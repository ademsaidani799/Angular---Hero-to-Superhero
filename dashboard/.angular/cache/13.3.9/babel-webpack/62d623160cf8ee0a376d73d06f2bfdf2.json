{"ast":null,"code":"/*\n Highcharts Gantt JS v10.2.1 (2022-08-29)\n\n (c) 2017-2021 Lars Cabrera, Torstein Honsi, Jon Arild Nygard & Oystein Moseng\n\n License: www.highcharts.com/license\n*/\n(function (U, O) {\n  \"object\" === typeof module && module.exports ? (O[\"default\"] = O, module.exports = U.document ? O(U) : O) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts-gantt\", function () {\n    return O(U);\n  }) : (U.Highcharts && U.Highcharts.error(16, !0), U.Highcharts = O(U));\n})(\"undefined\" !== typeof window ? window : this, function (U) {\n  function O(c, I, h, E) {\n    c.hasOwnProperty(I) || (c[I] = E.apply(null, h), \"function\" === typeof CustomEvent && U.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: I,\n        module: c[I]\n      }\n    })));\n  }\n\n  var h = {};\n  O(h, \"Core/Globals.js\", [], function () {\n    var c;\n\n    (function (c) {\n      c.SVG_NS = \"http://www.w3.org/2000/svg\";\n      c.product = \"Highcharts\";\n      c.version = \"10.2.1\";\n      c.win = \"undefined\" !== typeof U ? U : {};\n      c.doc = c.win.document;\n      c.svg = c.doc && c.doc.createElementNS && !!c.doc.createElementNS(c.SVG_NS, \"svg\").createSVGRect;\n      c.userAgent = c.win.navigator && c.win.navigator.userAgent || \"\";\n      c.isChrome = -1 !== c.userAgent.indexOf(\"Chrome\");\n      c.isFirefox = -1 !== c.userAgent.indexOf(\"Firefox\");\n      c.isMS = /(edge|msie|trident)/i.test(c.userAgent) && !c.win.opera;\n      c.isSafari = !c.isChrome && -1 !== c.userAgent.indexOf(\"Safari\");\n      c.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(c.userAgent);\n      c.isWebKit = -1 !== c.userAgent.indexOf(\"AppleWebKit\");\n      c.deg2rad = 2 * Math.PI / 360;\n      c.hasBidiBug = c.isFirefox && 4 > parseInt(c.userAgent.split(\"Firefox/\")[1], 10);\n      c.hasTouch = !!c.win.TouchEvent;\n      c.marginNames = [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"];\n\n      c.noop = function () {};\n\n      c.supportsPassiveEvents = function () {\n        var h = !1;\n\n        if (!c.isMS) {\n          var I = Object.defineProperty({}, \"passive\", {\n            get: function () {\n              h = !0;\n            }\n          });\n          c.win.addEventListener && c.win.removeEventListener && (c.win.addEventListener(\"testPassive\", c.noop, I), c.win.removeEventListener(\"testPassive\", c.noop, I));\n        }\n\n        return h;\n      }();\n\n      c.charts = [];\n      c.dateFormats = {};\n      c.seriesTypes = {};\n      c.symbolSizes = {};\n      c.chartCount = 0;\n    })(c || (c = {}));\n\n    \"\";\n    return c;\n  });\n  O(h, \"Core/Utilities.js\", [h[\"Core/Globals.js\"]], function (c) {\n    function h(l, g, e, z) {\n      var r = g ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === l && (l = \"\" + r + \": Deprecated member\");\n      var L = t(l),\n          G = L ? \"\" + r + \" #\" + l + \": www.highcharts.com/errors/\" + l + \"/\" : l.toString();\n\n      if (\"undefined\" !== typeof z) {\n        var q = \"\";\n        L && (G += \"?\");\n        M(z, function (C, g) {\n          q += \"\\n - \".concat(g, \": \").concat(C);\n          L && (G += encodeURI(g) + \"=\" + encodeURI(C));\n        });\n        G += q;\n      }\n\n      H(c, \"displayError\", {\n        chart: e,\n        code: l,\n        message: G,\n        params: z\n      }, function () {\n        if (g) throw Error(G);\n        a.console && -1 === h.messages.indexOf(G) && console.warn(G);\n      });\n      h.messages.push(G);\n    }\n\n    function B(l, g) {\n      var a = {};\n      M(l, function (z, r) {\n        if (F(l[r], !0) && !l.nodeType && g[r]) z = B(l[r], g[r]), Object.keys(z).length && (a[r] = z);else if (F(l[r]) || l[r] !== g[r] || r in l && !(r in g)) a[r] = l[r];\n      });\n      return a;\n    }\n\n    function E(l, g) {\n      return parseInt(l, g || 10);\n    }\n\n    function A(l) {\n      return \"string\" === typeof l;\n    }\n\n    function D(l) {\n      l = Object.prototype.toString.call(l);\n      return \"[object Array]\" === l || \"[object Array Iterator]\" === l;\n    }\n\n    function F(l, g) {\n      return !!l && \"object\" === typeof l && (!g || !D(l));\n    }\n\n    function y(l) {\n      return F(l) && \"number\" === typeof l.nodeType;\n    }\n\n    function p(l) {\n      var g = l && l.constructor;\n      return !(!F(l, !0) || y(l) || !g || !g.name || \"Object\" === g.name);\n    }\n\n    function t(l) {\n      return \"number\" === typeof l && !isNaN(l) && Infinity > l && -Infinity < l;\n    }\n\n    function b(l) {\n      return \"undefined\" !== typeof l && null !== l;\n    }\n\n    function k(l, g, a) {\n      var z = A(g) && !b(a),\n          r,\n          e = function (g, a) {\n        b(g) ? l.setAttribute(a, g) : z ? (r = l.getAttribute(a)) || \"class\" !== a || (r = l.getAttribute(a + \"Name\")) : l.removeAttribute(a);\n      };\n\n      A(g) ? e(a, g) : M(g, e);\n      return r;\n    }\n\n    function n(l, g) {\n      var a;\n      l || (l = {});\n\n      for (a in g) l[a] = g[a];\n\n      return l;\n    }\n\n    function m() {\n      for (var l = arguments, g = l.length, a = 0; a < g; a++) {\n        var z = l[a];\n        if (\"undefined\" !== typeof z && null !== z) return z;\n      }\n    }\n\n    function f(l, g) {\n      c.isMS && !c.svg && g && b(g.opacity) && (g.filter = \"alpha(opacity=\".concat(100 * g.opacity, \")\"));\n      n(l.style, g);\n    }\n\n    function d(l) {\n      return Math.pow(10, Math.floor(Math.log(l) / Math.LN10));\n    }\n\n    function v(l, g) {\n      return 1E14 < l ? l : parseFloat(l.toPrecision(g || 14));\n    }\n\n    function K(l, g, e) {\n      var z = c.getStyle || K;\n      if (\"width\" === g) return g = Math.min(l.offsetWidth, l.scrollWidth), e = l.getBoundingClientRect && l.getBoundingClientRect().width, e < g && e >= g - 1 && (g = Math.floor(e)), Math.max(0, g - (z(l, \"padding-left\", !0) || 0) - (z(l, \"padding-right\", !0) || 0));\n      if (\"height\" === g) return Math.max(0, Math.min(l.offsetHeight, l.scrollHeight) - (z(l, \"padding-top\", !0) || 0) - (z(l, \"padding-bottom\", !0) || 0));\n      a.getComputedStyle || h(27, !0);\n\n      if (l = a.getComputedStyle(l, void 0)) {\n        var r = l.getPropertyValue(g);\n        m(e, \"opacity\" !== g) && (r = E(r));\n      }\n\n      return r;\n    }\n\n    function M(l, g, a) {\n      for (var z in l) Object.hasOwnProperty.call(l, z) && g.call(a || l[z], l[z], z, l);\n    }\n\n    function N(l, g, a) {\n      function z(g, C) {\n        var z = l.removeEventListener || c.removeEventListenerPolyfill;\n        z && z.call(l, g, C, !1);\n      }\n\n      function r(r) {\n        var C;\n\n        if (l.nodeName) {\n          if (g) {\n            var a = {};\n            a[g] = !0;\n          } else a = r;\n\n          M(a, function (g, l) {\n            if (r[l]) for (C = r[l].length; C--;) z(l, r[l][C].fn);\n          });\n        }\n      }\n\n      var e = \"function\" === typeof l && l.prototype || l;\n\n      if (Object.hasOwnProperty.call(e, \"hcEvents\")) {\n        var G = e.hcEvents;\n        g ? (e = G[g] || [], a ? (G[g] = e.filter(function (g) {\n          return a !== g.fn;\n        }), z(g, a)) : (r(G), G[g] = [])) : (r(G), delete e.hcEvents);\n      }\n    }\n\n    function H(l, g, a, z) {\n      a = a || {};\n\n      if (w.createEvent && (l.dispatchEvent || l.fireEvent && l !== c)) {\n        var r = w.createEvent(\"Events\");\n        r.initEvent(g, !0, !0);\n        a = n(r, a);\n        l.dispatchEvent ? l.dispatchEvent(a) : l.fireEvent(g, a);\n      } else if (l.hcEvents) {\n        a.target || n(a, {\n          preventDefault: function () {\n            a.defaultPrevented = !0;\n          },\n          target: l,\n          type: g\n        });\n        r = [];\n\n        for (var e = l, G = !1; e.hcEvents;) Object.hasOwnProperty.call(e, \"hcEvents\") && e.hcEvents[g] && (r.length && (G = !0), r.unshift.apply(r, e.hcEvents[g])), e = Object.getPrototypeOf(e);\n\n        G && r.sort(function (g, C) {\n          return g.order - C.order;\n        });\n        r.forEach(function (g) {\n          !1 === g.fn.call(l, a) && a.preventDefault();\n        });\n      }\n\n      z && !a.defaultPrevented && z.call(l, a);\n    }\n\n    var q = c.charts,\n        w = c.doc,\n        a = c.win;\n    (h || (h = {})).messages = [];\n\n    Math.easeInOutSine = function (l) {\n      return -.5 * (Math.cos(Math.PI * l) - 1);\n    };\n\n    var x = Array.prototype.find ? function (l, g) {\n      return l.find(g);\n    } : function (l, g) {\n      var a,\n          z = l.length;\n\n      for (a = 0; a < z; a++) if (g(l[a], a)) return l[a];\n    };\n    M({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (a, g) {\n      c[g] = function (l) {\n        var z;\n        h(32, !1, void 0, (z = {}, z[\"Highcharts.\".concat(g)] = \"use Array.\".concat(a), z));\n        return Array.prototype[a].apply(l, [].slice.call(arguments, 1));\n      };\n    });\n\n    var e,\n        u = function () {\n      var a = Math.random().toString(36).substring(2, 9) + \"-\",\n          g = 0;\n      return function () {\n        return \"highcharts-\" + (e ? \"\" : a) + g++;\n      };\n    }();\n\n    a.jQuery && (a.jQuery.fn.highcharts = function () {\n      var a = [].slice.call(arguments);\n      if (this[0]) return a[0] ? (new c[A(a[0]) ? a.shift() : \"Chart\"](this[0], a[0], a[1]), this) : q[k(this[0], \"data-highcharts-chart\")];\n    });\n    x = {\n      addEvent: function (a, g, e, z) {\n        void 0 === z && (z = {});\n        var r = \"function\" === typeof a && a.prototype || a;\n        Object.hasOwnProperty.call(r, \"hcEvents\") || (r.hcEvents = {});\n        r = r.hcEvents;\n        c.Point && a instanceof c.Point && a.series && a.series.chart && (a.series.chart.runTrackerClick = !0);\n        var l = a.addEventListener || c.addEventListenerPolyfill;\n        l && l.call(a, g, e, c.supportsPassiveEvents ? {\n          passive: void 0 === z.passive ? -1 !== g.indexOf(\"touch\") : z.passive,\n          capture: !1\n        } : !1);\n        r[g] || (r[g] = []);\n        r[g].push({\n          fn: e,\n          order: \"number\" === typeof z.order ? z.order : Infinity\n        });\n        r[g].sort(function (g, a) {\n          return g.order - a.order;\n        });\n        return function () {\n          N(a, g, e);\n        };\n      },\n      arrayMax: function (a) {\n        for (var g = a.length, l = a[0]; g--;) a[g] > l && (l = a[g]);\n\n        return l;\n      },\n      arrayMin: function (a) {\n        for (var g = a.length, l = a[0]; g--;) a[g] < l && (l = a[g]);\n\n        return l;\n      },\n      attr: k,\n      clamp: function (a, g, e) {\n        return a > g ? a < e ? a : e : g;\n      },\n      cleanRecursively: B,\n      clearTimeout: function (a) {\n        b(a) && clearTimeout(a);\n      },\n      correctFloat: v,\n      createElement: function (a, g, e, z, r) {\n        a = w.createElement(a);\n        g && n(a, g);\n        r && f(a, {\n          padding: \"0\",\n          border: \"none\",\n          margin: \"0\"\n        });\n        e && f(a, e);\n        z && z.appendChild(a);\n        return a;\n      },\n      css: f,\n      defined: b,\n      destroyObjectProperties: function (a, g) {\n        M(a, function (e, z) {\n          e && e !== g && e.destroy && e.destroy();\n          delete a[z];\n        });\n      },\n      discardElement: function (a) {\n        a && a.parentElement && a.parentElement.removeChild(a);\n      },\n      erase: function (a, g) {\n        for (var e = a.length; e--;) if (a[e] === g) {\n          a.splice(e, 1);\n          break;\n        }\n      },\n      error: h,\n      extend: n,\n      extendClass: function (a, g) {\n        var e = function () {};\n\n        e.prototype = new a();\n        n(e.prototype, g);\n        return e;\n      },\n      find: x,\n      fireEvent: H,\n      getMagnitude: d,\n      getNestedProperty: function (e, g) {\n        for (e = e.split(\".\"); e.length && b(g);) {\n          var l = e.shift();\n          if (\"undefined\" === typeof l || \"__proto__\" === l) return;\n          g = g[l];\n          if (!b(g) || \"function\" === typeof g || \"number\" === typeof g.nodeType || g === a) return;\n        }\n\n        return g;\n      },\n      getStyle: K,\n      inArray: function (a, g, e) {\n        h(32, !1, void 0, {\n          \"Highcharts.inArray\": \"use Array.indexOf\"\n        });\n        return g.indexOf(a, e);\n      },\n      isArray: D,\n      isClass: p,\n      isDOMElement: y,\n      isFunction: function (a) {\n        return \"function\" === typeof a;\n      },\n      isNumber: t,\n      isObject: F,\n      isString: A,\n      keys: function (a) {\n        h(32, !1, void 0, {\n          \"Highcharts.keys\": \"use Object.keys\"\n        });\n        return Object.keys(a);\n      },\n      merge: function () {\n        var a,\n            g = arguments,\n            e = {},\n            z = function (a, g) {\n          \"object\" !== typeof a && (a = {});\n          M(g, function (r, C) {\n            \"__proto__\" !== C && \"constructor\" !== C && (!F(r, !0) || p(r) || y(r) ? a[C] = g[C] : a[C] = z(a[C] || {}, r));\n          });\n          return a;\n        };\n\n        !0 === g[0] && (e = g[1], g = Array.prototype.slice.call(g, 2));\n        var r = g.length;\n\n        for (a = 0; a < r; a++) e = z(e, g[a]);\n\n        return e;\n      },\n      normalizeTickInterval: function (a, g, e, z, r) {\n        var l = a;\n        e = m(e, d(a));\n        var q = a / e;\n        g || (g = r ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === z && (1 === e ? g = g.filter(function (a) {\n          return 0 === a % 1;\n        }) : .1 >= e && (g = [1 / e])));\n\n        for (z = 0; z < g.length && !(l = g[z], r && l * e >= a || !r && q <= (g[z] + (g[z + 1] || g[z])) / 2); z++);\n\n        return l = v(l * e, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: M,\n      offset: function (e) {\n        var g = w.documentElement;\n        e = e.parentElement || e.parentNode ? e.getBoundingClientRect() : {\n          top: 0,\n          left: 0,\n          width: 0,\n          height: 0\n        };\n        return {\n          top: e.top + (a.pageYOffset || g.scrollTop) - (g.clientTop || 0),\n          left: e.left + (a.pageXOffset || g.scrollLeft) - (g.clientLeft || 0),\n          width: e.width,\n          height: e.height\n        };\n      },\n      pad: function (a, g, e) {\n        return Array((g || 2) + 1 - String(a).replace(\"-\", \"\").length).join(e || \"0\") + a;\n      },\n      pick: m,\n      pInt: E,\n      relativeLength: function (a, g, e) {\n        return /%$/.test(a) ? g * parseFloat(a) / 100 + (e || 0) : parseFloat(a);\n      },\n      removeEvent: N,\n      splat: function (a) {\n        return D(a) ? a : [a];\n      },\n      stableSort: function (a, g) {\n        var e = a.length,\n            z,\n            r;\n\n        for (r = 0; r < e; r++) a[r].safeI = r;\n\n        a.sort(function (a, e) {\n          z = g(a, e);\n          return 0 === z ? a.safeI - e.safeI : z;\n        });\n\n        for (r = 0; r < e; r++) delete a[r].safeI;\n      },\n      syncTimeout: function (a, g, e) {\n        if (0 < g) return setTimeout(a, g, e);\n        a.call(0, e);\n        return -1;\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1E3,\n        minute: 6E4,\n        hour: 36E5,\n        day: 864E5,\n        week: 6048E5,\n        month: 24192E5,\n        year: 314496E5\n      },\n      uniqueKey: u,\n      useSerialIds: function (a) {\n        return e = m(a, e);\n      },\n      wrap: function (a, g, e) {\n        var z = a[g];\n\n        a[g] = function () {\n          var a = Array.prototype.slice.call(arguments),\n              g = arguments,\n              l = this;\n\n          l.proceed = function () {\n            z.apply(l, arguments.length ? arguments : g);\n          };\n\n          a.unshift(z);\n          a = e.apply(this, a);\n          l.proceed = null;\n          return a;\n        };\n      }\n    };\n    \"\";\n    return x;\n  });\n  O(h, \"Core/Chart/ChartDefaults.js\", [], function () {\n    return {\n      alignThresholds: !1,\n      panning: {\n        enabled: !1,\n        type: \"x\"\n      },\n      styledMode: !1,\n      borderRadius: 0,\n      colorCount: 10,\n      allowMutatingData: !0,\n      defaultSeriesType: \"line\",\n      ignoreHiddenSeries: !0,\n      spacing: [10, 10, 15, 10],\n      resetZoomButton: {\n        theme: {\n          zIndex: 6\n        },\n        position: {\n          align: \"right\",\n          x: -10,\n          y: 10\n        }\n      },\n      zoomBySingleTouch: !1,\n      zooming: {\n        singleTouch: !1,\n        resetButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        }\n      },\n      width: null,\n      height: null,\n      borderColor: \"#335cad\",\n      backgroundColor: \"#ffffff\",\n      plotBorderColor: \"#cccccc\"\n    };\n  });\n  O(h, \"Core/Color/Color.js\", [h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    var I = h.isNumber,\n        E = h.merge,\n        A = h.pInt;\n\n    h = function () {\n      function h(F) {\n        this.rgba = [NaN, NaN, NaN, NaN];\n        this.input = F;\n        var y = c.Color;\n        if (y && y !== h) return new y(F);\n        if (!(this instanceof h)) return new h(F);\n        this.init(F);\n      }\n\n      h.parse = function (c) {\n        return c ? new h(c) : h.None;\n      };\n\n      h.prototype.init = function (c) {\n        var y;\n        if (\"object\" === typeof c && \"undefined\" !== typeof c.stops) this.stops = c.stops.map(function (b) {\n          return new h(b[1]);\n        });else if (\"string\" === typeof c) {\n          this.input = c = h.names[c.toLowerCase()] || c;\n\n          if (\"#\" === c.charAt(0)) {\n            var p = c.length;\n            var t = parseInt(c.substr(1), 16);\n            7 === p ? y = [(t & 16711680) >> 16, (t & 65280) >> 8, t & 255, 1] : 4 === p && (y = [(t & 3840) >> 4 | (t & 3840) >> 8, (t & 240) >> 4 | t & 240, (t & 15) << 4 | t & 15, 1]);\n          }\n\n          if (!y) for (t = h.parsers.length; t-- && !y;) {\n            var b = h.parsers[t];\n            (p = b.regex.exec(c)) && (y = b.parse(p));\n          }\n        }\n        y && (this.rgba = y);\n      };\n\n      h.prototype.get = function (c) {\n        var y = this.input,\n            p = this.rgba;\n\n        if (\"object\" === typeof y && \"undefined\" !== typeof this.stops) {\n          var t = E(y);\n          t.stops = [].slice.call(t.stops);\n          this.stops.forEach(function (b, k) {\n            t.stops[k] = [t.stops[k][0], b.get(c)];\n          });\n          return t;\n        }\n\n        return p && I(p[0]) ? \"rgb\" === c || !c && 1 === p[3] ? \"rgb(\" + p[0] + \",\" + p[1] + \",\" + p[2] + \")\" : \"a\" === c ? \"\".concat(p[3]) : \"rgba(\" + p.join(\",\") + \")\" : y;\n      };\n\n      h.prototype.brighten = function (c) {\n        var y = this.rgba;\n        if (this.stops) this.stops.forEach(function (p) {\n          p.brighten(c);\n        });else if (I(c) && 0 !== c) for (var p = 0; 3 > p; p++) y[p] += A(255 * c), 0 > y[p] && (y[p] = 0), 255 < y[p] && (y[p] = 255);\n        return this;\n      };\n\n      h.prototype.setOpacity = function (c) {\n        this.rgba[3] = c;\n        return this;\n      };\n\n      h.prototype.tweenTo = function (c, y) {\n        var p = this.rgba,\n            t = c.rgba;\n        if (!I(p[0]) || !I(t[0])) return c.input || \"none\";\n        c = 1 !== t[3] || 1 !== p[3];\n        return (c ? \"rgba(\" : \"rgb(\") + Math.round(t[0] + (p[0] - t[0]) * (1 - y)) + \",\" + Math.round(t[1] + (p[1] - t[1]) * (1 - y)) + \",\" + Math.round(t[2] + (p[2] - t[2]) * (1 - y)) + (c ? \",\" + (t[3] + (p[3] - t[3]) * (1 - y)) : \"\") + \")\";\n      };\n\n      h.names = {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      };\n      h.parsers = [{\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function (c) {\n          return [A(c[1]), A(c[2]), A(c[3]), parseFloat(c[4], 10)];\n        }\n      }, {\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function (c) {\n          return [A(c[1]), A(c[2]), A(c[3]), 1];\n        }\n      }];\n      h.None = new h(\"\");\n      return h;\n    }();\n\n    \"\";\n    return h;\n  });\n  O(h, \"Core/Color/Palettes.js\", [], function () {\n    return {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \")\n    };\n  });\n  O(h, \"Core/Time.js\", [h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    var I = c.win,\n        E = h.defined,\n        A = h.error,\n        D = h.extend,\n        F = h.isObject,\n        y = h.merge,\n        p = h.objectEach,\n        t = h.pad,\n        b = h.pick,\n        k = h.splat,\n        n = h.timeUnits,\n        m = c.isSafari && I.Intl && I.Intl.DateTimeFormat.prototype.formatRange,\n        f = c.isSafari && I.Intl && !I.Intl.DateTimeFormat.prototype.formatRange;\n\n    h = function () {\n      function d(d) {\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = I.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(d);\n      }\n\n      d.prototype.get = function (d, f) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          var v = f.getTime(),\n              b = v - this.getTimezoneOffset(f);\n          f.setTime(b);\n          d = f[\"getUTC\" + d]();\n          f.setTime(v);\n          return d;\n        }\n\n        return this.useUTC ? f[\"getUTC\" + d]() : f[\"get\" + d]();\n      };\n\n      d.prototype.set = function (d, f, b) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === d || \"Seconds\" === d || \"Minutes\" === d && 0 === this.getTimezoneOffset(f) % 36E5) return f[\"setUTC\" + d](b);\n          var v = this.getTimezoneOffset(f);\n          v = f.getTime() - v;\n          f.setTime(v);\n          f[\"setUTC\" + d](b);\n          d = this.getTimezoneOffset(f);\n          v = f.getTime() + d;\n          return f.setTime(v);\n        }\n\n        return this.useUTC || m && \"FullYear\" === d ? f[\"setUTC\" + d](b) : f[\"set\" + d](b);\n      };\n\n      d.prototype.update = function (d) {\n        var f = b(d && d.useUTC, !0);\n        this.options = d = y(!0, this.options || {}, d);\n        this.Date = d.Date || I.Date || Date;\n        this.timezoneOffset = (this.useUTC = f) && d.timezoneOffset || void 0;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.variableTimezone = f && !(!d.getTimezoneOffset && !d.timezone);\n      };\n\n      d.prototype.makeTime = function (d, m, k, n, H, q) {\n        if (this.useUTC) {\n          var w = this.Date.UTC.apply(0, arguments);\n          var a = this.getTimezoneOffset(w);\n          w += a;\n          var x = this.getTimezoneOffset(w);\n          a !== x ? w += x - a : a - 36E5 !== this.getTimezoneOffset(w - 36E5) || f || (w -= 36E5);\n        } else w = new this.Date(d, m, b(k, 1), b(n, 0), b(H, 0), b(q, 0)).getTime();\n\n        return w;\n      };\n\n      d.prototype.timezoneOffsetFunction = function () {\n        var d = this,\n            f = this.options,\n            b = f.getTimezoneOffset,\n            m = f.moment || I.moment;\n        if (!this.useUTC) return function (d) {\n          return 6E4 * new Date(d.toString()).getTimezoneOffset();\n        };\n\n        if (f.timezone) {\n          if (m) return function (d) {\n            return 6E4 * -m.tz(d, f.timezone).utcOffset();\n          };\n          A(25);\n        }\n\n        return this.useUTC && b ? function (d) {\n          return 6E4 * b(d.valueOf());\n        } : function () {\n          return 6E4 * (d.timezoneOffset || 0);\n        };\n      };\n\n      d.prototype.dateFormat = function (d, f, m) {\n        if (!E(f) || isNaN(f)) return c.defaultOptions.lang && c.defaultOptions.lang.invalidDate || \"\";\n        d = b(d, \"%Y-%m-%d %H:%M:%S\");\n        var v = this,\n            k = new this.Date(f),\n            q = this.get(\"Hours\", k),\n            w = this.get(\"Day\", k),\n            a = this.get(\"Date\", k),\n            x = this.get(\"Month\", k),\n            e = this.get(\"FullYear\", k),\n            u = c.defaultOptions.lang,\n            l = u && u.weekdays,\n            g = u && u.shortWeekdays;\n        k = D({\n          a: g ? g[w] : l[w].substr(0, 3),\n          A: l[w],\n          d: t(a),\n          e: t(a, 2, \" \"),\n          w: w,\n          b: u.shortMonths[x],\n          B: u.months[x],\n          m: t(x + 1),\n          o: x + 1,\n          y: e.toString().substr(2, 2),\n          Y: e,\n          H: t(q),\n          k: q,\n          I: t(q % 12 || 12),\n          l: q % 12 || 12,\n          M: t(this.get(\"Minutes\", k)),\n          p: 12 > q ? \"AM\" : \"PM\",\n          P: 12 > q ? \"am\" : \"pm\",\n          S: t(k.getSeconds()),\n          L: t(Math.floor(f % 1E3), 3)\n        }, c.dateFormats);\n        p(k, function (a, g) {\n          for (; -1 !== d.indexOf(\"%\" + g);) d = d.replace(\"%\" + g, \"function\" === typeof a ? a.call(v, f) : a);\n        });\n        return m ? d.substr(0, 1).toUpperCase() + d.substr(1) : d;\n      };\n\n      d.prototype.resolveDTLFormat = function (d) {\n        return F(d, !0) ? d : (d = k(d), {\n          main: d[0],\n          from: d[1],\n          to: d[2]\n        });\n      };\n\n      d.prototype.getTimeTicks = function (d, f, k, m) {\n        var v = this,\n            q = [],\n            w = {},\n            a = new v.Date(f),\n            x = d.unitRange,\n            e = d.count || 1,\n            u;\n        m = b(m, 1);\n\n        if (E(f)) {\n          v.set(\"Milliseconds\", a, x >= n.second ? 0 : e * Math.floor(v.get(\"Milliseconds\", a) / e));\n          x >= n.second && v.set(\"Seconds\", a, x >= n.minute ? 0 : e * Math.floor(v.get(\"Seconds\", a) / e));\n          x >= n.minute && v.set(\"Minutes\", a, x >= n.hour ? 0 : e * Math.floor(v.get(\"Minutes\", a) / e));\n          x >= n.hour && v.set(\"Hours\", a, x >= n.day ? 0 : e * Math.floor(v.get(\"Hours\", a) / e));\n          x >= n.day && v.set(\"Date\", a, x >= n.month ? 1 : Math.max(1, e * Math.floor(v.get(\"Date\", a) / e)));\n\n          if (x >= n.month) {\n            v.set(\"Month\", a, x >= n.year ? 0 : e * Math.floor(v.get(\"Month\", a) / e));\n            var l = v.get(\"FullYear\", a);\n          }\n\n          x >= n.year && v.set(\"FullYear\", a, l - l % e);\n          x === n.week && (l = v.get(\"Day\", a), v.set(\"Date\", a, v.get(\"Date\", a) - l + m + (l < m ? -7 : 0)));\n          l = v.get(\"FullYear\", a);\n          m = v.get(\"Month\", a);\n          var g = v.get(\"Date\", a),\n              G = v.get(\"Hours\", a);\n          f = a.getTime();\n          !v.variableTimezone && v.useUTC || !E(k) || (u = k - f > 4 * n.month || v.getTimezoneOffset(f) !== v.getTimezoneOffset(k));\n          f = a.getTime();\n\n          for (a = 1; f < k;) q.push(f), f = x === n.year ? v.makeTime(l + a * e, 0) : x === n.month ? v.makeTime(l, m + a * e) : !u || x !== n.day && x !== n.week ? u && x === n.hour && 1 < e ? v.makeTime(l, m, g, G + a * e) : f + x * e : v.makeTime(l, m, g + a * e * (x === n.day ? 1 : 7)), a++;\n\n          q.push(f);\n          x <= n.hour && 1E4 > q.length && q.forEach(function (a) {\n            0 === a % 18E5 && \"000000000\" === v.dateFormat(\"%H%M%S%L\", a) && (w[a] = \"day\");\n          });\n        }\n\n        q.info = D(d, {\n          higherRanks: w,\n          totalRange: x * e\n        });\n        return q;\n      };\n\n      d.prototype.getDateFormat = function (d, f, b, m) {\n        var v = this.dateFormat(\"%m-%d %H:%M:%S.%L\", f),\n            q = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            w = \"millisecond\";\n\n        for (a in n) {\n          if (d === n.week && +this.dateFormat(\"%w\", f) === b && \"00:00:00.000\" === v.substr(6)) {\n            var a = \"week\";\n            break;\n          }\n\n          if (n[a] > d) {\n            a = w;\n            break;\n          }\n\n          if (q[a] && v.substr(q[a]) !== \"01-01 00:00:00.000\".substr(q[a])) break;\n          \"week\" !== a && (w = a);\n        }\n\n        return this.resolveDTLFormat(m[a]).main;\n      };\n\n      return d;\n    }();\n\n    \"\";\n    return h;\n  });\n  O(h, \"Core/DefaultOptions.js\", [h[\"Core/Chart/ChartDefaults.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Color/Palettes.js\"], h[\"Core/Time.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A, D) {\n    h = h.parse;\n    var I = D.merge,\n        y = {\n      colors: E.colors,\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: {\n        Date: void 0,\n        getTimezoneOffset: void 0,\n        timezone: void 0,\n        timezoneOffset: 0,\n        useUTC: !0\n      },\n      chart: c,\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      caption: {\n        margin: 15,\n        text: \"\",\n        align: \"left\",\n        verticalAlign: \"bottom\"\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        className: \"highcharts-no-tooltip\",\n        layout: \"horizontal\",\n        labelFormatter: function () {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: B.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        headerShape: \"callout\",\n        hideDelay: 500,\n        padding: 8,\n        shape: \"callout\",\n        shared: !1,\n        snap: B.isTouchDevice ? 25 : 10,\n        headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n        backgroundColor: h(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        stickOnContact: !1,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          whiteSpace: \"nowrap\"\n        },\n        useHTML: !1\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n    y.chart.styledMode = !1;\n    \"\";\n    var p = new A(I(y.global, y.time));\n    c = {\n      defaultOptions: y,\n      defaultTime: p,\n      getOptions: function () {\n        return y;\n      },\n      setOptions: function (t) {\n        I(!0, y, t);\n        if (t.time || t.global) B.time ? B.time.update(I(y.global, y.time, t.global, t.time)) : B.time = p;\n        return y;\n      }\n    };\n    \"\";\n    return c;\n  });\n  O(h, \"Core/Animation/Fx.js\", [h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var I = c.parse,\n        A = h.win,\n        D = B.isNumber,\n        F = B.objectEach;\n    return function () {\n      function c(p, t, b) {\n        this.pos = NaN;\n        this.options = t;\n        this.elem = p;\n        this.prop = b;\n      }\n\n      c.prototype.dSetter = function () {\n        var p = this.paths,\n            t = p && p[0];\n        p = p && p[1];\n        var b = this.now || 0,\n            k = [];\n        if (1 !== b && t && p) {\n          if (t.length === p.length && 1 > b) for (var n = 0; n < p.length; n++) {\n            for (var m = t[n], f = p[n], d = [], v = 0; v < f.length; v++) {\n              var K = m[v],\n                  c = f[v];\n              D(K) && D(c) && (\"A\" !== f[0] || 4 !== v && 5 !== v) ? d[v] = K + b * (c - K) : d[v] = c;\n            }\n\n            k.push(d);\n          } else k = p;\n        } else k = this.toD || [];\n        this.elem.attr(\"d\", k, void 0, !0);\n      };\n\n      c.prototype.update = function () {\n        var p = this.elem,\n            t = this.prop,\n            b = this.now,\n            k = this.options.step;\n        if (this[t + \"Setter\"]) this[t + \"Setter\"]();else p.attr ? p.element && p.attr(t, b, null, !0) : p.style[t] = b + this.unit;\n        k && k.call(p, b, this);\n      };\n\n      c.prototype.run = function (p, t, b) {\n        var k = this,\n            n = k.options,\n            m = function (d) {\n          return m.stopped ? !1 : k.step(d);\n        },\n            f = A.requestAnimationFrame || function (d) {\n          setTimeout(d, 13);\n        },\n            d = function () {\n          for (var v = 0; v < c.timers.length; v++) c.timers[v]() || c.timers.splice(v--, 1);\n\n          c.timers.length && f(d);\n        };\n\n        p !== t || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = p, this.end = t, this.unit = b, this.now = this.start, this.pos = 0, m.elem = this.elem, m.prop = this.prop, m() && 1 === c.timers.push(m) && f(d)) : (delete n.curAnim[this.prop], n.complete && 0 === Object.keys(n.curAnim).length && n.complete.call(this.elem));\n      };\n\n      c.prototype.step = function (p) {\n        var t = +new Date(),\n            b = this.options,\n            k = this.elem,\n            n = b.complete,\n            m = b.duration,\n            f = b.curAnim;\n        if (k.attr && !k.element) p = !1;else if (p || t >= m + this.startTime) {\n          this.now = this.end;\n          this.pos = 1;\n          this.update();\n          var d = f[this.prop] = !0;\n          F(f, function (f) {\n            !0 !== f && (d = !1);\n          });\n          d && n && n.call(k);\n          p = !1;\n        } else this.pos = b.easing((t - this.startTime) / m), this.now = this.start + (this.end - this.start) * this.pos, this.update(), p = !0;\n        return p;\n      };\n\n      c.prototype.initPath = function (p, t, b) {\n        function k(f, q) {\n          for (; f.length < N;) {\n            var w = f[0],\n                a = q[N - f.length];\n            a && \"M\" === w[0] && (f[0] = \"C\" === a[0] ? [\"C\", w[1], w[2], w[1], w[2], w[1], w[2]] : [\"L\", w[1], w[2]]);\n            f.unshift(w);\n            d && (w = f.pop(), f.push(f[f.length - 1], w));\n          }\n        }\n\n        function n(f, q) {\n          for (; f.length < N;) if (q = f[Math.floor(f.length / v) - 1].slice(), \"C\" === q[0] && (q[1] = q[5], q[2] = q[6]), d) {\n            var w = f[Math.floor(f.length / v)].slice();\n            f.splice(f.length / 2, 0, q, w);\n          } else f.push(q);\n        }\n\n        var m = p.startX,\n            f = p.endX;\n        b = b.slice();\n        var d = p.isArea,\n            v = d ? 2 : 1;\n        t = t && t.slice();\n        if (!t) return [b, b];\n\n        if (m && f && f.length) {\n          for (p = 0; p < m.length; p++) if (m[p] === f[0]) {\n            var K = p;\n            break;\n          } else if (m[0] === f[f.length - m.length + p]) {\n            K = p;\n            var c = !0;\n            break;\n          } else if (m[m.length - 1] === f[f.length - m.length + p]) {\n            K = m.length - p;\n            break;\n          }\n\n          \"undefined\" === typeof K && (t = []);\n        }\n\n        if (t.length && D(K)) {\n          var N = b.length + K * v;\n          c ? (k(t, b), n(b, t)) : (k(b, t), n(t, b));\n        }\n\n        return [t, b];\n      };\n\n      c.prototype.fillSetter = function () {\n        c.prototype.strokeSetter.apply(this, arguments);\n      };\n\n      c.prototype.strokeSetter = function () {\n        this.elem.attr(this.prop, I(this.start).tweenTo(I(this.end), this.pos), void 0, !0);\n      };\n\n      c.timers = [];\n      return c;\n    }();\n  });\n  O(h, \"Core/Animation/AnimationUtilities.js\", [h[\"Core/Animation/Fx.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    function I(b) {\n      return p(b) ? t({\n        duration: 500,\n        defer: 0\n      }, b) : {\n        duration: b ? 500 : 0,\n        defer: 0\n      };\n    }\n\n    function E(b, m) {\n      for (var f = c.timers.length; f--;) c.timers[f].elem !== b || m && m !== c.timers[f].prop || (c.timers[f].stopped = !0);\n    }\n\n    var A = h.defined,\n        D = h.getStyle,\n        F = h.isArray,\n        y = h.isNumber,\n        p = h.isObject,\n        t = h.merge,\n        b = h.objectEach,\n        k = h.pick;\n    return {\n      animate: function (k, m, f) {\n        var d,\n            v = \"\",\n            n,\n            M;\n\n        if (!p(f)) {\n          var N = arguments;\n          f = {\n            duration: N[2],\n            easing: N[3],\n            complete: N[4]\n          };\n        }\n\n        y(f.duration) || (f.duration = 400);\n        f.easing = \"function\" === typeof f.easing ? f.easing : Math[f.easing] || Math.easeInOutSine;\n        f.curAnim = t(m);\n        b(m, function (b, q) {\n          E(k, q);\n          M = new c(k, f, q);\n          n = void 0;\n          \"d\" === q && F(m.d) ? (M.paths = M.initPath(k, k.pathArray, m.d), M.toD = m.d, d = 0, n = 1) : k.attr ? d = k.attr(q) : (d = parseFloat(D(k, q)) || 0, \"opacity\" !== q && (v = \"px\"));\n          n || (n = b);\n          \"string\" === typeof n && n.match(\"px\") && (n = n.replace(/px/g, \"\"));\n          M.run(d, n, v);\n        });\n      },\n      animObject: I,\n      getDeferredAnimation: function (b, k, f) {\n        var d = I(k),\n            v = 0,\n            m = 0;\n        (f ? [f] : b.series).forEach(function (f) {\n          f = I(f.options.animation);\n          v = k && A(k.defer) ? d.defer : Math.max(v, f.duration + f.defer);\n          m = Math.min(d.duration, f.duration);\n        });\n        b.renderer.forExport && (v = 0);\n        return {\n          defer: Math.max(0, v - m),\n          duration: Math.min(v, m)\n        };\n      },\n      setAnimation: function (b, m) {\n        m.renderer.globalAnimation = k(b, m.options.chart.animation, !0);\n      },\n      stop: E\n    };\n  });\n  O(h, \"Core/Renderer/HTML/AST.js\", [h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    var I = c.SVG_NS,\n        E = h.attr,\n        A = h.createElement,\n        D = h.css,\n        F = h.error,\n        y = h.isFunction,\n        p = h.isString,\n        t = h.objectEach,\n        b = h.splat,\n        k = (h = c.win.trustedTypes) && y(h.createPolicy) && h.createPolicy(\"highcharts\", {\n      createHTML: function (f) {\n        return f;\n      }\n    }),\n        n = k ? k.createHTML(\"\") : \"\";\n\n    try {\n      var m = !!new DOMParser().parseFromString(n, \"text/html\");\n    } catch (f) {\n      m = !1;\n    }\n\n    y = function () {\n      function f(d) {\n        this.nodes = \"string\" === typeof d ? this.parseMarkup(d) : d;\n      }\n\n      f.filterUserAttributes = function (d) {\n        t(d, function (b, k) {\n          var v = !0;\n          -1 === f.allowedAttributes.indexOf(k) && (v = !1);\n          -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(k) && (v = p(b) && f.allowedReferences.some(function (d) {\n            return 0 === b.indexOf(d);\n          }));\n          v || (F(33, !1, void 0, {\n            \"Invalid attribute in config\": \"\".concat(k)\n          }), delete d[k]);\n        });\n        return d;\n      };\n\n      f.parseStyle = function (d) {\n        return d.split(\";\").reduce(function (d, f) {\n          f = f.split(\":\").map(function (d) {\n            return d.trim();\n          });\n          var b = f.shift();\n          b && f.length && (d[b.replace(/-([a-z])/g, function (d) {\n            return d[1].toUpperCase();\n          })] = f.join(\":\"));\n          return d;\n        }, {});\n      };\n\n      f.setElementHTML = function (d, b) {\n        d.innerHTML = f.emptyHTML;\n        b && new f(b).addToDOM(d);\n      };\n\n      f.prototype.addToDOM = function (d) {\n        function k(d, v) {\n          var m;\n          b(d).forEach(function (d) {\n            var q = d.tagName,\n                b = d.textContent ? c.doc.createTextNode(d.textContent) : void 0,\n                a = f.bypassHTMLFiltering;\n            if (q) if (\"#text\" === q) var x = b;else if (-1 !== f.allowedTags.indexOf(q) || a) {\n              q = c.doc.createElementNS(\"svg\" === q ? I : v.namespaceURI || I, q);\n              var e = d.attributes || {};\n              t(d, function (a, l) {\n                \"tagName\" !== l && \"attributes\" !== l && \"children\" !== l && \"style\" !== l && \"textContent\" !== l && (e[l] = a);\n              });\n              E(q, a ? e : f.filterUserAttributes(e));\n              d.style && D(q, d.style);\n              b && q.appendChild(b);\n              k(d.children || [], q);\n              x = q;\n            } else F(33, !1, void 0, {\n              \"Invalid tagName in config\": q\n            });\n            x && v.appendChild(x);\n            m = x;\n          });\n          return m;\n        }\n\n        return k(this.nodes, d);\n      };\n\n      f.prototype.parseMarkup = function (d) {\n        var b = [];\n        d = d.trim().replace(/ style=([\"'])/g, \" data-style=$1\");\n        if (m) d = new DOMParser().parseFromString(k ? k.createHTML(d) : d, \"text/html\");else {\n          var n = A(\"div\");\n          n.innerHTML = d;\n          d = {\n            body: n\n          };\n        }\n\n        var p = function (d, b) {\n          var q = d.nodeName.toLowerCase(),\n              w = {\n            tagName: q\n          };\n          \"#text\" === q && (w.textContent = d.textContent || \"\");\n\n          if (q = d.attributes) {\n            var a = {};\n            [].forEach.call(q, function (e) {\n              \"data-style\" === e.name ? w.style = f.parseStyle(e.value) : a[e.name] = e.value;\n            });\n            w.attributes = a;\n          }\n\n          if (d.childNodes.length) {\n            var x = [];\n            [].forEach.call(d.childNodes, function (a) {\n              p(a, x);\n            });\n            x.length && (w.children = x);\n          }\n\n          b.push(w);\n        };\n\n        [].forEach.call(d.body.childNodes, function (d) {\n          return p(d, b);\n        });\n        return b;\n      };\n\n      f.allowedAttributes = \"aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex\".split(\" \");\n      f.allowedReferences = \"https:// http:// mailto: / ../ ./ #\".split(\" \");\n      f.allowedTags = \"a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead tbody tspan td th tr u ul #text\".split(\" \");\n      f.emptyHTML = n;\n      f.bypassHTMLFiltering = !1;\n      return f;\n    }();\n\n    \"\";\n    return y;\n  });\n  O(h, \"Core/FormatUtilities.js\", [h[\"Core/DefaultOptions.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    function I(t, b, k, n) {\n      t = +t || 0;\n      b = +b;\n      var m = E.lang,\n          f = (t.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          d = t.toString().split(\"e\"),\n          v = b;\n      if (-1 === b) b = Math.min(f, 20);else if (!F(b)) b = 2;else if (b && d[1] && 0 > d[1]) {\n        var K = b + +d[1];\n        0 <= K ? (d[0] = (+d[0]).toExponential(K).split(\"e\")[0], b = K) : (d[0] = d[0].split(\".\")[0] || 0, t = 20 > b ? (d[0] * Math.pow(10, d[1])).toFixed(b) : 0, d[1] = 0);\n      }\n      K = (Math.abs(d[1] ? d[0] : t) + Math.pow(10, -Math.max(b, f) - 1)).toFixed(b);\n      f = String(p(K));\n      var c = 3 < f.length ? f.length % 3 : 0;\n      k = y(k, m.decimalPoint);\n      n = y(n, m.thousandsSep);\n      t = (0 > t ? \"-\" : \"\") + (c ? f.substr(0, c) + n : \"\");\n      t = 0 > +d[1] && !v ? \"0\" : t + f.substr(c).replace(/(\\d{3})(?=\\d)/g, \"$1\" + n);\n      b && (t += k + K.slice(-b));\n      d[1] && 0 !== +t && (t += \"e\" + d[1]);\n      return t;\n    }\n\n    var E = c.defaultOptions,\n        A = c.defaultTime,\n        D = h.getNestedProperty,\n        F = h.isNumber,\n        y = h.pick,\n        p = h.pInt;\n    return {\n      dateFormat: function (p, b, k) {\n        return A.dateFormat(p, b, k);\n      },\n      format: function (p, b, k) {\n        var n = \"{\",\n            m = !1,\n            f = /f$/,\n            d = /\\.([0-9])/,\n            v = E.lang,\n            K = k && k.time || A;\n        k = k && k.numberFormatter || I;\n\n        for (var t = []; p;) {\n          var c = p.indexOf(n);\n          if (-1 === c) break;\n          var H = p.slice(0, c);\n\n          if (m) {\n            H = H.split(\":\");\n            n = D(H.shift() || \"\", b);\n            if (H.length && \"number\" === typeof n) if (H = H.join(\":\"), f.test(H)) {\n              var q = parseInt((H.match(d) || [\"\", \"-1\"])[1], 10);\n              null !== n && (n = k(n, q, v.decimalPoint, -1 < H.indexOf(\",\") ? v.thousandsSep : \"\"));\n            } else n = K.dateFormat(H, n);\n            t.push(n);\n          } else t.push(H);\n\n          p = p.slice(c + 1);\n          n = (m = !m) ? \"}\" : \"{\";\n        }\n\n        t.push(p);\n        return t.join(\"\");\n      },\n      numberFormat: I\n    };\n  });\n  O(h, \"Core/Renderer/RendererUtilities.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    var h = c.clamp,\n        B = c.pick,\n        E = c.stableSort,\n        A;\n\n    (function (c) {\n      function F(c, p, t) {\n        var b = c,\n            k = b.reducedLen || p,\n            n = function (d, f) {\n          return (f.rank || 0) - (d.rank || 0);\n        },\n            m = function (d, f) {\n          return d.target - f.target;\n        },\n            f,\n            d = !0,\n            v = [],\n            K = 0;\n\n        for (f = c.length; f--;) K += c[f].size;\n\n        if (K > k) {\n          E(c, n);\n\n          for (K = f = 0; K <= k;) K += c[f].size, f++;\n\n          v = c.splice(f - 1, c.length);\n        }\n\n        E(c, m);\n\n        for (c = c.map(function (d) {\n          return {\n            size: d.size,\n            targets: [d.target],\n            align: B(d.align, .5)\n          };\n        }); d;) {\n          for (f = c.length; f--;) k = c[f], n = (Math.min.apply(0, k.targets) + Math.max.apply(0, k.targets)) / 2, k.pos = h(n - k.size * k.align, 0, p - k.size);\n\n          f = c.length;\n\n          for (d = !1; f--;) 0 < f && c[f - 1].pos + c[f - 1].size > c[f].pos && (c[f - 1].size += c[f].size, c[f - 1].targets = c[f - 1].targets.concat(c[f].targets), c[f - 1].align = .5, c[f - 1].pos + c[f - 1].size > p && (c[f - 1].pos = p - c[f - 1].size), c.splice(f, 1), d = !0);\n        }\n\n        b.push.apply(b, v);\n        f = 0;\n        c.some(function (d) {\n          var k = 0;\n          return (d.targets || []).some(function () {\n            b[f].pos = d.pos + k;\n            if (\"undefined\" !== typeof t && Math.abs(b[f].pos - b[f].target) > t) return b.slice(0, f + 1).forEach(function (d) {\n              return delete d.pos;\n            }), b.reducedLen = (b.reducedLen || p) - .1 * p, b.reducedLen > .1 * p && F(b, p, t), !0;\n            k += b[f].size;\n            f++;\n            return !1;\n          });\n        });\n        E(b, m);\n        return b;\n      }\n\n      c.distribute = F;\n    })(A || (A = {}));\n\n    return A;\n  });\n  O(h, \"Core/Renderer/SVG/SVGElement.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E) {\n    var I = c.animate,\n        D = c.animObject,\n        F = c.stop,\n        y = B.deg2rad,\n        p = B.doc,\n        t = B.svg,\n        b = B.SVG_NS,\n        k = B.win,\n        n = E.addEvent,\n        m = E.attr,\n        f = E.createElement,\n        d = E.css,\n        v = E.defined,\n        K = E.erase,\n        M = E.extend,\n        N = E.fireEvent,\n        H = E.isArray,\n        q = E.isFunction,\n        w = E.isString,\n        a = E.merge,\n        x = E.objectEach,\n        e = E.pick,\n        u = E.pInt,\n        l = E.syncTimeout,\n        g = E.uniqueKey;\n\n    c = function () {\n      function G() {\n        this.element = void 0;\n        this.onEvents = {};\n        this.opacity = 1;\n        this.renderer = void 0;\n        this.SVG_NS = b;\n        this.symbolCustomAttribs = \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \");\n      }\n\n      G.prototype._defaultGetter = function (a) {\n        a = e(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      };\n\n      G.prototype._defaultSetter = function (a, g, e) {\n        e.setAttribute(g, a);\n      };\n\n      G.prototype.add = function (a) {\n        var g = this.renderer,\n            e = this.element;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        \"undefined\" !== typeof this.textStr && \"text\" === this.element.nodeName && g.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) var z = this.zIndexSetter();\n        z || (a ? a.element : g.box).appendChild(e);\n        if (this.onAdd) this.onAdd();\n        return this;\n      };\n\n      G.prototype.addClass = function (a, g) {\n        var e = g ? \"\" : this.attr(\"class\") || \"\";\n        a = (a || \"\").split(/ /g).reduce(function (a, g) {\n          -1 === e.indexOf(g) && a.push(g);\n          return a;\n        }, e ? [e] : []).join(\" \");\n        a !== e && this.attr(\"class\", a);\n        return this;\n      };\n\n      G.prototype.afterSetters = function () {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      };\n\n      G.prototype.align = function (a, g, l) {\n        var r = {},\n            z = this.renderer,\n            C = z.alignedObjects,\n            J,\n            d,\n            f;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = g, !l || w(l)) this.alignTo = J = l || \"renderer\", K(C, this), C.push(this), l = void 0;\n        } else a = this.alignOptions, g = this.alignByTranslate, J = this.alignTo;\n\n        l = e(l, z[J], \"scrollablePlotBox\" === J ? z.plotBox : void 0, z);\n        J = a.align;\n        var L = a.verticalAlign;\n        z = (l.x || 0) + (a.x || 0);\n        C = (l.y || 0) + (a.y || 0);\n        \"right\" === J ? d = 1 : \"center\" === J && (d = 2);\n        d && (z += (l.width - (a.width || 0)) / d);\n        r[g ? \"translateX\" : \"x\"] = Math.round(z);\n        \"bottom\" === L ? f = 1 : \"middle\" === L && (f = 2);\n        f && (C += (l.height - (a.height || 0)) / f);\n        r[g ? \"translateY\" : \"y\"] = Math.round(C);\n        this[this.placed ? \"animate\" : \"attr\"](r);\n        this.placed = !0;\n        this.alignAttr = r;\n        return this;\n      };\n\n      G.prototype.alignSetter = function (a) {\n        var g = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        g[a] && (this.alignValue = a, this.element.setAttribute(\"text-anchor\", g[a]));\n      };\n\n      G.prototype.animate = function (a, g, d) {\n        var r = this,\n            z = D(e(g, this.renderer.globalAnimation, !0));\n        g = z.defer;\n        e(p.hidden, p.msHidden, p.webkitHidden, !1) && (z.duration = 0);\n        0 !== z.duration ? (d && (z.complete = d), l(function () {\n          r.element && I(r, a, z);\n        }, g)) : (this.attr(a, void 0, d || z.complete), x(a, function (a, g) {\n          z.step && z.step.call(this, a, {\n            prop: g,\n            pos: 1,\n            elem: this\n          });\n        }, this));\n        return this;\n      };\n\n      G.prototype.applyTextOutline = function (a) {\n        var g = this.element;\n        -1 !== a.indexOf(\"contrast\") && (a = a.replace(/contrast/g, this.renderer.getContrast(g.style.fill)));\n        var e = a.split(\" \");\n        a = e[e.length - 1];\n\n        if ((e = e[0]) && \"none\" !== e && B.svg) {\n          this.fakeTS = !0;\n          this.ySetter = this.xSetter;\n          e = e.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, g, e) {\n            return 2 * Number(g) + e;\n          });\n          this.removeTextOutline();\n          var z = p.createElementNS(b, \"tspan\");\n          m(z, {\n            \"class\": \"highcharts-text-outline\",\n            fill: a,\n            stroke: a,\n            \"stroke-width\": e,\n            \"stroke-linejoin\": \"round\"\n          });\n          a = g.querySelector(\"textPath\") || g;\n          [].forEach.call(a.childNodes, function (a) {\n            var g = a.cloneNode(!0);\n            g.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(function (a) {\n              return g.removeAttribute(a);\n            });\n            z.appendChild(g);\n          });\n          var l = 0;\n          [].forEach.call(a.querySelectorAll(\"text tspan\"), function (a) {\n            l += Number(a.getAttribute(\"dy\"));\n          });\n          e = p.createElementNS(b, \"tspan\");\n          e.textContent = \"\\u200b\";\n          m(e, {\n            x: Number(g.getAttribute(\"x\")),\n            dy: -l\n          });\n          z.appendChild(e);\n          a.insertBefore(z, a.firstChild);\n        }\n      };\n\n      G.prototype.attr = function (a, g, e, l) {\n        var r = this.element,\n            C = this.symbolCustomAttribs,\n            z,\n            d = this,\n            f,\n            q;\n\n        if (\"string\" === typeof a && \"undefined\" !== typeof g) {\n          var u = a;\n          a = {};\n          a[u] = g;\n        }\n\n        \"string\" === typeof a ? d = (this[a + \"Getter\"] || this._defaultGetter).call(this, a, r) : (x(a, function (g, e) {\n          f = !1;\n          l || F(this, e);\n          this.symbolName && -1 !== C.indexOf(e) && (z || (this.symbolAttr(a), z = !0), f = !0);\n          !this.rotation || \"x\" !== e && \"y\" !== e || (this.doTransform = !0);\n          f || (q = this[e + \"Setter\"] || this._defaultSetter, q.call(this, g, e, r), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(e) && this.updateShadows(e, g, q));\n        }, this), this.afterSetters());\n        e && e.call(this);\n        return d;\n      };\n\n      G.prototype.clip = function (a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      };\n\n      G.prototype.crisp = function (a, g) {\n        g = g || a.strokeWidth || 0;\n        var e = Math.round(g) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + e;\n        a.y = Math.floor(a.y || this.y || 0) + e;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * e);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * e);\n        v(a.strokeWidth) && (a.strokeWidth = g);\n        return a;\n      };\n\n      G.prototype.complexColor = function (e, r, l) {\n        var z = this.renderer,\n            d,\n            C,\n            J,\n            f,\n            q,\n            u,\n            L,\n            b,\n            G,\n            w,\n            k = [],\n            m;\n        N(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          e.radialGradient ? C = \"radialGradient\" : e.linearGradient && (C = \"linearGradient\");\n\n          if (C) {\n            J = e[C];\n            q = z.gradients;\n            u = e.stops;\n            G = l.radialReference;\n            H(J) && (e[C] = J = {\n              x1: J[0],\n              y1: J[1],\n              x2: J[2],\n              y2: J[3],\n              gradientUnits: \"userSpaceOnUse\"\n            });\n            \"radialGradient\" === C && G && !v(J.gradientUnits) && (f = J, J = a(J, z.getRadialAttr(G, f), {\n              gradientUnits: \"userSpaceOnUse\"\n            }));\n            x(J, function (a, g) {\n              \"id\" !== g && k.push(g, a);\n            });\n            x(u, function (a) {\n              k.push(a);\n            });\n            k = k.join(\",\");\n            if (q[k]) w = q[k].attr(\"id\");else {\n              J.id = w = g();\n              var P = q[k] = z.createElement(C).attr(J).add(z.defs);\n              P.radAttr = f;\n              P.stops = [];\n              u.forEach(function (a) {\n                0 === a[1].indexOf(\"rgba\") ? (d = h.parse(a[1]), L = d.get(\"rgb\"), b = d.get(\"a\")) : (L = a[1], b = 1);\n                a = z.createElement(\"stop\").attr({\n                  offset: a[0],\n                  \"stop-color\": L,\n                  \"stop-opacity\": b\n                }).add(P);\n                P.stops.push(a);\n              });\n            }\n            m = \"url(\" + z.url + \"#\" + w + \")\";\n            l.setAttribute(r, m);\n            l.gradient = k;\n\n            e.toString = function () {\n              return m;\n            };\n          }\n        });\n      };\n\n      G.prototype.css = function (g) {\n        var e = this.styles,\n            z = {},\n            l = this.element,\n            f = !e;\n        g.color && (g.fill = g.color);\n        e && x(g, function (a, g) {\n          e && e[g] !== a && (z[g] = a, f = !0);\n        });\n\n        if (f) {\n          e && (g = M(e, z));\n          if (null === g.width || \"auto\" === g.width) delete this.textWidth;else if (\"text\" === l.nodeName.toLowerCase() && g.width) var C = this.textWidth = u(g.width);\n          this.styles = g;\n          C && !t && this.renderer.forExport && delete g.width;\n          var J = a(g);\n          l.namespaceURI === this.SVG_NS && [\"textOutline\", \"textOverflow\", \"width\"].forEach(function (a) {\n            return J && delete J[a];\n          });\n          d(l, J);\n          this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), g.textOutline && this.applyTextOutline(g.textOutline));\n        }\n\n        return this;\n      };\n\n      G.prototype.dashstyleSetter = function (a) {\n        var g = this[\"stroke-width\"];\n        \"inherit\" === g && (g = 1);\n\n        if (a = a && a.toLowerCase()) {\n          var l = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (a = l.length; a--;) l[a] = \"\" + u(l[a]) * e(g, NaN);\n\n          a = l.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      };\n\n      G.prototype.destroy = function () {\n        var a = this,\n            g = a.element || {},\n            e = a.renderer,\n            l = g.ownerSVGElement,\n            d = e.isSVG && \"SPAN\" === g.nodeName && a.parentGroup || void 0;\n        g.onclick = g.onmouseout = g.onmouseover = g.onmousemove = g.point = null;\n        F(a);\n\n        if (a.clipPath && l) {\n          var C = a.clipPath;\n          [].forEach.call(l.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (a) {\n            -1 < a.getAttribute(\"clip-path\").indexOf(C.element.id) && a.removeAttribute(\"clip-path\");\n          });\n          a.clipPath = C.destroy();\n        }\n\n        if (a.stops) {\n          for (l = 0; l < a.stops.length; l++) a.stops[l].destroy();\n\n          a.stops.length = 0;\n          a.stops = void 0;\n        }\n\n        a.safeRemoveChild(g);\n\n        for (e.styledMode || a.destroyShadows(); d && d.div && 0 === d.div.childNodes.length;) g = d.parentGroup, a.safeRemoveChild(d.div), delete d.div, d = g;\n\n        a.alignTo && K(e.alignedObjects, a);\n        x(a, function (g, e) {\n          a[e] && a[e].parentGroup === a && a[e].destroy && a[e].destroy();\n          delete a[e];\n        });\n      };\n\n      G.prototype.destroyShadows = function () {\n        (this.shadows || []).forEach(function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      };\n\n      G.prototype.dSetter = function (a, g, e) {\n        H(a) && (\"string\" === typeof a[0] && (a = this.renderer.pathToSegments(a)), this.pathArray = a, a = a.reduce(function (a, g, e) {\n          return g && g.join ? (e ? a + \" \" : \"\") + g.join(\" \") : (g || \"\").toString();\n        }, \"\"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[g] !== a && (e.setAttribute(g, a), this[g] = a);\n      };\n\n      G.prototype.fadeOut = function (a) {\n        var g = this;\n        g.animate({\n          opacity: 0\n        }, {\n          duration: e(a, 150),\n          complete: function () {\n            g.hide();\n          }\n        });\n      };\n\n      G.prototype.fillSetter = function (a, g, e) {\n        \"string\" === typeof a ? e.setAttribute(g, a) : a && this.complexColor(a, g, e);\n      };\n\n      G.prototype.getBBox = function (a, g) {\n        var l = this.alignValue,\n            r = this.element,\n            z = this.renderer,\n            C = this.styles,\n            J = this.textStr,\n            f = z.cache,\n            u = z.cacheKeys,\n            x = r.namespaceURI === this.SVG_NS;\n        g = e(g, this.rotation, 0);\n        var b = z.styledMode ? r && G.prototype.getStyle.call(r, \"font-size\") : C && C.fontSize,\n            P;\n\n        if (v(J)) {\n          var w = J.toString();\n          -1 === w.indexOf(\"<\") && (w = w.replace(/[0-9]/g, \"0\"));\n          w += [\"\", g, b, this.textWidth, l, C && C.textOverflow, C && C.fontWeight].join();\n        }\n\n        w && !a && (P = f[w]);\n\n        if (!P) {\n          if (x || z.forExport) {\n            try {\n              var k = this.fakeTS && function (a) {\n                var g = r.querySelector(\".highcharts-text-outline\");\n                g && d(g, {\n                  display: a\n                });\n              };\n\n              q(k) && k(\"none\");\n              P = r.getBBox ? M({}, r.getBBox()) : {\n                width: r.offsetWidth,\n                height: r.offsetHeight,\n                x: 0,\n                y: 0\n              };\n              q(k) && k(\"\");\n            } catch (V) {\n              \"\";\n            }\n\n            if (!P || 0 > P.width) P = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n          } else P = this.htmlGetBBox();\n\n          if (z.isSVG && (z = P.width, a = P.height, x && (P.height = a = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[\"\" + (b || \"\") + \",\".concat(Math.round(a))] || a), g)) {\n            x = Number(r.getAttribute(\"y\") || 0) - P.y;\n            l = {\n              right: 1,\n              center: .5\n            }[l || 0] || 0;\n            C = g * y;\n            b = (g - 90) * y;\n            var m = z * Math.cos(C);\n            g = z * Math.sin(C);\n            k = Math.cos(b);\n            C = Math.sin(b);\n            z = P.x + l * (z - m) + x * k;\n            b = z + m;\n            k = b - a * k;\n            m = k - m;\n            x = P.y + x - l * g + x * C;\n            l = x + g;\n            a = l - a * C;\n            g = a - g;\n            P.x = Math.min(z, b, k, m);\n            P.y = Math.min(x, l, a, g);\n            P.width = Math.max(z, b, k, m) - P.x;\n            P.height = Math.max(x, l, a, g) - P.y;\n          }\n\n          if (w && (\"\" === J || 0 < P.height)) {\n            for (; 250 < u.length;) delete f[u.shift()];\n\n            f[w] || u.push(w);\n            f[w] = P;\n          }\n        }\n\n        return P;\n      };\n\n      G.prototype.getStyle = function (a) {\n        return k.getComputedStyle(this.element || this, \"\").getPropertyValue(a);\n      };\n\n      G.prototype.hasClass = function (a) {\n        return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(a);\n      };\n\n      G.prototype.hide = function () {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      };\n\n      G.prototype.htmlGetBBox = function () {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      };\n\n      G.prototype.init = function (a, g) {\n        this.element = \"span\" === g ? f(g) : p.createElementNS(this.SVG_NS, g);\n        this.renderer = a;\n        N(this, \"afterInit\");\n      };\n\n      G.prototype.invert = function (a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      };\n\n      G.prototype.on = function (a, g) {\n        var e = this.onEvents;\n        if (e[a]) e[a]();\n        e[a] = n(this.element, a, g);\n        return this;\n      };\n\n      G.prototype.opacitySetter = function (a, g, e) {\n        this.opacity = a = Number(Number(a).toFixed(3));\n        e.setAttribute(g, a);\n      };\n\n      G.prototype.removeClass = function (a) {\n        return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(w(a) ? new RegExp(\"(^| )\".concat(a, \"( |$)\")) : a, \" \").replace(/ +/g, \" \").trim());\n      };\n\n      G.prototype.removeTextOutline = function () {\n        var a = this.element.querySelector(\"tspan.highcharts-text-outline\");\n        a && this.safeRemoveChild(a);\n      };\n\n      G.prototype.safeRemoveChild = function (a) {\n        var g = a.parentNode;\n        g && g.removeChild(a);\n      };\n\n      G.prototype.setRadialReference = function (a) {\n        var g = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        g && g.radAttr && g.animate(this.renderer.getRadialAttr(a, g.radAttr));\n        return this;\n      };\n\n      G.prototype.setTextPath = function (e, l) {\n        var d = this;\n        l = a(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, l);\n        var r = this.renderer.url,\n            z = this.text || this,\n            C = z.textPath,\n            J = l.attributes,\n            f = l.enabled;\n        e = e || C && C.path;\n        C && C.undo();\n        e && f ? (l = n(z, \"afterModifyTree\", function (a) {\n          if (e && f) {\n            var C = e.attr(\"id\");\n            C || e.attr(\"id\", C = g());\n            var l = {\n              x: 0,\n              y: 0\n            };\n            v(J.dx) && (l.dx = J.dx, delete J.dx);\n            v(J.dy) && (l.dy = J.dy, delete J.dy);\n            z.attr(l);\n            d.attr({\n              transform: \"\"\n            });\n            d.box && (d.box = d.box.destroy());\n            l = a.nodes.slice(0);\n            a.nodes.length = 0;\n            a.nodes[0] = {\n              tagName: \"textPath\",\n              attributes: M(J, {\n                \"text-anchor\": J.textAnchor,\n                href: \"\" + r + \"#\".concat(C)\n              }),\n              children: l\n            };\n          }\n        }), z.textPath = {\n          path: e,\n          undo: l\n        }) : (z.attr({\n          dx: 0,\n          dy: 0\n        }), delete z.textPath);\n        this.added && (z.textCache = \"\", this.renderer.buildText(z));\n        return this;\n      };\n\n      G.prototype.shadow = function (a, g, e) {\n        var l = [],\n            d = this.element,\n            C = this.oldShadowOptions,\n            J = {\n          color: \"#000000\",\n          offsetX: this.parentInverted ? -1 : 1,\n          offsetY: this.parentInverted ? -1 : 1,\n          opacity: .15,\n          width: 3\n        },\n            r = !1,\n            z;\n        !0 === a ? z = J : \"object\" === typeof a && (z = M(J, a));\n        z && (z && C && x(z, function (a, g) {\n          a !== C[g] && (r = !0);\n        }), r && this.destroyShadows(), this.oldShadowOptions = z);\n        if (!z) this.destroyShadows();else if (!this.shadows) {\n          var f = z.opacity / z.width;\n          var q = this.parentInverted ? \"translate(\".concat(z.offsetY, \", \").concat(z.offsetX, \")\") : \"translate(\".concat(z.offsetX, \", \").concat(z.offsetY, \")\");\n\n          for (J = 1; J <= z.width; J++) {\n            var u = d.cloneNode(!1);\n            var b = 2 * z.width + 1 - 2 * J;\n            m(u, {\n              stroke: a.color || \"#000000\",\n              \"stroke-opacity\": f * J,\n              \"stroke-width\": b,\n              transform: q,\n              fill: \"none\"\n            });\n            u.setAttribute(\"class\", (u.getAttribute(\"class\") || \"\") + \" highcharts-shadow\");\n            e && (m(u, \"height\", Math.max(m(u, \"height\") - b, 0)), u.cutHeight = b);\n            g ? g.element.appendChild(u) : d.parentNode && d.parentNode.insertBefore(u, d);\n            l.push(u);\n          }\n\n          this.shadows = l;\n        }\n        return this;\n      };\n\n      G.prototype.show = function (a) {\n        void 0 === a && (a = !0);\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      };\n\n      G.prototype.strokeSetter = function (a, g, e) {\n        this[g] = a;\n        this.stroke && this[\"stroke-width\"] ? (G.prototype.fillSetter.call(this, this.stroke, \"stroke\", e), e.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === g && 0 === a && this.hasStroke ? (e.removeAttribute(\"stroke\"), this.hasStroke = !1) : this.renderer.styledMode && this[\"stroke-width\"] && (e.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0);\n      };\n\n      G.prototype.strokeWidth = function () {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var a = this.getStyle(\"stroke-width\"),\n            g = 0;\n        if (a.indexOf(\"px\") === a.length - 2) g = u(a);else if (\"\" !== a) {\n          var e = p.createElementNS(b, \"rect\");\n          m(e, {\n            width: a,\n            \"stroke-width\": 0\n          });\n          this.element.parentNode.appendChild(e);\n          g = e.getBBox().width;\n          e.parentNode.removeChild(e);\n        }\n        return g;\n      };\n\n      G.prototype.symbolAttr = function (a) {\n        var g = this;\n        \"x y r start end width height innerR anchorX anchorY clockwise\".split(\" \").forEach(function (l) {\n          g[l] = e(a[l], g[l]);\n        });\n        g.attr({\n          d: g.renderer.symbols[g.symbolName](g.x, g.y, g.width, g.height, g)\n        });\n      };\n\n      G.prototype.textSetter = function (a) {\n        a !== this.textStr && (delete this.textPxLength, this.textStr = a, this.added && this.renderer.buildText(this));\n      };\n\n      G.prototype.titleSetter = function (a) {\n        var g = this.element,\n            l = g.getElementsByTagName(\"title\")[0] || p.createElementNS(this.SVG_NS, \"title\");\n        g.insertBefore ? g.insertBefore(l, g.firstChild) : g.appendChild(l);\n        l.textContent = String(e(a, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n      };\n\n      G.prototype.toFront = function () {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      };\n\n      G.prototype.translate = function (a, g) {\n        return this.attr({\n          translateX: a,\n          translateY: g\n        });\n      };\n\n      G.prototype.updateShadows = function (a, g, e) {\n        var l = this.shadows;\n        if (l) for (var d = l.length; d--;) e.call(l[d], \"height\" === a ? Math.max(g - (l[d].cutHeight || 0), 0) : \"d\" === a ? this.d : g, a, l[d]);\n      };\n\n      G.prototype.updateTransform = function () {\n        var a = this.scaleX,\n            g = this.scaleY,\n            l = this.inverted,\n            d = this.rotation,\n            f = this.matrix,\n            C = this.element,\n            J = this.translateX || 0,\n            q = this.translateY || 0;\n        l && (J += this.width, q += this.height);\n        J = [\"translate(\" + J + \",\" + q + \")\"];\n        v(f) && J.push(\"matrix(\" + f.join(\",\") + \")\");\n        l ? J.push(\"rotate(90) scale(-1,1)\") : d && J.push(\"rotate(\" + d + \" \" + e(this.rotationOriginX, C.getAttribute(\"x\"), 0) + \" \" + e(this.rotationOriginY, C.getAttribute(\"y\") || 0) + \")\");\n        (v(a) || v(g)) && J.push(\"scale(\" + e(a, 1) + \" \" + e(g, 1) + \")\");\n        J.length && !(this.text || this).textPath && C.setAttribute(\"transform\", J.join(\" \"));\n      };\n\n      G.prototype.visibilitySetter = function (a, g, e) {\n        \"inherit\" === a ? e.removeAttribute(g) : this[g] !== a && e.setAttribute(g, a);\n        this[g] = a;\n      };\n\n      G.prototype.xGetter = function (a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      };\n\n      G.prototype.zIndexSetter = function (a, g) {\n        var e = this.renderer,\n            l = this.parentGroup,\n            d = (l || e).element || e.box,\n            C = this.element;\n        e = d === e.box;\n        var J = !1;\n        var r = this.added;\n        var f;\n        v(a) ? (C.setAttribute(\"data-z-index\", a), a = +a, this[g] === a && (r = !1)) : v(this[g]) && C.removeAttribute(\"data-z-index\");\n        this[g] = a;\n\n        if (r) {\n          (a = this.zIndex) && l && (l.handleZ = !0);\n          g = d.childNodes;\n\n          for (f = g.length - 1; 0 <= f && !J; f--) {\n            l = g[f];\n            r = l.getAttribute(\"data-z-index\");\n            var q = !v(r);\n            if (l !== C) if (0 > a && q && !e && !f) d.insertBefore(C, g[f]), J = !0;else if (u(r) <= a || q && (!v(a) || 0 <= a)) d.insertBefore(C, g[f + 1] || null), J = !0;\n          }\n\n          J || (d.insertBefore(C, g[e ? 3 : 0] || null), J = !0);\n        }\n\n        return J;\n      };\n\n      return G;\n    }();\n\n    c.prototype[\"stroke-widthSetter\"] = c.prototype.strokeSetter;\n    c.prototype.yGetter = c.prototype.xGetter;\n\n    c.prototype.matrixSetter = c.prototype.rotationOriginXSetter = c.prototype.rotationOriginYSetter = c.prototype.rotationSetter = c.prototype.scaleXSetter = c.prototype.scaleYSetter = c.prototype.translateXSetter = c.prototype.translateYSetter = c.prototype.verticalAlignSetter = function (a, g) {\n      this[g] = a;\n      this.doTransform = !0;\n    };\n\n    \"\";\n    return c;\n  });\n  O(h, \"Core/Renderer/RendererRegistry.js\", [h[\"Core/Globals.js\"]], function (c) {\n    var h;\n\n    (function (h) {\n      h.rendererTypes = {};\n      var I;\n\n      h.getRendererType = function (c) {\n        void 0 === c && (c = I);\n        return h.rendererTypes[c] || h.rendererTypes[I];\n      };\n\n      h.registerRendererType = function (A, D, F) {\n        h.rendererTypes[A] = D;\n        if (!I || F) I = A, c.Renderer = D;\n      };\n    })(h || (h = {}));\n\n    return h;\n  });\n  O(h, \"Core/Renderer/SVG/SVGLabel.js\", [h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    var I = this && this.__extends || function () {\n      var p = function (b, k) {\n        p = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, k) {\n          b.__proto__ = k;\n        } || function (b, k) {\n          for (var f in k) k.hasOwnProperty(f) && (b[f] = k[f]);\n        };\n\n        return p(b, k);\n      };\n\n      return function (b, k) {\n        function n() {\n          this.constructor = b;\n        }\n\n        p(b, k);\n        b.prototype = null === k ? Object.create(k) : (n.prototype = k.prototype, new n());\n      };\n    }(),\n        E = h.defined,\n        A = h.extend,\n        D = h.isNumber,\n        F = h.merge,\n        y = h.pick,\n        p = h.removeEvent;\n\n    return function (t) {\n      function b(k, n, m, f, d, v, p, c, h, H) {\n        var q = t.call(this) || this;\n        q.paddingLeftSetter = q.paddingSetter;\n        q.paddingRightSetter = q.paddingSetter;\n        q.init(k, \"g\");\n        q.textStr = n;\n        q.x = m;\n        q.y = f;\n        q.anchorX = v;\n        q.anchorY = p;\n        q.baseline = h;\n        q.className = H;\n        q.addClass(\"button\" === H ? \"highcharts-no-tooltip\" : \"highcharts-label\");\n        H && q.addClass(\"highcharts-\" + H);\n        q.text = k.text(void 0, 0, 0, c).attr({\n          zIndex: 1\n        });\n        var w;\n        \"string\" === typeof d && ((w = /^url\\((.*?)\\)$/.test(d)) || q.renderer.symbols[d]) && (q.symbolKey = d);\n        q.bBox = b.emptyBBox;\n        q.padding = 3;\n        q.baselineOffset = 0;\n        q.needsBox = k.styledMode || w;\n        q.deferredAttr = {};\n        q.alignFactor = 0;\n        return q;\n      }\n\n      I(b, t);\n\n      b.prototype.alignSetter = function (b) {\n        b = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[b];\n        b !== this.alignFactor && (this.alignFactor = b, this.bBox && D(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      };\n\n      b.prototype.anchorXSetter = function (b, n) {\n        this.anchorX = b;\n        this.boxAttr(n, Math.round(b) - this.getCrispAdjust() - this.xSetting);\n      };\n\n      b.prototype.anchorYSetter = function (b, n) {\n        this.anchorY = b;\n        this.boxAttr(n, b - this.ySetting);\n      };\n\n      b.prototype.boxAttr = function (b, n) {\n        this.box ? this.box.attr(b, n) : this.deferredAttr[b] = n;\n      };\n\n      b.prototype.css = function (k) {\n        if (k) {\n          var n = {};\n          k = F(k);\n          b.textProps.forEach(function (f) {\n            \"undefined\" !== typeof k[f] && (n[f] = k[f], delete k[f]);\n          });\n          this.text.css(n);\n          var m = (\"width\" in n);\n          \"fontSize\" in n || \"fontWeight\" in n ? this.updateTextPadding() : m && this.updateBoxSize();\n        }\n\n        return c.prototype.css.call(this, k);\n      };\n\n      b.prototype.destroy = function () {\n        p(this.element, \"mouseenter\");\n        p(this.element, \"mouseleave\");\n        this.text && this.text.destroy();\n        this.box && (this.box = this.box.destroy());\n        c.prototype.destroy.call(this);\n      };\n\n      b.prototype.fillSetter = function (b, n) {\n        b && (this.needsBox = !0);\n        this.fill = b;\n        this.boxAttr(n, b);\n      };\n\n      b.prototype.getBBox = function () {\n        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n        var b = this.padding,\n            n = y(this.paddingLeft, b);\n        return {\n          width: this.width,\n          height: this.height,\n          x: this.bBox.x - n,\n          y: this.bBox.y - b\n        };\n      };\n\n      b.prototype.getCrispAdjust = function () {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n      };\n\n      b.prototype.heightSetter = function (b) {\n        this.heightSetting = b;\n      };\n\n      b.prototype.onAdd = function () {\n        var b = this.textStr;\n        this.text.add(this);\n        this.attr({\n          text: E(b) ? b : \"\",\n          x: this.x,\n          y: this.y\n        });\n        this.box && E(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      };\n\n      b.prototype.paddingSetter = function (b, n) {\n        D(b) ? b !== this[n] && (this[n] = b, this.updateTextPadding()) : this[n] = void 0;\n      };\n\n      b.prototype.rSetter = function (b, n) {\n        this.boxAttr(n, b);\n      };\n\n      b.prototype.shadow = function (b) {\n        b && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(b));\n        return this;\n      };\n\n      b.prototype.strokeSetter = function (b, n) {\n        this.stroke = b;\n        this.boxAttr(n, b);\n      };\n\n      b.prototype[\"stroke-widthSetter\"] = function (b, n) {\n        b && (this.needsBox = !0);\n        this[\"stroke-width\"] = b;\n        this.boxAttr(n, b);\n      };\n\n      b.prototype[\"text-alignSetter\"] = function (b) {\n        this.textAlign = b;\n      };\n\n      b.prototype.textSetter = function (b) {\n        \"undefined\" !== typeof b && this.text.attr({\n          text: b\n        });\n        this.updateTextPadding();\n      };\n\n      b.prototype.updateBoxSize = function () {\n        var k = this.text,\n            n = k.element.style,\n            m = {},\n            f = this.padding,\n            d = this.bBox = D(this.widthSetting) && D(this.heightSetting) && !this.textAlign || !E(k.textStr) ? b.emptyBBox : k.getBBox();\n        this.width = this.getPaddedWidth();\n        this.height = (this.heightSetting || d.height || 0) + 2 * f;\n        n = this.renderer.fontMetrics(n && n.fontSize, k);\n        this.baselineOffset = f + Math.min((this.text.firstLineMetrics || n).b, d.height || Infinity);\n        this.heightSetting && (this.baselineOffset += (this.heightSetting - n.h) / 2);\n        this.needsBox && !k.textPath && (this.box || (k = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), k.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), k.add(this)), k = this.getCrispAdjust(), m.x = k, m.y = (this.baseline ? -this.baselineOffset : 0) + k, m.width = Math.round(this.width), m.height = Math.round(this.height), this.box.attr(A(m, this.deferredAttr)), this.deferredAttr = {});\n      };\n\n      b.prototype.updateTextPadding = function () {\n        var b = this.text;\n\n        if (!b.textPath) {\n          this.updateBoxSize();\n          var n = this.baseline ? 0 : this.baselineOffset,\n              m = y(this.paddingLeft, this.padding);\n          E(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (m += {\n            center: .5,\n            right: 1\n          }[this.textAlign] * (this.widthSetting - this.bBox.width));\n          if (m !== b.x || n !== b.y) b.attr(\"x\", m), b.hasBoxWidthChanged && (this.bBox = b.getBBox(!0)), \"undefined\" !== typeof n && b.attr(\"y\", n);\n          b.x = m;\n          b.y = n;\n        }\n      };\n\n      b.prototype.widthSetter = function (b) {\n        this.widthSetting = D(b) ? b : void 0;\n      };\n\n      b.prototype.getPaddedWidth = function () {\n        var b = this.padding,\n            n = y(this.paddingLeft, b);\n        b = y(this.paddingRight, b);\n        return (this.widthSetting || this.bBox.width || 0) + n + b;\n      };\n\n      b.prototype.xSetter = function (b) {\n        this.x = b;\n        this.alignFactor && (b -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0);\n        this.xSetting = Math.round(b);\n        this.attr(\"translateX\", this.xSetting);\n      };\n\n      b.prototype.ySetter = function (b) {\n        this.ySetting = this.y = Math.round(b);\n        this.attr(\"translateY\", this.ySetting);\n      };\n\n      b.emptyBBox = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      b.textProps = \"color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width\".split(\" \");\n      return b;\n    }(c);\n  });\n  O(h, \"Core/Renderer/SVG/Symbols.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    function h(c, p, t, b, k) {\n      var n = [];\n\n      if (k) {\n        var m = k.start || 0,\n            f = F(k.r, t);\n        t = F(k.r, b || t);\n        var d = (k.end || 0) - .001;\n        b = k.innerR;\n        var v = F(k.open, .001 > Math.abs((k.end || 0) - m - 2 * Math.PI)),\n            K = Math.cos(m),\n            h = Math.sin(m),\n            N = Math.cos(d),\n            H = Math.sin(d);\n        m = F(k.longArc, .001 > d - m - Math.PI ? 0 : 1);\n        n.push([\"M\", c + f * K, p + t * h], [\"A\", f, t, 0, m, F(k.clockwise, 1), c + f * N, p + t * H]);\n        A(b) && n.push(v ? [\"M\", c + b * N, p + b * H] : [\"L\", c + b * N, p + b * H], [\"A\", b, b, 0, m, A(k.clockwise) ? 1 - k.clockwise : 0, c + b * K, p + b * h]);\n        v || n.push([\"Z\"]);\n      }\n\n      return n;\n    }\n\n    function B(c, p, t, b, k) {\n      return k && k.r ? E(c, p, t, b, k) : [[\"M\", c, p], [\"L\", c + t, p], [\"L\", c + t, p + b], [\"L\", c, p + b], [\"Z\"]];\n    }\n\n    function E(c, p, t, b, k) {\n      k = k && k.r || 0;\n      return [[\"M\", c + k, p], [\"L\", c + t - k, p], [\"C\", c + t, p, c + t, p, c + t, p + k], [\"L\", c + t, p + b - k], [\"C\", c + t, p + b, c + t, p + b, c + t - k, p + b], [\"L\", c + k, p + b], [\"C\", c, p + b, c, p + b, c, p + b - k], [\"L\", c, p + k], [\"C\", c, p, c, p, c + k, p]];\n    }\n\n    var A = c.defined,\n        D = c.isNumber,\n        F = c.pick;\n    return {\n      arc: h,\n      callout: function (c, p, t, b, k) {\n        var n = Math.min(k && k.r || 0, t, b),\n            m = n + 6,\n            f = k && k.anchorX;\n        k = k && k.anchorY || 0;\n        var d = E(c, p, t, b, {\n          r: n\n        });\n        if (!D(f)) return d;\n        c + f >= t ? k > p + m && k < p + b - m ? d.splice(3, 1, [\"L\", c + t, k - 6], [\"L\", c + t + 6, k], [\"L\", c + t, k + 6], [\"L\", c + t, p + b - n]) : d.splice(3, 1, [\"L\", c + t, b / 2], [\"L\", f, k], [\"L\", c + t, b / 2], [\"L\", c + t, p + b - n]) : 0 >= c + f ? k > p + m && k < p + b - m ? d.splice(7, 1, [\"L\", c, k + 6], [\"L\", c - 6, k], [\"L\", c, k - 6], [\"L\", c, p + n]) : d.splice(7, 1, [\"L\", c, b / 2], [\"L\", f, k], [\"L\", c, b / 2], [\"L\", c, p + n]) : k && k > b && f > c + m && f < c + t - m ? d.splice(5, 1, [\"L\", f + 6, p + b], [\"L\", f, p + b + 6], [\"L\", f - 6, p + b], [\"L\", c + n, p + b]) : k && 0 > k && f > c + m && f < c + t - m && d.splice(1, 1, [\"L\", f - 6, p], [\"L\", f, p - 6], [\"L\", f + 6, p], [\"L\", t - n, p]);\n        return d;\n      },\n      circle: function (c, p, t, b) {\n        return h(c + t / 2, p + b / 2, t / 2, b / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function (c, p, t, b) {\n        return [[\"M\", c + t / 2, p], [\"L\", c + t, p + b / 2], [\"L\", c + t / 2, p + b], [\"L\", c, p + b / 2], [\"Z\"]];\n      },\n      rect: B,\n      roundedRect: E,\n      square: B,\n      triangle: function (c, p, t, b) {\n        return [[\"M\", c + t / 2, p], [\"L\", c + t, p + b], [\"L\", c, p + b], [\"Z\"]];\n      },\n      \"triangle-down\": function (c, p, t, b) {\n        return [[\"M\", c, p], [\"L\", c + t, p], [\"L\", c + t / 2, p + b], [\"Z\"]];\n      }\n    };\n  });\n  O(h, \"Core/Renderer/SVG/TextBuilder.js\", [h[\"Core/Renderer/HTML/AST.js\"], h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var I = h.doc,\n        A = h.SVG_NS,\n        D = h.win,\n        F = B.attr,\n        y = B.extend,\n        p = B.fireEvent,\n        t = B.isString,\n        b = B.objectEach,\n        k = B.pick;\n    return function () {\n      function n(b) {\n        var f = b.styles;\n        this.renderer = b.renderer;\n        this.svgElement = b;\n        this.width = b.textWidth;\n        this.textLineHeight = f && f.lineHeight;\n        this.textOutline = f && f.textOutline;\n        this.ellipsis = !(!f || \"ellipsis\" !== f.textOverflow);\n        this.noWrap = !(!f || \"nowrap\" !== f.whiteSpace);\n        this.fontSize = f && f.fontSize;\n      }\n\n      n.prototype.buildSVG = function () {\n        var b = this.svgElement,\n            f = b.element,\n            d = b.renderer,\n            v = k(b.textStr, \"\").toString(),\n            n = -1 !== v.indexOf(\"<\"),\n            p = f.childNodes;\n        d = this.width && !b.added && d.box;\n        var h = /<br.*?>/g,\n            H = [v, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();\n\n        if (H !== b.textCache) {\n          b.textCache = H;\n          delete b.actualWidth;\n\n          for (H = p.length; H--;) f.removeChild(p[H]);\n\n          n || this.ellipsis || this.width || b.textPath || -1 !== v.indexOf(\" \") && (!this.noWrap || h.test(v)) ? \"\" !== v && (d && d.appendChild(f), v = new c(v), this.modifyTree(v.nodes), v.addToDOM(f), this.modifyDOM(), this.ellipsis && -1 !== (f.textContent || \"\").indexOf(\"\\u2026\") && b.attr(\"title\", this.unescapeEntities(b.textStr || \"\", [\"&lt;\", \"&gt;\"])), d && d.removeChild(f)) : f.appendChild(I.createTextNode(this.unescapeEntities(v)));\n          t(this.textOutline) && b.applyTextOutline && b.applyTextOutline(this.textOutline);\n        }\n      };\n\n      n.prototype.modifyDOM = function () {\n        var b = this,\n            f = this.svgElement,\n            d = F(f.element, \"x\");\n        f.firstLineMetrics = void 0;\n\n        for (var v; v = f.element.firstChild;) if (/^[\\s\\u200B]*$/.test(v.textContent || \" \")) f.element.removeChild(v);else break;\n\n        [].forEach.call(f.element.querySelectorAll(\"tspan.highcharts-br\"), function (v, q) {\n          v.nextSibling && v.previousSibling && (0 === q && 1 === v.previousSibling.nodeType && (f.firstLineMetrics = f.renderer.fontMetrics(void 0, v.previousSibling)), F(v, {\n            dy: b.getLineHeight(v.nextSibling),\n            x: d\n          }));\n        });\n        var k = this.width || 0;\n\n        if (k) {\n          var n = function (v, q) {\n            var w = v.textContent || \"\",\n                a = w.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n                x = !b.noWrap && (1 < a.length || 1 < f.element.childNodes.length),\n                e = b.getLineHeight(q),\n                u = 0,\n                l = f.actualWidth;\n            if (b.ellipsis) w && b.truncate(v, w, void 0, 0, Math.max(0, k - parseInt(b.fontSize || 12, 10)), function (a, e) {\n              return a.substring(0, e) + \"\\u2026\";\n            });else if (x) {\n              w = [];\n\n              for (x = []; q.firstChild && q.firstChild !== v;) x.push(q.firstChild), q.removeChild(q.firstChild);\n\n              for (; a.length;) a.length && !b.noWrap && 0 < u && (w.push(v.textContent || \"\"), v.textContent = a.join(\" \").replace(/- /g, \"-\")), b.truncate(v, void 0, a, 0 === u ? l || 0 : 0, k, function (g, e) {\n                return a.slice(0, e).join(\" \").replace(/- /g, \"-\");\n              }), l = f.actualWidth, u++;\n\n              x.forEach(function (a) {\n                q.insertBefore(a, v);\n              });\n              w.forEach(function (a) {\n                q.insertBefore(I.createTextNode(a), v);\n                a = I.createElementNS(A, \"tspan\");\n                a.textContent = \"\\u200b\";\n                F(a, {\n                  dy: e,\n                  x: d\n                });\n                q.insertBefore(a, v);\n              });\n            }\n          },\n              c = function (d) {\n            [].slice.call(d.childNodes).forEach(function (b) {\n              b.nodeType === D.Node.TEXT_NODE ? n(b, d) : (-1 !== b.className.baseVal.indexOf(\"highcharts-br\") && (f.actualWidth = 0), c(b));\n            });\n          };\n\n          c(f.element);\n        }\n      };\n\n      n.prototype.getLineHeight = function (b) {\n        var f;\n        b = b.nodeType === D.Node.TEXT_NODE ? b.parentElement : b;\n        this.renderer.styledMode || (f = b && /(px|em)$/.test(b.style.fontSize) ? b.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);\n        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(f, b || this.svgElement.element).h;\n      };\n\n      n.prototype.modifyTree = function (b) {\n        var f = this,\n            d = function (v, k) {\n          var m = v.attributes;\n          m = void 0 === m ? {} : m;\n          var n = v.children,\n              c = v.style;\n          c = void 0 === c ? {} : c;\n          var q = v.tagName,\n              w = f.renderer.styledMode;\n          if (\"b\" === q || \"strong\" === q) w ? m[\"class\"] = \"highcharts-strong\" : c.fontWeight = \"bold\";else if (\"i\" === q || \"em\" === q) w ? m[\"class\"] = \"highcharts-emphasized\" : c.fontStyle = \"italic\";\n          c && c.color && (c.fill = c.color);\n          \"br\" === q ? (m[\"class\"] = \"highcharts-br\", v.textContent = \"\\u200b\", (k = b[k + 1]) && k.textContent && (k.textContent = k.textContent.replace(/^ +/gm, \"\"))) : \"a\" === q && n && n.some(function (a) {\n            return \"#text\" === a.tagName;\n          }) && (v.children = [{\n            children: n,\n            tagName: \"tspan\"\n          }]);\n          \"#text\" !== q && \"a\" !== q && (v.tagName = \"tspan\");\n          y(v, {\n            attributes: m,\n            style: c\n          });\n          n && n.filter(function (a) {\n            return \"#text\" !== a.tagName;\n          }).forEach(d);\n        };\n\n        b.forEach(d);\n        p(this.svgElement, \"afterModifyTree\", {\n          nodes: b\n        });\n      };\n\n      n.prototype.truncate = function (b, f, d, v, k, n) {\n        var m = this.svgElement,\n            c = m.renderer,\n            q = m.rotation,\n            w = [],\n            a = d ? 1 : 0,\n            x = (f || d || \"\").length,\n            e = x,\n            u,\n            l = function (a, g) {\n          g = g || a;\n          var e = b.parentNode;\n          if (e && \"undefined\" === typeof w[g]) if (e.getSubStringLength) try {\n            w[g] = v + e.getSubStringLength(0, d ? g + 1 : g);\n          } catch (L) {\n            \"\";\n          } else c.getSpanWidth && (b.textContent = n(f || d, a), w[g] = v + c.getSpanWidth(m, b));\n          return w[g];\n        };\n\n        m.rotation = 0;\n        var g = l(b.textContent.length);\n\n        if (v + g > k) {\n          for (; a <= x;) e = Math.ceil((a + x) / 2), d && (u = n(d, e)), g = l(e, u && u.length - 1), a === x ? a = x + 1 : g > k ? x = e - 1 : a = e;\n\n          0 === x ? b.textContent = \"\" : f && x === f.length - 1 || (b.textContent = u || n(f || d, e));\n        }\n\n        d && d.splice(0, e);\n        m.actualWidth = g;\n        m.rotation = q;\n      };\n\n      n.prototype.unescapeEntities = function (k, f) {\n        b(this.renderer.escapes, function (d, b) {\n          f && -1 !== f.indexOf(d) || (k = k.toString().replace(new RegExp(d, \"g\"), b));\n        });\n        return k;\n      };\n\n      return n;\n    }();\n  });\n  O(h, \"Core/Renderer/SVG/SVGRenderer.js\", [h[\"Core/Renderer/HTML/AST.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Renderer/RendererRegistry.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Renderer/SVG/SVGLabel.js\"], h[\"Core/Renderer/SVG/Symbols.js\"], h[\"Core/Renderer/SVG/TextBuilder.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A, D, F, y, p) {\n    var t = B.charts,\n        b = B.deg2rad,\n        k = B.doc,\n        n = B.isFirefox,\n        m = B.isMS,\n        f = B.isWebKit,\n        d = B.noop,\n        v = B.SVG_NS,\n        K = B.symbolSizes,\n        M = B.win,\n        N = p.addEvent,\n        H = p.attr,\n        q = p.createElement,\n        w = p.css,\n        a = p.defined,\n        x = p.destroyObjectProperties,\n        e = p.extend,\n        u = p.isArray,\n        l = p.isNumber,\n        g = p.isObject,\n        G = p.isString,\n        z = p.merge,\n        r = p.pick,\n        L = p.pInt,\n        Q = p.uniqueKey,\n        S;\n\n    B = function () {\n      function C(a, g, e, C, l, d, b) {\n        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;\n        this.init(a, g, e, C, l, d, b);\n      }\n\n      C.prototype.init = function (a, g, e, C, l, d, b) {\n        var J = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        }),\n            r = J.element;\n        b || J.css(this.getStyle(C));\n        a.appendChild(r);\n        H(a, \"dir\", \"ltr\");\n        -1 === a.innerHTML.indexOf(\"xmlns\") && H(r, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = r;\n        this.boxWrapper = J;\n        this.alignedObjects = [];\n        this.url = this.getReferenceURL();\n        this.createElement(\"desc\").add().element.appendChild(k.createTextNode(\"Created with Highcharts 10.2.1\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = d;\n        this.forExport = l;\n        this.styledMode = b;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(g, e, !1);\n        var f;\n        n && a.getBoundingClientRect && (g = function () {\n          w(a, {\n            left: 0,\n            top: 0\n          });\n          f = a.getBoundingClientRect();\n          w(a, {\n            left: Math.ceil(f.left) - f.left + \"px\",\n            top: Math.ceil(f.top) - f.top + \"px\"\n          });\n        }, g(), this.unSubPixelFix = N(M, \"resize\", g));\n      };\n\n      C.prototype.definition = function (a) {\n        return new c([a]).addToDOM(this.defs.element);\n      };\n\n      C.prototype.getReferenceURL = function () {\n        if ((n || f) && k.getElementsByTagName(\"base\").length) {\n          if (!a(S)) {\n            var g = Q();\n            g = new c([{\n              tagName: \"svg\",\n              attributes: {\n                width: 8,\n                height: 8\n              },\n              children: [{\n                tagName: \"defs\",\n                children: [{\n                  tagName: \"clipPath\",\n                  attributes: {\n                    id: g\n                  },\n                  children: [{\n                    tagName: \"rect\",\n                    attributes: {\n                      width: 4,\n                      height: 4\n                    }\n                  }]\n                }]\n              }, {\n                tagName: \"rect\",\n                attributes: {\n                  id: \"hitme\",\n                  width: 8,\n                  height: 8,\n                  \"clip-path\": \"url(#\".concat(g, \")\"),\n                  fill: \"rgba(0,0,0,0.001)\"\n                }\n              }]\n            }]).addToDOM(k.body);\n            w(g, {\n              position: \"fixed\",\n              top: 0,\n              left: 0,\n              zIndex: 9E5\n            });\n            var e = k.elementFromPoint(6, 6);\n            S = \"hitme\" === (e && e.id);\n            k.body.removeChild(g);\n          }\n\n          if (S) return M.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\");\n        }\n\n        return \"\";\n      };\n\n      C.prototype.getStyle = function (a) {\n        return this.style = e({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, a);\n      };\n\n      C.prototype.setStyle = function (a) {\n        this.boxWrapper.css(this.getStyle(a));\n      };\n\n      C.prototype.isHidden = function () {\n        return !this.boxWrapper.getBBox().width;\n      };\n\n      C.prototype.destroy = function () {\n        var a = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        x(this.gradients || {});\n        this.gradients = null;\n        a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      };\n\n      C.prototype.createElement = function (a) {\n        var g = new this.Element();\n        g.init(this, a);\n        return g;\n      };\n\n      C.prototype.getRadialAttr = function (a, g) {\n        return {\n          cx: a[0] - a[2] / 2 + (g.cx || 0) * a[2],\n          cy: a[1] - a[2] / 2 + (g.cy || 0) * a[2],\n          r: (g.r || 0) * a[2]\n        };\n      };\n\n      C.prototype.buildText = function (a) {\n        new y(a).buildSVG();\n      };\n\n      C.prototype.getContrast = function (a) {\n        a = h.parse(a).rgba.map(function (a) {\n          a /= 255;\n          return .03928 >= a ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4);\n        });\n        a = .2126 * a[0] + .7152 * a[1] + .0722 * a[2];\n        return 1.05 / (a + .05) > (a + .05) / .05 ? \"#FFFFFF\" : \"#000000\";\n      };\n\n      C.prototype.button = function (a, C, l, d, b, r, f, q, u, x) {\n        void 0 === b && (b = {});\n        var J = this.label(a, C, l, u, void 0, void 0, x, void 0, \"button\"),\n            w = this.styledMode;\n        a = b.states || {};\n        var G = 0;\n        b = z(b);\n        delete b.states;\n        var v = z({\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontWeight: \"normal\"\n        }, b.style);\n        delete b.style;\n        var P = c.filterUserAttributes(b);\n        J.attr(z({\n          padding: 8,\n          r: 2\n        }, P));\n\n        if (!w) {\n          P = z({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1\n          }, P);\n          r = z(P, {\n            fill: \"#e6e6e6\"\n          }, c.filterUserAttributes(r || a.hover || {}));\n          var k = r.style;\n          delete r.style;\n          f = z(P, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, c.filterUserAttributes(f || a.select || {}));\n          var L = f.style;\n          delete f.style;\n          q = z(P, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, c.filterUserAttributes(q || a.disabled || {}));\n          var n = q.style;\n          delete q.style;\n        }\n\n        N(J.element, m ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== G && J.setState(1);\n        });\n        N(J.element, m ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== G && J.setState(G);\n        });\n\n        J.setState = function (a) {\n          1 !== a && (J.state = G = a);\n          J.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n          w || (J.attr([P, r, f, q][a || 0]), a = [v, k, L, n][a || 0], g(a) && J.css(a));\n        };\n\n        w || J.attr(P).css(e({\n          cursor: \"default\"\n        }, v));\n        return J.on(\"touchstart\", function (a) {\n          return a.stopPropagation();\n        }).on(\"click\", function (a) {\n          3 !== G && d.call(J, a);\n        });\n      };\n\n      C.prototype.crispLine = function (g, e, C) {\n        void 0 === C && (C = \"round\");\n        var l = g[0],\n            d = g[1];\n        a(l[1]) && l[1] === d[1] && (l[1] = d[1] = Math[C](l[1]) - e % 2 / 2);\n        a(l[2]) && l[2] === d[2] && (l[2] = d[2] = Math[C](l[2]) + e % 2 / 2);\n        return g;\n      };\n\n      C.prototype.path = function (a) {\n        var C = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        u(a) ? C.d = a : g(a) && e(C, a);\n        return this.createElement(\"path\").attr(C);\n      };\n\n      C.prototype.circle = function (a, e, C) {\n        a = g(a) ? a : \"undefined\" === typeof a ? {} : {\n          x: a,\n          y: e,\n          r: C\n        };\n        e = this.createElement(\"circle\");\n\n        e.xSetter = e.ySetter = function (a, g, e) {\n          e.setAttribute(\"c\" + g, a);\n        };\n\n        return e.attr(a);\n      };\n\n      C.prototype.arc = function (a, e, C, l, d, b) {\n        g(a) ? (l = a, e = l.y, C = l.r, a = l.x) : l = {\n          innerR: l,\n          start: d,\n          end: b\n        };\n        a = this.symbol(\"arc\", a, e, C, C, l);\n        a.r = C;\n        return a;\n      };\n\n      C.prototype.rect = function (a, e, C, l, d, b) {\n        d = g(a) ? a.r : d;\n        var r = this.createElement(\"rect\");\n        a = g(a) ? a : \"undefined\" === typeof a ? {} : {\n          x: a,\n          y: e,\n          width: Math.max(C, 0),\n          height: Math.max(l, 0)\n        };\n        this.styledMode || (\"undefined\" !== typeof b && (a[\"stroke-width\"] = b, a = r.crisp(a)), a.fill = \"none\");\n        d && (a.r = d);\n\n        r.rSetter = function (a, g, e) {\n          r.r = a;\n          H(e, {\n            rx: a,\n            ry: a\n          });\n        };\n\n        r.rGetter = function () {\n          return r.r || 0;\n        };\n\n        return r.attr(a);\n      };\n\n      C.prototype.setSize = function (a, g, e) {\n        this.width = a;\n        this.height = g;\n        this.boxWrapper.animate({\n          width: a,\n          height: g\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: r(e, !0) ? void 0 : 0\n        });\n        this.alignElements();\n      };\n\n      C.prototype.g = function (a) {\n        var g = this.createElement(\"g\");\n        return a ? g.attr({\n          \"class\": \"highcharts-\" + a\n        }) : g;\n      };\n\n      C.prototype.image = function (a, g, e, C, d, b) {\n        var r = {\n          preserveAspectRatio: \"none\"\n        },\n            f = function (a, g) {\n          a.setAttributeNS ? a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", g) : a.setAttribute(\"hc-svg-href\", g);\n        };\n\n        l(g) && (r.x = g);\n        l(e) && (r.y = e);\n        l(C) && (r.width = C);\n        l(d) && (r.height = d);\n        var J = this.createElement(\"image\").attr(r);\n\n        g = function (g) {\n          f(J.element, a);\n          b.call(J, g);\n        };\n\n        b ? (f(J.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), e = new M.Image(), N(e, \"load\", g), e.src = a, e.complete && g({})) : f(J.element, a);\n        return J;\n      };\n\n      C.prototype.symbol = function (g, C, l, d, b, f) {\n        var J = this,\n            u = /^url\\((.*?)\\)$/,\n            x = u.test(g),\n            z = !x && (this.symbols[g] ? g : \"circle\"),\n            G = z && this.symbols[z],\n            v;\n\n        if (G) {\n          \"number\" === typeof C && (v = G.call(this.symbols, Math.round(C || 0), Math.round(l || 0), d || 0, b || 0, f));\n          var P = this.path(v);\n          J.styledMode || P.attr(\"fill\", \"none\");\n          e(P, {\n            symbolName: z || void 0,\n            x: C,\n            y: l,\n            width: d,\n            height: b\n          });\n          f && e(P, f);\n        } else if (x) {\n          var L = g.match(u)[1];\n          var m = P = this.image(L);\n          m.imgwidth = r(K[L] && K[L].width, f && f.width);\n          m.imgheight = r(K[L] && K[L].height, f && f.height);\n\n          var n = function (a) {\n            return a.attr({\n              width: a.width,\n              height: a.height\n            });\n          };\n\n          [\"width\", \"height\"].forEach(function (g) {\n            m[g + \"Setter\"] = function (g, e) {\n              var C = this[\"img\" + e];\n              this[e] = g;\n              a(C) && (f && \"within\" === f.backgroundSize && this.width && this.height && (C = Math.round(C * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(e, C), this.alignByTranslate || (g = ((this[e] || 0) - C) / 2, this.attr(\"width\" === e ? {\n                translateX: g\n              } : {\n                translateY: g\n              })));\n            };\n          });\n          a(C) && m.attr({\n            x: C,\n            y: l\n          });\n          m.isImg = !0;\n          a(m.imgwidth) && a(m.imgheight) ? n(m) : (m.attr({\n            width: 0,\n            height: 0\n          }), q(\"img\", {\n            onload: function () {\n              var a = t[J.chartIndex];\n              0 === this.width && (w(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), k.body.appendChild(this));\n              K[L] = {\n                width: this.width,\n                height: this.height\n              };\n              m.imgwidth = this.width;\n              m.imgheight = this.height;\n              m.element && n(m);\n              this.parentNode && this.parentNode.removeChild(this);\n              J.imgCount--;\n              if (!J.imgCount && a && !a.hasLoaded) a.onload();\n            },\n            src: L\n          }), this.imgCount++);\n        }\n\n        return P;\n      };\n\n      C.prototype.clipRect = function (a, g, e, C) {\n        var l = Q() + \"-\",\n            d = this.createElement(\"clipPath\").attr({\n          id: l\n        }).add(this.defs);\n        a = this.rect(a, g, e, C, 0).add(d);\n        a.id = l;\n        a.clipPath = d;\n        a.count = 0;\n        return a;\n      };\n\n      C.prototype.text = function (g, e, C, l) {\n        var d = {};\n        if (l && (this.allowHTML || !this.forExport)) return this.html(g, e, C);\n        d.x = Math.round(e || 0);\n        C && (d.y = Math.round(C));\n        a(g) && (d.text = g);\n        g = this.createElement(\"text\").attr(d);\n        if (!l || this.forExport && !this.allowHTML) g.xSetter = function (a, g, e) {\n          for (var C = e.getElementsByTagName(\"tspan\"), l = e.getAttribute(g), d = 0, b; d < C.length; d++) b = C[d], b.getAttribute(g) === l && b.setAttribute(g, a);\n\n          e.setAttribute(g, a);\n        };\n        return g;\n      };\n\n      C.prototype.fontMetrics = function (a, g) {\n        a = !this.styledMode && /px/.test(a) || !M.getComputedStyle ? a || g && g.style && g.style.fontSize || this.style && this.style.fontSize : g && A.prototype.getStyle.call(g, \"font-size\");\n        a = /px/.test(a) ? L(a) : 12;\n        g = 24 > a ? a + 3 : Math.round(1.2 * a);\n        return {\n          h: g,\n          b: Math.round(.8 * g),\n          f: a\n        };\n      };\n\n      C.prototype.rotCorr = function (a, g, e) {\n        var C = a;\n        g && e && (C = Math.max(C * Math.cos(g * b), 4));\n        return {\n          x: -a / 3 * Math.sin(g * b),\n          y: C\n        };\n      };\n\n      C.prototype.pathToSegments = function (a) {\n        for (var g = [], e = [], C = {\n          A: 8,\n          C: 7,\n          H: 2,\n          L: 3,\n          M: 3,\n          Q: 5,\n          S: 5,\n          T: 3,\n          V: 2\n        }, d = 0; d < a.length; d++) G(e[0]) && l(a[d]) && e.length === C[e[0].toUpperCase()] && a.splice(d, 0, e[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" === typeof a[d] && (e.length && g.push(e.slice(0)), e.length = 0), e.push(a[d]);\n\n        g.push(e.slice(0));\n        return g;\n      };\n\n      C.prototype.label = function (a, g, e, C, l, d, b, r, f) {\n        return new D(this, a, g, e, C, l, d, b, r, f);\n      };\n\n      C.prototype.alignElements = function () {\n        this.alignedObjects.forEach(function (a) {\n          return a.align();\n        });\n      };\n\n      return C;\n    }();\n\n    e(B.prototype, {\n      Element: A,\n      SVG_NS: v,\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      symbols: F,\n      draw: d\n    });\n    E.registerRendererType(\"svg\", B, !0);\n    \"\";\n    return B;\n  });\n  O(h, \"Core/Renderer/HTML/HTMLElement.js\", [h[\"Core/Globals.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var I = this && this.__extends || function () {\n      var b = function (f, d) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var f in b) b.hasOwnProperty(f) && (d[f] = b[f]);\n        };\n\n        return b(f, d);\n      };\n\n      return function (f, d) {\n        function v() {\n          this.constructor = f;\n        }\n\n        b(f, d);\n        f.prototype = null === d ? Object.create(d) : (v.prototype = d.prototype, new v());\n      };\n    }(),\n        A = c.isFirefox,\n        D = c.isMS,\n        F = c.isWebKit,\n        y = c.win,\n        p = B.css,\n        t = B.defined,\n        b = B.extend,\n        k = B.pick,\n        n = B.pInt;\n\n    return function (m) {\n      function f() {\n        return null !== m && m.apply(this, arguments) || this;\n      }\n\n      I(f, m);\n\n      f.compose = function (d) {\n        if (-1 === f.composedClasses.indexOf(d)) {\n          f.composedClasses.push(d);\n          var b = f.prototype,\n              k = d.prototype;\n          k.getSpanCorrection = b.getSpanCorrection;\n          k.htmlCss = b.htmlCss;\n          k.htmlGetBBox = b.htmlGetBBox;\n          k.htmlUpdateTransform = b.htmlUpdateTransform;\n          k.setSpanRotation = b.setSpanRotation;\n        }\n\n        return d;\n      };\n\n      f.prototype.getSpanCorrection = function (d, b, f) {\n        this.xCorr = -d * f;\n        this.yCorr = -b;\n      };\n\n      f.prototype.htmlCss = function (d) {\n        var f = \"SPAN\" === this.element.tagName && d && \"width\" in d,\n            m = k(f && d.width, void 0);\n\n        if (f) {\n          delete d.width;\n          this.textWidth = m;\n          var n = !0;\n        }\n\n        d && \"ellipsis\" === d.textOverflow && (d.whiteSpace = \"nowrap\", d.overflow = \"hidden\");\n        this.styles = b(this.styles, d);\n        p(this.element, d);\n        n && this.htmlUpdateTransform();\n        return this;\n      };\n\n      f.prototype.htmlGetBBox = function () {\n        var d = this.element;\n        return {\n          x: d.offsetLeft,\n          y: d.offsetTop,\n          width: d.offsetWidth,\n          height: d.offsetHeight\n        };\n      };\n\n      f.prototype.htmlUpdateTransform = function () {\n        if (this.added) {\n          var d = this.renderer,\n              b = this.element,\n              f = this.translateX || 0,\n              k = this.translateY || 0,\n              m = this.x || 0,\n              c = this.y || 0,\n              q = this.textAlign || \"left\",\n              w = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[q],\n              a = this.styles;\n          a = a && a.whiteSpace;\n          p(b, {\n            marginLeft: f,\n            marginTop: k\n          });\n          !d.styledMode && this.shadows && this.shadows.forEach(function (a) {\n            p(a, {\n              marginLeft: f + 1,\n              marginTop: k + 1\n            });\n          });\n          this.inverted && [].forEach.call(b.childNodes, function (a) {\n            d.invertChild(a, b);\n          });\n\n          if (\"SPAN\" === b.tagName) {\n            var x = this.rotation,\n                e = this.textWidth && n(this.textWidth),\n                u = [x, q, b.innerHTML, this.textWidth, this.textAlign].join(),\n                l = void 0;\n            l = !1;\n\n            if (e !== this.oldTextWidth) {\n              if (this.textPxLength) var g = this.textPxLength;else p(b, {\n                width: \"\",\n                whiteSpace: a || \"nowrap\"\n              }), g = b.offsetWidth;\n              (e > this.oldTextWidth || g > e) && (/[ \\-]/.test(b.textContent || b.innerText) || \"ellipsis\" === b.style.textOverflow) && (p(b, {\n                width: g > e || x ? e + \"px\" : \"auto\",\n                display: \"block\",\n                whiteSpace: a || \"normal\"\n              }), this.oldTextWidth = e, l = !0);\n            }\n\n            this.hasBoxWidthChanged = l;\n            u !== this.cTT && (l = d.fontMetrics(b.style.fontSize, b).b, !t(x) || x === (this.oldRotation || 0) && q === this.oldAlign || this.setSpanRotation(x, w, l), this.getSpanCorrection(!t(x) && this.textPxLength || b.offsetWidth, l, w, x, q));\n            p(b, {\n              left: m + (this.xCorr || 0) + \"px\",\n              top: c + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = u;\n            this.oldRotation = x;\n            this.oldAlign = q;\n          }\n        } else this.alignOnAdd = !0;\n      };\n\n      f.prototype.setSpanRotation = function (d, b, f) {\n        var k = {},\n            v = D && !/Edge/.test(y.navigator.userAgent) ? \"-ms-transform\" : F ? \"-webkit-transform\" : A ? \"MozTransform\" : y.opera ? \"-o-transform\" : void 0;\n        v && (k[v] = k.transform = \"rotate(\" + d + \"deg)\", k[v + (A ? \"Origin\" : \"-origin\")] = k.transformOrigin = 100 * b + \"% \" + f + \"px\", p(this.element, k));\n      };\n\n      f.composedClasses = [];\n      return f;\n    }(h);\n  });\n  O(h, \"Core/Renderer/HTML/HTMLRenderer.js\", [h[\"Core/Renderer/HTML/AST.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Renderer/SVG/SVGRenderer.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E) {\n    var I = this && this.__extends || function () {\n      var c = function (b, k) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, k) {\n          b.__proto__ = k;\n        } || function (b, k) {\n          for (var f in k) k.hasOwnProperty(f) && (b[f] = k[f]);\n        };\n\n        return c(b, k);\n      };\n\n      return function (b, k) {\n        function n() {\n          this.constructor = b;\n        }\n\n        c(b, k);\n        b.prototype = null === k ? Object.create(k) : (n.prototype = k.prototype, new n());\n      };\n    }(),\n        D = E.attr,\n        F = E.createElement,\n        y = E.extend,\n        p = E.pick;\n\n    return function (t) {\n      function b() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      I(b, t);\n\n      b.compose = function (k) {\n        -1 === b.composedClasses.indexOf(k) && (b.composedClasses.push(k), k.prototype.html = b.prototype.html);\n        return k;\n      };\n\n      b.prototype.html = function (b, n, m) {\n        var f = this.createElement(\"span\"),\n            d = f.element,\n            k = f.renderer,\n            t = k.isSVG,\n            M = function (d, b) {\n          [\"opacity\", \"visibility\"].forEach(function (f) {\n            d[f + \"Setter\"] = function (q, a, x) {\n              var e = d.div ? d.div.style : b;\n              h.prototype[f + \"Setter\"].call(this, q, a, x);\n              e && (e[a] = q);\n            };\n          });\n          d.addedSetters = !0;\n        };\n\n        f.textSetter = function (d) {\n          d !== this.textStr && (delete this.bBox, delete this.oldTextWidth, c.setElementHTML(this.element, p(d, \"\")), this.textStr = d, f.doTransform = !0);\n        };\n\n        t && M(f, f.element.style);\n\n        f.xSetter = f.ySetter = f.alignSetter = f.rotationSetter = function (d, b) {\n          \"align\" === b ? f.alignValue = f.textAlign = d : f[b] = d;\n          f.doTransform = !0;\n        };\n\n        f.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        f.attr({\n          text: b,\n          x: Math.round(n),\n          y: Math.round(m)\n        }).css({\n          position: \"absolute\"\n        });\n        k.styledMode || f.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        d.style.whiteSpace = \"nowrap\";\n        f.css = f.htmlCss;\n        t && (f.add = function (b) {\n          var v = k.box.parentNode,\n              q = [];\n\n          if (this.parentGroup = b) {\n            var w = b.div;\n\n            if (!w) {\n              for (; b;) q.push(b), b = b.parentGroup;\n\n              q.reverse().forEach(function (a) {\n                function d(g, e) {\n                  a[e] = g;\n                  \"translateX\" === e ? l.left = g + \"px\" : l.top = g + \"px\";\n                  a.doTransform = !0;\n                }\n\n                var e = D(a.element, \"class\"),\n                    b = a.styles || {};\n                w = a.div = a.div || F(\"div\", e ? {\n                  className: e\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  cursor: b.cursor,\n                  pointerEvents: b.pointerEvents,\n                  visibility: a.visibility\n                }, w || v);\n                var l = w.style;\n                y(a, {\n                  classSetter: function (a) {\n                    return function (g) {\n                      this.element.setAttribute(\"class\", g);\n                      a.className = g;\n                    };\n                  }(w),\n                  on: function () {\n                    q[0].div && f.on.apply({\n                      element: q[0].div,\n                      onEvents: a.onEvents\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: d,\n                  translateYSetter: d\n                });\n                a.addedSetters || M(a);\n              });\n            }\n          } else w = v;\n\n          w.appendChild(d);\n          f.added = !0;\n          f.alignOnAdd && f.htmlUpdateTransform();\n          return f;\n        });\n        return f;\n      };\n\n      b.composedClasses = [];\n      return b;\n    }(B);\n  });\n  O(h, \"Core/Axis/AxisDefaults.js\", [], function () {\n    var c = /*#__PURE__*/(() => {\n      (function (c) {\n        c.defaultXAxisOptions = {\n          alignTicks: !0,\n          allowDecimals: void 0,\n          panningEnabled: !0,\n          zIndex: 2,\n          zoomEnabled: !0,\n          dateTimeLabelFormats: {\n            millisecond: {\n              main: \"%H:%M:%S.%L\",\n              range: !1\n            },\n            second: {\n              main: \"%H:%M:%S\",\n              range: !1\n            },\n            minute: {\n              main: \"%H:%M\",\n              range: !1\n            },\n            hour: {\n              main: \"%H:%M\",\n              range: !1\n            },\n            day: {\n              main: \"%e. %b\"\n            },\n            week: {\n              main: \"%e. %b\"\n            },\n            month: {\n              main: \"%b '%y\"\n            },\n            year: {\n              main: \"%Y\"\n            }\n          },\n          endOnTick: !1,\n          gridLineDashStyle: \"Solid\",\n          gridZIndex: 1,\n          labels: {\n            autoRotation: void 0,\n            autoRotationLimit: 80,\n            distance: void 0,\n            enabled: !0,\n            indentation: 10,\n            overflow: \"justify\",\n            padding: 5,\n            reserveSpace: void 0,\n            rotation: void 0,\n            staggerLines: 0,\n            step: 0,\n            useHTML: !1,\n            x: 0,\n            zIndex: 7,\n            style: {\n              color: \"#666666\",\n              cursor: \"default\",\n              fontSize: \"11px\"\n            }\n          },\n          maxPadding: .01,\n          minorGridLineDashStyle: \"Solid\",\n          minorTickLength: 2,\n          minorTickPosition: \"outside\",\n          minPadding: .01,\n          offset: void 0,\n          opposite: !1,\n          reversed: void 0,\n          reversedStacks: !1,\n          showEmpty: !0,\n          showFirstLabel: !0,\n          showLastLabel: !0,\n          startOfWeek: 1,\n          startOnTick: !1,\n          tickLength: 10,\n          tickPixelInterval: 100,\n          tickmarkPlacement: \"between\",\n          tickPosition: \"outside\",\n          title: {\n            align: \"middle\",\n            rotation: 0,\n            useHTML: !1,\n            x: 0,\n            y: 0,\n            style: {\n              color: \"#666666\"\n            }\n          },\n          type: \"linear\",\n          uniqueNames: !0,\n          visible: !0,\n          minorGridLineColor: \"#f2f2f2\",\n          minorGridLineWidth: 1,\n          minorTickColor: \"#999999\",\n          lineColor: \"#ccd6eb\",\n          lineWidth: 1,\n          gridLineColor: \"#e6e6e6\",\n          gridLineWidth: void 0,\n          tickColor: \"#ccd6eb\"\n        };\n        c.defaultYAxisOptions = {\n          reversedStacks: !0,\n          endOnTick: !0,\n          maxPadding: .05,\n          minPadding: .05,\n          tickPixelInterval: 72,\n          showLastLabel: !0,\n          labels: {\n            x: -8\n          },\n          startOnTick: !0,\n          title: {\n            rotation: 270,\n            text: \"Values\"\n          },\n          stackLabels: {\n            animation: {},\n            allowOverlap: !1,\n            enabled: !1,\n            crop: !0,\n            overflow: \"justify\",\n            formatter: function () {\n              var c = this.axis.chart.numberFormatter;\n              return c(this.total || 0, -1);\n            },\n            style: {\n              color: \"#000000\",\n              fontSize: \"11px\",\n              fontWeight: \"bold\",\n              textOutline: \"1px contrast\"\n            }\n          },\n          gridLineWidth: 1,\n          lineWidth: 0\n        };\n        c.defaultLeftAxisOptions = {\n          labels: {\n            x: -15\n          },\n          title: {\n            rotation: 270\n          }\n        };\n        c.defaultRightAxisOptions = {\n          labels: {\n            x: 15\n          },\n          title: {\n            rotation: 90\n          }\n        };\n        c.defaultBottomAxisOptions = {\n          labels: {\n            autoRotation: [-45],\n            x: 0\n          },\n          margin: 15,\n          title: {\n            rotation: 0\n          }\n        };\n        c.defaultTopAxisOptions = {\n          labels: {\n            autoRotation: [-45],\n            x: 0\n          },\n          margin: 15,\n          title: {\n            rotation: 0\n          }\n        };\n      })(c || (c = {}));\n\n      return c;\n    })();\n    return c;\n  });\n  O(h, \"Core/Foundation.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    var h = c.addEvent,\n        B = c.isFunction,\n        E = c.objectEach,\n        A = c.removeEvent,\n        D;\n\n    (function (c) {\n      c.registerEventOptions = function (c, p) {\n        c.eventOptions = c.eventOptions || {};\n        E(p.events, function (p, b) {\n          c.eventOptions[b] !== p && (c.eventOptions[b] && (A(c, b, c.eventOptions[b]), delete c.eventOptions[b]), B(p) && (c.eventOptions[b] = p, h(c, b, p)));\n        });\n      };\n    })(D || (D = {}));\n\n    return D;\n  });\n  O(h, \"Core/Axis/Tick.js\", [h[\"Core/FormatUtilities.js\"], h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var I = h.deg2rad,\n        A = B.clamp,\n        D = B.correctFloat,\n        F = B.defined,\n        y = B.destroyObjectProperties,\n        p = B.extend,\n        t = B.fireEvent,\n        b = B.isNumber,\n        k = B.merge,\n        n = B.objectEach,\n        m = B.pick;\n\n    h = function () {\n      function f(d, b, f, k, m) {\n        this.isNewLabel = this.isNew = !0;\n        this.axis = d;\n        this.pos = b;\n        this.type = f || \"\";\n        this.parameters = m || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        t(this, \"init\");\n        f || k || this.addLabel();\n      }\n\n      f.prototype.addLabel = function () {\n        var d = this,\n            f = d.axis,\n            k = f.options,\n            n = f.chart,\n            h = f.categories,\n            H = f.logarithmic,\n            q = f.names,\n            w = d.pos,\n            a = m(d.options && d.options.labels, k.labels),\n            x = f.tickPositions,\n            e = w === x[0],\n            u = w === x[x.length - 1],\n            l = (!a.step || 1 === a.step) && 1 === f.tickInterval;\n        x = x.info;\n        var g = d.label,\n            G;\n        h = this.parameters.category || (h ? m(h[w], q[w], w) : w);\n        H && b(h) && (h = D(H.lin2log(h)));\n        if (f.dateTime) if (x) {\n          var z = n.time.resolveDTLFormat(k.dateTimeLabelFormats[!k.grid && x.higherRanks[w] || x.unitName]);\n          var r = z.main;\n        } else b(h) && (r = f.dateTime.getXDateFormat(h, k.dateTimeLabelFormats || {}));\n        d.isFirst = e;\n        d.isLast = u;\n        var L = {\n          axis: f,\n          chart: n,\n          dateTimeLabelFormat: r,\n          isFirst: e,\n          isLast: u,\n          pos: w,\n          tick: d,\n          tickPositionInfo: x,\n          value: h\n        };\n        t(this, \"labelFormat\", L);\n\n        var Q = function (g) {\n          return a.formatter ? a.formatter.call(g, g) : a.format ? (g.text = f.defaultLabelFormatter.call(g), c.format(a.format, g, n)) : f.defaultLabelFormatter.call(g, g);\n        };\n\n        k = Q.call(L, L);\n        var S = z && z.list;\n        d.shortenLabel = S ? function () {\n          for (G = 0; G < S.length; G++) if (p(L, {\n            dateTimeLabelFormat: S[G]\n          }), g.attr({\n            text: Q.call(L, L)\n          }), g.getBBox().width < f.getSlotWidth(d) - 2 * a.padding) return;\n\n          g.attr({\n            text: \"\"\n          });\n        } : void 0;\n        l && f._addedPlotLB && d.moveLabel(k, a);\n        F(g) || d.movedLabel ? g && g.textStr !== k && !l && (!g.textWidth || a.style.width || g.styles.width || g.css({\n          width: null\n        }), g.attr({\n          text: k\n        }), g.textPxLength = g.getBBox().width) : (d.label = g = d.createLabel({\n          x: 0,\n          y: 0\n        }, k, a), d.rotation = 0);\n      };\n\n      f.prototype.createLabel = function (d, b, f) {\n        var m = this.axis,\n            v = m.chart;\n        if (d = F(b) && f.enabled ? v.renderer.text(b, d.x, d.y, f.useHTML).add(m.labelGroup) : null) v.styledMode || d.css(k(f.style)), d.textPxLength = d.getBBox().width;\n        return d;\n      };\n\n      f.prototype.destroy = function () {\n        y(this, this.axis);\n      };\n\n      f.prototype.getPosition = function (d, b, f, k) {\n        var m = this.axis,\n            v = m.chart,\n            q = k && v.oldChartHeight || v.chartHeight;\n        d = {\n          x: d ? D(m.translate(b + f, void 0, void 0, k) + m.transB) : m.left + m.offset + (m.opposite ? (k && v.oldChartWidth || v.chartWidth) - m.right - m.left : 0),\n          y: d ? q - m.bottom + m.offset - (m.opposite ? m.height : 0) : D(q - m.translate(b + f, void 0, void 0, k) - m.transB)\n        };\n        d.y = A(d.y, -1E5, 1E5);\n        t(this, \"afterGetPosition\", {\n          pos: d\n        });\n        return d;\n      };\n\n      f.prototype.getLabelPosition = function (d, b, f, k, m, c, q, w) {\n        var a = this.axis,\n            x = a.transA,\n            e = a.isLinked && a.linkedParent ? a.linkedParent.reversed : a.reversed,\n            u = a.staggerLines,\n            l = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            g = k || a.reserveSpaceDefault ? 0 : -a.labelOffset * (\"center\" === a.labelAlign ? .5 : 1),\n            G = {};\n        f = 0 === a.side ? f.rotation ? -8 : -f.getBBox().height : 2 === a.side ? l.y + 8 : Math.cos(f.rotation * I) * (l.y - f.getBBox(!1, 0).height / 2);\n        F(m.y) && (f = 0 === a.side && a.horiz ? m.y + f : m.y);\n        d = d + m.x + g + l.x - (c && k ? c * x * (e ? -1 : 1) : 0);\n        b = b + f - (c && !k ? c * x * (e ? 1 : -1) : 0);\n        u && (k = q / (w || 1) % u, a.opposite && (k = u - k - 1), b += a.labelOffset / u * k);\n        G.x = d;\n        G.y = Math.round(b);\n        t(this, \"afterGetLabelPosition\", {\n          pos: G,\n          tickmarkOffset: c,\n          index: q\n        });\n        return G;\n      };\n\n      f.prototype.getLabelSize = function () {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      };\n\n      f.prototype.getMarkPath = function (b, f, k, m, c, n) {\n        return n.crispLine([[\"M\", b, f], [\"L\", b + (c ? 0 : -k), f + (c ? k : 0)]], m);\n      };\n\n      f.prototype.handleOverflow = function (b) {\n        var d = this.axis,\n            f = d.options.labels,\n            k = b.x,\n            c = d.chart.chartWidth,\n            n = d.chart.spacing,\n            q = m(d.labelLeft, Math.min(d.pos, n[3]));\n        n = m(d.labelRight, Math.max(d.isRadial ? 0 : d.pos + d.len, c - n[1]));\n        var w = this.label,\n            a = this.rotation,\n            x = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[d.labelAlign || w.attr(\"align\")],\n            e = w.getBBox().width,\n            u = d.getSlotWidth(this),\n            l = {},\n            g = u,\n            G = 1,\n            z;\n        if (a || \"justify\" !== f.overflow) 0 > a && k - x * e < q ? z = Math.round(k / Math.cos(a * I) - q) : 0 < a && k + x * e > n && (z = Math.round((c - k) / Math.cos(a * I)));else if (c = k + (1 - x) * e, k - x * e < q ? g = b.x + g * (1 - x) - q : c > n && (g = n - b.x + g * x, G = -1), g = Math.min(u, g), g < u && \"center\" === d.labelAlign && (b.x += G * (u - g - x * (u - Math.min(e, g)))), e > g || d.autoRotation && (w.styles || {}).width) z = g;\n        z && (this.shortenLabel ? this.shortenLabel() : (l.width = Math.floor(z) + \"px\", (f.style || {}).textOverflow || (l.textOverflow = \"ellipsis\"), w.css(l)));\n      };\n\n      f.prototype.moveLabel = function (b, f) {\n        var d = this,\n            k = d.label,\n            m = d.axis,\n            c = m.reversed,\n            q = !1;\n        k && k.textStr === b ? (d.movedLabel = k, q = !0, delete d.label) : n(m.ticks, function (a) {\n          q || a.isNew || a === d || !a.label || a.label.textStr !== b || (d.movedLabel = a.label, q = !0, a.labelPos = d.movedLabel.xy, delete a.label);\n        });\n\n        if (!q && (d.labelPos || k)) {\n          var w = d.labelPos || k.xy;\n          k = m.horiz ? c ? 0 : m.width + m.left : w.x;\n          m = m.horiz ? w.y : c ? m.width + m.left : 0;\n          d.movedLabel = d.createLabel({\n            x: k,\n            y: m\n          }, b, f);\n          d.movedLabel && d.movedLabel.attr({\n            opacity: 0\n          });\n        }\n      };\n\n      f.prototype.render = function (b, f, k) {\n        var d = this.axis,\n            c = d.horiz,\n            n = this.pos,\n            q = m(this.tickmarkOffset, d.tickmarkOffset);\n        n = this.getPosition(c, n, q, f);\n        q = n.x;\n        var w = n.y;\n        d = c && q === d.pos + d.len || !c && w === d.pos ? -1 : 1;\n        c = m(k, this.label && this.label.newOpacity, 1);\n        k = m(k, 1);\n        this.isActive = !0;\n        this.renderGridLine(f, k, d);\n        this.renderMark(n, k, d);\n        this.renderLabel(n, f, c, b);\n        this.isNew = !1;\n        t(this, \"afterRender\");\n      };\n\n      f.prototype.renderGridLine = function (d, b, f) {\n        var k = this.axis,\n            c = k.options,\n            n = {},\n            q = this.pos,\n            w = this.type,\n            a = m(this.tickmarkOffset, k.tickmarkOffset),\n            x = k.chart.renderer,\n            e = this.gridLine,\n            u = c.gridLineWidth,\n            l = c.gridLineColor,\n            g = c.gridLineDashStyle;\n        \"minor\" === this.type && (u = c.minorGridLineWidth, l = c.minorGridLineColor, g = c.minorGridLineDashStyle);\n        e || (k.chart.styledMode || (n.stroke = l, n[\"stroke-width\"] = u || 0, n.dashstyle = g), w || (n.zIndex = 1), d && (b = 0), this.gridLine = e = x.path().attr(n).addClass(\"highcharts-\" + (w ? w + \"-\" : \"\") + \"grid-line\").add(k.gridGroup));\n        if (e && (f = k.getPlotLinePath({\n          value: q + a,\n          lineWidth: e.strokeWidth() * f,\n          force: \"pass\",\n          old: d\n        }))) e[d || this.isNew ? \"attr\" : \"animate\"]({\n          d: f,\n          opacity: b\n        });\n      };\n\n      f.prototype.renderMark = function (d, b, f) {\n        var k = this.axis,\n            c = k.options,\n            n = k.chart.renderer,\n            q = this.type,\n            w = k.tickSize(q ? q + \"Tick\" : \"tick\"),\n            a = d.x;\n        d = d.y;\n        var x = m(c[\"minor\" !== q ? \"tickWidth\" : \"minorTickWidth\"], !q && k.isXAxis ? 1 : 0);\n        c = c[\"minor\" !== q ? \"tickColor\" : \"minorTickColor\"];\n        var e = this.mark,\n            u = !e;\n        w && (k.opposite && (w[0] = -w[0]), e || (this.mark = e = n.path().addClass(\"highcharts-\" + (q ? q + \"-\" : \"\") + \"tick\").add(k.axisGroup), k.chart.styledMode || e.attr({\n          stroke: c,\n          \"stroke-width\": x\n        })), e[u ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(a, d, w[0], e.strokeWidth() * f, k.horiz, n),\n          opacity: b\n        }));\n      };\n\n      f.prototype.renderLabel = function (d, f, k, c) {\n        var n = this.axis,\n            v = n.horiz,\n            q = n.options,\n            w = this.label,\n            a = q.labels,\n            x = a.step;\n        n = m(this.tickmarkOffset, n.tickmarkOffset);\n        var e = d.x;\n        d = d.y;\n        var u = !0;\n        w && b(e) && (w.xy = d = this.getLabelPosition(e, d, w, v, a, n, c, x), this.isFirst && !this.isLast && !q.showFirstLabel || this.isLast && !this.isFirst && !q.showLastLabel ? u = !1 : !v || a.step || a.rotation || f || 0 === k || this.handleOverflow(d), x && c % x && (u = !1), u && b(d.y) ? (d.opacity = k, w[this.isNewLabel ? \"attr\" : \"animate\"](d).show(!0), this.isNewLabel = !1) : (w.hide(), this.isNewLabel = !0));\n      };\n\n      f.prototype.replaceMovedLabel = function () {\n        var b = this.label,\n            f = this.axis,\n            k = f.reversed;\n\n        if (b && !this.isNew) {\n          var m = f.horiz ? k ? f.left : f.width + f.left : b.xy.x;\n          k = f.horiz ? b.xy.y : k ? f.width + f.top : f.top;\n          b.animate({\n            x: m,\n            y: k,\n            opacity: 0\n          }, void 0, b.destroy);\n          delete this.label;\n        }\n\n        f.isDirty = !0;\n        this.label = this.movedLabel;\n        delete this.movedLabel;\n      };\n\n      return f;\n    }();\n\n    \"\";\n    return h;\n  });\n  O(h, \"Core/Axis/Axis.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Axis/AxisDefaults.js\"], h[\"Core/Color/Color.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Foundation.js\"], h[\"Core/Globals.js\"], h[\"Core/Axis/Tick.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A, D, F, y) {\n    var p = c.animObject,\n        t = E.defaultOptions,\n        b = A.registerEventOptions,\n        k = D.deg2rad,\n        n = y.arrayMax,\n        m = y.arrayMin,\n        f = y.clamp,\n        d = y.correctFloat,\n        v = y.defined,\n        K = y.destroyObjectProperties,\n        M = y.erase,\n        N = y.error,\n        H = y.extend,\n        q = y.fireEvent,\n        w = y.isArray,\n        a = y.isNumber,\n        x = y.isString,\n        e = y.merge,\n        u = y.normalizeTickInterval,\n        l = y.objectEach,\n        g = y.pick,\n        G = y.relativeLength,\n        z = y.removeEvent,\n        r = y.splat,\n        L = y.syncTimeout,\n        Q = function (a, e) {\n      return u(e, void 0, void 0, g(a.options.allowDecimals, .5 > e || void 0 !== a.tickAmount), !!a.tickAmount);\n    };\n\n    c = function () {\n      function u(a, g) {\n        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;\n        this.init(a, g);\n      }\n\n      u.prototype.init = function (e, l) {\n        var C = l.isX;\n        this.chart = e;\n        this.horiz = e.inverted && !this.isZAxis ? !C : C;\n        this.isXAxis = C;\n        this.coll = this.coll || (C ? \"xAxis\" : \"yAxis\");\n        q(this, \"init\", {\n          userOptions: l\n        });\n        this.opposite = g(l.opposite, this.opposite);\n        this.side = g(l.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);\n        this.setOptions(l);\n        var d = this.options,\n            f = d.labels,\n            u = d.type;\n        this.userOptions = l;\n        this.minPixelPadding = 0;\n        this.reversed = g(d.reversed, this.reversed);\n        this.visible = d.visible;\n        this.zoomEnabled = d.zoomEnabled;\n        this.hasNames = \"category\" === u || !0 === d.categories;\n        this.categories = d.categories || (this.hasNames ? [] : void 0);\n        this.names || (this.names = [], this.names.keys = {});\n        this.plotLinesAndBandsGroups = {};\n        this.positiveValuesOnly = !!this.logarithmic;\n        this.isLinked = v(d.linkedTo);\n        this.ticks = {};\n        this.labelEdge = [];\n        this.minorTicks = {};\n        this.plotLinesAndBands = [];\n        this.alternateBands = {};\n        this.len = 0;\n        this.minRange = this.userMinRange = d.minRange || d.maxZoom;\n        this.range = d.range;\n        this.offset = d.offset || 0;\n        this.min = this.max = null;\n        l = g(d.crosshair, r(e.options.tooltip.crosshairs)[C ? 0 : 1]);\n        this.crosshair = !0 === l ? {} : l;\n        -1 === e.axes.indexOf(this) && (C ? e.axes.splice(e.xAxis.length, 0, this) : e.axes.push(this), e[this.coll].push(this));\n        this.series = this.series || [];\n        e.inverted && !this.isZAxis && C && \"undefined\" === typeof this.reversed && (this.reversed = !0);\n        this.labelRotation = a(f.rotation) ? f.rotation : void 0;\n        b(this, d);\n        q(this, \"afterInit\");\n      };\n\n      u.prototype.setOptions = function (a) {\n        this.options = e(h.defaultXAxisOptions, \"yAxis\" === this.coll && h.defaultYAxisOptions, [h.defaultTopAxisOptions, h.defaultRightAxisOptions, h.defaultBottomAxisOptions, h.defaultLeftAxisOptions][this.side], e(t[this.coll], a));\n        q(this, \"afterSetOptions\", {\n          userOptions: a\n        });\n      };\n\n      u.prototype.defaultLabelFormatter = function (g) {\n        var e = this.axis;\n        g = this.chart.numberFormatter;\n        var C = a(this.value) ? this.value : NaN,\n            l = e.chart.time,\n            d = this.dateTimeLabelFormat,\n            b = t.lang,\n            f = b.numericSymbols;\n        b = b.numericSymbolMagnitude || 1E3;\n        var r = e.logarithmic ? Math.abs(C) : e.tickInterval,\n            u = f && f.length;\n        if (e.categories) var q = \"\".concat(this.value);else if (d) q = l.dateFormat(d, C);else if (u && 1E3 <= r) for (; u-- && \"undefined\" === typeof q;) e = Math.pow(b, u + 1), r >= e && 0 === 10 * C % e && null !== f[u] && 0 !== C && (q = g(C / e, -1) + f[u]);\n        \"undefined\" === typeof q && (q = 1E4 <= Math.abs(C) ? g(C, -1) : g(C, -1, void 0, \"\"));\n        return q;\n      };\n\n      u.prototype.getSeriesExtremes = function () {\n        var e = this,\n            d = e.chart,\n            l;\n        q(this, \"getSeriesExtremes\", null, function () {\n          e.hasVisibleSeries = !1;\n          e.dataMin = e.dataMax = e.threshold = null;\n          e.softThreshold = !e.isXAxis;\n          e.stacking && e.stacking.buildStacks();\n          e.series.forEach(function (C) {\n            if (C.visible || !d.options.chart.ignoreHiddenSeries) {\n              var b = C.options,\n                  f = b.threshold;\n              e.hasVisibleSeries = !0;\n              e.positiveValuesOnly && 0 >= f && (f = null);\n\n              if (e.isXAxis) {\n                if (b = C.xData, b.length) {\n                  b = e.logarithmic ? b.filter(e.validatePositiveValue) : b;\n                  l = C.getXExtremes(b);\n                  var r = l.min;\n                  var u = l.max;\n                  a(r) || r instanceof Date || (b = b.filter(a), l = C.getXExtremes(b), r = l.min, u = l.max);\n                  b.length && (e.dataMin = Math.min(g(e.dataMin, r), r), e.dataMax = Math.max(g(e.dataMax, u), u));\n                }\n              } else if (C = C.applyExtremes(), a(C.dataMin) && (r = C.dataMin, e.dataMin = Math.min(g(e.dataMin, r), r)), a(C.dataMax) && (u = C.dataMax, e.dataMax = Math.max(g(e.dataMax, u), u)), v(f) && (e.threshold = f), !b.softThreshold || e.positiveValuesOnly) e.softThreshold = !1;\n            }\n          });\n        });\n        q(this, \"afterGetSeriesExtremes\");\n      };\n\n      u.prototype.translate = function (g, e, b, l, f, r) {\n        var C = this.linkedParent || this,\n            u = l && C.old ? C.old.min : C.min;\n        if (!a(u)) return NaN;\n        var q = C.minPixelPadding;\n        f = (C.isOrdinal || C.brokenAxis && C.brokenAxis.hasBreaks || C.logarithmic && f) && C.lin2val;\n        var k = 1,\n            x = 0;\n        l = l && C.old ? C.old.transA : C.transA;\n        l || (l = C.transA);\n        b && (k *= -1, x = C.len);\n        C.reversed && (k *= -1, x -= k * (C.sector || C.len));\n        e ? (r = (g * k + x - q) / l + u, f && (r = C.lin2val(r))) : (f && (g = C.val2lin(g)), g = k * (g - u) * l, r = (C.isRadial ? g : d(g)) + x + k * q + (a(r) ? l * r : 0));\n        return r;\n      };\n\n      u.prototype.toPixels = function (a, g) {\n        return this.translate(a, !1, !this.horiz, void 0, !0) + (g ? 0 : this.pos);\n      };\n\n      u.prototype.toValue = function (a, g) {\n        return this.translate(a - (g ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n      };\n\n      u.prototype.getPlotLinePath = function (e) {\n        function l(a, g, e) {\n          if (\"pass\" !== c && a < g || a > e) c ? a = f(a, g, e) : h = !0;\n          return a;\n        }\n\n        var C = this,\n            b = C.chart,\n            d = C.left,\n            r = C.top,\n            u = e.old,\n            k = e.value,\n            x = e.lineWidth,\n            z = u && b.oldChartHeight || b.chartHeight,\n            w = u && b.oldChartWidth || b.chartWidth,\n            G = C.transB,\n            m = e.translatedValue,\n            c = e.force,\n            L,\n            n,\n            v,\n            p,\n            h;\n        e = {\n          value: k,\n          lineWidth: x,\n          old: u,\n          force: c,\n          acrossPanes: e.acrossPanes,\n          translatedValue: m\n        };\n        q(this, \"getPlotLinePath\", e, function (e) {\n          m = g(m, C.translate(k, void 0, void 0, u));\n          m = f(m, -1E5, 1E5);\n          L = v = Math.round(m + G);\n          n = p = Math.round(z - m - G);\n          a(m) ? C.horiz ? (n = r, p = z - C.bottom, L = v = l(L, d, d + C.width)) : (L = d, v = w - C.right, n = p = l(n, r, r + C.height)) : (h = !0, c = !1);\n          e.path = h && !c ? null : b.renderer.crispLine([[\"M\", L, n], [\"L\", v, p]], x || 1);\n        });\n        return e.path;\n      };\n\n      u.prototype.getLinearTickPositions = function (a, g, e) {\n        var b = d(Math.floor(g / a) * a);\n        e = d(Math.ceil(e / a) * a);\n        var C = [],\n            l;\n        d(b + a) === b && (l = 20);\n        if (this.single) return [g];\n\n        for (g = b; g <= e;) {\n          C.push(g);\n          g = d(g + a, l);\n          if (g === f) break;\n          var f = g;\n        }\n\n        return C;\n      };\n\n      u.prototype.getMinorTickInterval = function () {\n        var a = this.options;\n        return !0 === a.minorTicks ? g(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      };\n\n      u.prototype.getMinorTickPositions = function () {\n        var a = this.options,\n            g = this.tickPositions,\n            e = this.minorTickInterval,\n            b = this.pointRangePadding || 0,\n            l = this.min - b;\n        b = this.max + b;\n        var d = b - l,\n            f = [];\n\n        if (d && d / e < this.len / 3) {\n          var r = this.logarithmic;\n          if (r) this.paddedTicks.forEach(function (a, g, b) {\n            g && f.push.apply(f, r.getLogTickPositions(e, b[g - 1], b[g], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) f = f.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(e), l, b, a.startOfWeek));else for (a = l + (g[0] - l) % e; a <= b && a !== f[0]; a += e) f.push(a);\n        }\n\n        0 !== f.length && this.trimTicks(f);\n        return f;\n      };\n\n      u.prototype.adjustForMinRange = function () {\n        var a = this.options,\n            e = this.logarithmic,\n            b = this.min,\n            l = this.max,\n            d = 0,\n            f,\n            r,\n            u,\n            q;\n        this.isXAxis && \"undefined\" === typeof this.minRange && !e && (v(a.min) || v(a.max) || v(a.floor) || v(a.ceiling) ? this.minRange = null : (this.series.forEach(function (a) {\n          u = a.xData;\n          q = a.xIncrement ? 1 : u.length - 1;\n          if (1 < u.length) for (f = q; 0 < f; f--) if (r = u[f] - u[f - 1], !d || r < d) d = r;\n        }), this.minRange = Math.min(5 * d, this.dataMax - this.dataMin)));\n\n        if (l - b < this.minRange) {\n          var k = this.dataMax - this.dataMin >= this.minRange;\n          var x = this.minRange;\n          var z = (x - l + b) / 2;\n          z = [b - z, g(a.min, b - z)];\n          k && (z[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);\n          b = n(z);\n          l = [b + x, g(a.max, b + x)];\n          k && (l[2] = e ? e.log2lin(this.dataMax) : this.dataMax);\n          l = m(l);\n          l - b < x && (z[0] = l - x, z[1] = g(a.min, l - x), b = n(z));\n        }\n\n        this.min = b;\n        this.max = l;\n      };\n\n      u.prototype.getClosest = function () {\n        var a;\n        this.categories ? a = 1 : this.series.forEach(function (g) {\n          var e = g.closestPointRange,\n              b = g.visible || !g.chart.options.chart.ignoreHiddenSeries;\n          !g.noSharedTooltip && v(e) && b && (a = v(a) ? Math.min(a, e) : e);\n        });\n        return a;\n      };\n\n      u.prototype.nameToX = function (a) {\n        var e = w(this.options.categories),\n            b = e ? this.categories : this.names,\n            l = a.options.x;\n        a.series.requireSorting = !1;\n        v(l) || (l = this.options.uniqueNames && b ? e ? b.indexOf(a.name) : g(b.keys[a.name], -1) : a.series.autoIncrement());\n\n        if (-1 === l) {\n          if (!e && b) var d = b.length;\n        } else d = l;\n\n        \"undefined\" !== typeof d ? (this.names[d] = a.name, this.names.keys[a.name] = d) : a.x && (d = a.x);\n        return d;\n      };\n\n      u.prototype.updateNames = function () {\n        var a = this,\n            g = this.names;\n        0 < g.length && (Object.keys(g.keys).forEach(function (a) {\n          delete g.keys[a];\n        }), g.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (g) {\n          g.xIncrement = null;\n          if (!g.points || g.isDirtyData) a.max = Math.max(a.max, g.xData.length - 1), g.processData(), g.generatePoints();\n          g.data.forEach(function (e, b) {\n            if (e && e.options && \"undefined\" !== typeof e.name) {\n              var l = a.nameToX(e);\n              \"undefined\" !== typeof l && l !== e.x && (e.x = l, g.xData[b] = l);\n            }\n          });\n        }));\n      };\n\n      u.prototype.setAxisTranslation = function () {\n        var a = this,\n            e = a.max - a.min,\n            b = a.linkedParent,\n            l = !!a.categories,\n            d = a.isXAxis,\n            f = a.axisPointRange || 0,\n            r = 0,\n            u = 0,\n            k = a.transA;\n\n        if (d || l || f) {\n          var z = a.getClosest();\n          b ? (r = b.minPointOffset, u = b.pointRangePadding) : a.series.forEach(function (e) {\n            var b = l ? 1 : d ? g(e.options.pointRange, z, 0) : a.axisPointRange || 0,\n                C = e.options.pointPlacement;\n            f = Math.max(f, b);\n            if (!a.single || l) e = e.is(\"xrange\") ? !d : d, r = Math.max(r, e && x(C) ? 0 : b / 2), u = Math.max(u, e && \"on\" === C ? 0 : b);\n          });\n          b = a.ordinal && a.ordinal.slope && z ? a.ordinal.slope / z : 1;\n          a.minPointOffset = r *= b;\n          a.pointRangePadding = u *= b;\n          a.pointRange = Math.min(f, a.single && l ? 1 : e);\n          d && (a.closestPointRange = z);\n        }\n\n        a.translationSlope = a.transA = k = a.staticScale || a.len / (e + u || 1);\n        a.transB = a.horiz ? a.left : a.bottom;\n        a.minPixelPadding = k * r;\n        q(this, \"afterSetAxisTranslation\");\n      };\n\n      u.prototype.minFromRange = function () {\n        return this.max - this.range;\n      };\n\n      u.prototype.setTickInterval = function (e) {\n        var b = this.chart,\n            l = this.logarithmic,\n            f = this.options,\n            C = this.isXAxis,\n            r = this.isLinked,\n            u = f.tickPixelInterval,\n            k = this.categories,\n            z = this.softThreshold,\n            x = f.maxPadding,\n            w = f.minPadding,\n            G = a(f.tickInterval) && 0 <= f.tickInterval ? f.tickInterval : void 0,\n            m = a(this.threshold) ? this.threshold : null;\n        this.dateTime || k || r || this.getTickAmount();\n        var c = g(this.userMin, f.min);\n        var L = g(this.userMax, f.max);\n\n        if (r) {\n          this.linkedParent = b[this.coll][f.linkedTo];\n          var n = this.linkedParent.getExtremes();\n          this.min = g(n.min, n.dataMin);\n          this.max = g(n.max, n.dataMax);\n          f.type !== this.linkedParent.options.type && N(11, 1, b);\n        } else {\n          if (z && v(m)) if (this.dataMin >= m) n = m, w = 0;else if (this.dataMax <= m) {\n            var p = m;\n            x = 0;\n          }\n          this.min = g(c, n, this.dataMin);\n          this.max = g(L, p, this.dataMax);\n        }\n\n        l && (this.positiveValuesOnly && !e && 0 >= Math.min(this.min, g(this.dataMin, this.min)) && N(10, 1, b), this.min = d(l.log2lin(this.min), 16), this.max = d(l.log2lin(this.max), 16));\n        this.range && v(this.max) && (this.userMin = this.min = c = Math.max(this.dataMin, this.minFromRange()), this.userMax = L = this.max, this.range = null);\n        q(this, \"foundExtremes\");\n        this.beforePadding && this.beforePadding();\n        this.adjustForMinRange();\n        !(k || this.axisPointRange || this.stacking && this.stacking.usePercentage || r) && v(this.min) && v(this.max) && (b = this.max - this.min) && (!v(c) && w && (this.min -= b * w), !v(L) && x && (this.max += b * x));\n        a(this.userMin) || (a(f.softMin) && f.softMin < this.min && (this.min = c = f.softMin), a(f.floor) && (this.min = Math.max(this.min, f.floor)));\n        a(this.userMax) || (a(f.softMax) && f.softMax > this.max && (this.max = L = f.softMax), a(f.ceiling) && (this.max = Math.min(this.max, f.ceiling)));\n        z && v(this.dataMin) && (m = m || 0, !v(c) && this.min < m && this.dataMin >= m ? this.min = this.options.minRange ? Math.min(m, this.max - this.minRange) : m : !v(L) && this.max > m && this.dataMax <= m && (this.max = this.options.minRange ? Math.max(m, this.min + this.minRange) : m));\n        a(this.min) && a(this.max) && !this.chart.polar && this.min > this.max && (v(this.options.min) ? this.max = this.min : v(this.options.max) && (this.min = this.max));\n        this.tickInterval = this.min === this.max || \"undefined\" === typeof this.min || \"undefined\" === typeof this.max ? 1 : r && this.linkedParent && !G && u === this.linkedParent.options.tickPixelInterval ? G = this.linkedParent.tickInterval : g(G, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, k ? 1 : (this.max - this.min) * u / Math.max(this.len, u));\n\n        if (C && !e) {\n          var h = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);\n          this.series.forEach(function (a) {\n            a.forceCrop = a.forceCropping && a.forceCropping();\n            a.processData(h);\n          });\n          q(this, \"postProcessData\", {\n            hasExtemesChanged: h\n          });\n        }\n\n        this.setAxisTranslation();\n        q(this, \"initialAxisTranslation\");\n        this.pointRange && !G && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n        e = g(f.minTickInterval, this.dateTime && !this.series.some(function (a) {\n          return a.noSharedTooltip;\n        }) ? this.closestPointRange : 0);\n        !G && this.tickInterval < e && (this.tickInterval = e);\n        this.dateTime || this.logarithmic || G || (this.tickInterval = Q(this, this.tickInterval));\n        this.tickAmount || (this.tickInterval = this.unsquish());\n        this.setTickPositions();\n      };\n\n      u.prototype.setTickPositions = function () {\n        var a = this.options,\n            g = a.tickPositions,\n            e = this.getMinorTickInterval(),\n            b = this.hasVerticalPanning(),\n            l = \"colorAxis\" === this.coll,\n            d = (l || !b) && a.startOnTick;\n        b = (l || !b) && a.endOnTick;\n        l = a.tickPositioner;\n        this.tickmarkOffset = this.categories && \"between\" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === e && this.tickInterval ? this.tickInterval / 5 : e;\n        this.single = this.min === this.max && v(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);\n        this.tickPositions = e = g && g.slice();\n\n        if (!e) {\n          if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {\n            if (this.dateTime) e = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) e = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else for (var f = a = this.tickInterval; f <= 2 * a;) if (e = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && e.length > this.tickAmount) this.tickInterval = Q(this, f *= 1.1);else break;\n          } else e = [this.min, this.max], N(19, !1, this.chart);\n          e.length > this.len && (e = [e[0], e.pop()], e[0] === e[1] && (e.length = 1));\n          this.tickPositions = e;\n          l && (l = l.apply(this, [this.min, this.max])) && (this.tickPositions = e = l);\n        }\n\n        this.paddedTicks = e.slice(0);\n        this.trimTicks(e, d, b);\n        this.isLinked || (this.single && 2 > e.length && !this.categories && !this.series.some(function (a) {\n          return a.is(\"heatmap\") && \"between\" === a.options.pointPlacement;\n        }) && (this.min -= .5, this.max += .5), g || l || this.adjustTickAmount());\n        q(this, \"afterSetTickPositions\");\n      };\n\n      u.prototype.trimTicks = function (a, g, e) {\n        var b = a[0],\n            l = a[a.length - 1],\n            d = !this.isOrdinal && this.minPointOffset || 0;\n        q(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (g && -Infinity !== b) this.min = b;else for (; this.min - d > a[0];) a.shift();\n          if (e) this.max = l;else for (; this.max + d < a[a.length - 1];) a.pop();\n          0 === a.length && v(b) && !this.options.tickPositions && a.push((l + b) / 2);\n        }\n      };\n\n      u.prototype.alignToOthers = function () {\n        var g = this,\n            e = [this],\n            b = g.options,\n            l = \"yAxis\" === this.coll && this.chart.options.chart.alignThresholds,\n            d = [],\n            f;\n        g.thresholdAlignment = void 0;\n\n        if ((!1 !== this.chart.options.chart.alignTicks && b.alignTicks || l) && !1 !== b.startOnTick && !1 !== b.endOnTick && !g.logarithmic) {\n          var r = function (a) {\n            var g = a.options;\n            return [a.horiz ? g.left : g.top, g.width, g.height, g.pane].join();\n          },\n              u = r(this);\n\n          this.chart[this.coll].forEach(function (a) {\n            var b = a.series;\n            b.length && b.some(function (a) {\n              return a.visible;\n            }) && a !== g && r(a) === u && (f = !0, e.push(a));\n          });\n        }\n\n        if (f && l) {\n          e.forEach(function (e) {\n            e = e.getThresholdAlignment(g);\n            a(e) && d.push(e);\n          });\n          var k = 1 < d.length ? d.reduce(function (a, g) {\n            return a + g;\n          }, 0) / d.length : void 0;\n          e.forEach(function (a) {\n            a.thresholdAlignment = k;\n          });\n        }\n\n        return f;\n      };\n\n      u.prototype.getThresholdAlignment = function (g) {\n        (!a(this.dataMin) || this !== g && this.series.some(function (a) {\n          return a.isDirty || a.isDirtyData;\n        })) && this.getSeriesExtremes();\n        if (a(this.threshold)) return g = f((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (g = 1 - g), g;\n      };\n\n      u.prototype.getTickAmount = function () {\n        var a = this.options,\n            g = a.tickPixelInterval,\n            e = a.tickAmount;\n        !v(a.tickInterval) && !e && this.len < g && !this.isRadial && !this.logarithmic && a.startOnTick && a.endOnTick && (e = 2);\n        !e && this.alignToOthers() && (e = Math.ceil(this.len / g) + 1);\n        4 > e && (this.finalTickAmt = e, e = 5);\n        this.tickAmount = e;\n      };\n\n      u.prototype.adjustTickAmount = function () {\n        var e = this,\n            b = e.finalTickAmt,\n            l = e.max,\n            f = e.min,\n            r = e.options,\n            u = e.tickPositions,\n            k = e.tickAmount,\n            q = e.thresholdAlignment,\n            z = u && u.length,\n            x = g(e.threshold, e.softThreshold ? 0 : null);\n        var w = e.tickInterval;\n\n        if (a(q)) {\n          var m = .5 > q ? Math.ceil(q * (k - 1)) : Math.floor(q * (k - 1));\n          r.reversed && (m = k - 1 - m);\n        }\n\n        if (e.hasData() && a(f) && a(l)) {\n          q = function () {\n            e.transA *= (z - 1) / (k - 1);\n            e.min = r.startOnTick ? u[0] : Math.min(f, u[0]);\n            e.max = r.endOnTick ? u[u.length - 1] : Math.max(l, u[u.length - 1]);\n          };\n\n          if (a(m) && a(e.threshold)) {\n            for (; u[m] !== x || u.length !== k || u[0] > f || u[u.length - 1] < l;) {\n              u.length = 0;\n\n              for (u.push(e.threshold); u.length < k;) void 0 === u[m] || u[m] > e.threshold ? u.unshift(d(u[0] - w)) : u.push(d(u[u.length - 1] + w));\n\n              if (w > 8 * e.tickInterval) break;\n              w *= 2;\n            }\n\n            q();\n          } else if (z < k) {\n            for (; u.length < k;) u.length % 2 || f === x ? u.push(d(u[u.length - 1] + w)) : u.unshift(d(u[0] - w));\n\n            q();\n          }\n\n          if (v(b)) {\n            for (w = x = u.length; w--;) (3 === b && 1 === w % 2 || 2 >= b && 0 < w && w < x - 1) && u.splice(w, 1);\n\n            e.finalTickAmt = void 0;\n          }\n        }\n      };\n\n      u.prototype.setScale = function () {\n        var a = !1,\n            g = !1;\n        this.series.forEach(function (e) {\n          a = a || e.isDirtyData || e.isDirty;\n          g = g || e.xAxis && e.xAxis.isDirty || !1;\n        });\n        this.setAxisSize();\n        var e = this.len !== (this.old && this.old.len);\n        e || a || g || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = e || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();\n        a && this.panningState && (this.panningState.isDirty = !0);\n        q(this, \"afterSetScale\");\n      };\n\n      u.prototype.setExtremes = function (a, e, b, l, d) {\n        var f = this,\n            u = f.chart;\n        b = g(b, !0);\n        f.series.forEach(function (a) {\n          delete a.kdTree;\n        });\n        d = H(d, {\n          min: a,\n          max: e\n        });\n        q(f, \"setExtremes\", d, function () {\n          f.userMin = a;\n          f.userMax = e;\n          f.eventArgs = d;\n          b && u.redraw(l);\n        });\n      };\n\n      u.prototype.zoom = function (a, e) {\n        var b = this,\n            l = this.dataMin,\n            d = this.dataMax,\n            f = this.options,\n            u = Math.min(l, g(f.min, l)),\n            r = Math.max(d, g(f.max, d));\n        a = {\n          newMin: a,\n          newMax: e\n        };\n        q(this, \"zoom\", a, function (a) {\n          var g = a.newMin,\n              e = a.newMax;\n          if (g !== b.min || e !== b.max) b.allowZoomOutside || (v(l) && (g < u && (g = u), g > r && (g = r)), v(d) && (e < u && (e = u), e > r && (e = r))), b.displayBtn = \"undefined\" !== typeof g || \"undefined\" !== typeof e, b.setExtremes(g, e, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          a.zoomed = !0;\n        });\n        return a.zoomed;\n      };\n\n      u.prototype.setAxisSize = function () {\n        var a = this.chart,\n            e = this.options,\n            b = e.offsets || [0, 0, 0, 0],\n            l = this.horiz,\n            d = this.width = Math.round(G(g(e.width, a.plotWidth - b[3] + b[1]), a.plotWidth)),\n            f = this.height = Math.round(G(g(e.height, a.plotHeight - b[0] + b[2]), a.plotHeight)),\n            u = this.top = Math.round(G(g(e.top, a.plotTop + b[0]), a.plotHeight, a.plotTop));\n        e = this.left = Math.round(G(g(e.left, a.plotLeft + b[3]), a.plotWidth, a.plotLeft));\n        this.bottom = a.chartHeight - f - u;\n        this.right = a.chartWidth - d - e;\n        this.len = Math.max(l ? d : f, 0);\n        this.pos = l ? e : u;\n      };\n\n      u.prototype.getExtremes = function () {\n        var a = this.logarithmic;\n        return {\n          min: a ? d(a.lin2log(this.min)) : this.min,\n          max: a ? d(a.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      };\n\n      u.prototype.getThreshold = function (a) {\n        var g = this.logarithmic,\n            e = g ? g.lin2log(this.min) : this.min;\n        g = g ? g.lin2log(this.max) : this.max;\n        null === a || -Infinity === a ? a = e : Infinity === a ? a = g : e > a ? a = e : g < a && (a = g);\n        return this.translate(a, 0, 1, 0, 1);\n      };\n\n      u.prototype.autoLabelAlign = function (a) {\n        var e = (g(a, 0) - 90 * this.side + 720) % 360;\n        a = {\n          align: \"center\"\n        };\n        q(this, \"autoLabelAlign\", a, function (a) {\n          15 < e && 165 > e ? a.align = \"right\" : 195 < e && 345 > e && (a.align = \"left\");\n        });\n        return a.align;\n      };\n\n      u.prototype.tickSize = function (a) {\n        var e = this.options,\n            b = g(e[\"tick\" === a ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === a && this.isXAxis && !this.categories ? 1 : 0),\n            l = e[\"tick\" === a ? \"tickLength\" : \"minorTickLength\"];\n\n        if (b && l) {\n          \"inside\" === e[a + \"Position\"] && (l = -l);\n          var d = [l, b];\n        }\n\n        a = {\n          tickSize: d\n        };\n        q(this, \"afterTickSize\", a);\n        return a.tickSize;\n      };\n\n      u.prototype.labelMetrics = function () {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      };\n\n      u.prototype.unsquish = function () {\n        var e = this.options.labels,\n            b = this.horiz,\n            l = this.tickInterval,\n            f = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / l),\n            u = e.rotation,\n            r = this.labelMetrics(),\n            q = Math.max(this.max - this.min, 0),\n            x = function (a) {\n          var g = a / (f || 1);\n          g = 1 < g ? Math.ceil(g) : 1;\n          g * l > q && Infinity !== a && Infinity !== f && q && (g = Math.ceil(q / l));\n          return d(g * l);\n        },\n            z = l,\n            w,\n            m,\n            G = Number.MAX_VALUE;\n\n        if (b) {\n          if (!e.staggerLines && !e.step) if (a(u)) var c = [u];else f < e.autoRotationLimit && (c = e.autoRotation);\n          c && c.forEach(function (a) {\n            if (a === u || a && -90 <= a && 90 >= a) {\n              m = x(Math.abs(r.h / Math.sin(k * a)));\n              var g = m + Math.abs(a / 360);\n              g < G && (G = g, w = a, z = m);\n            }\n          });\n        } else e.step || (z = x(r.h));\n\n        this.autoRotation = c;\n        this.labelRotation = g(w, a(u) ? u : 0);\n        return z;\n      };\n\n      u.prototype.getSlotWidth = function (g) {\n        var e = this.chart,\n            b = this.horiz,\n            l = this.options.labels,\n            d = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            f = e.margin[3];\n        if (g && a(g.slotWidth)) return g.slotWidth;\n        if (b && 2 > l.step) return l.rotation ? 0 : (this.staggerLines || 1) * this.len / d;\n\n        if (!b) {\n          g = l.style.width;\n          if (void 0 !== g) return parseInt(String(g), 10);\n          if (f) return f - e.spacing[3];\n        }\n\n        return .33 * e.chartWidth;\n      };\n\n      u.prototype.renderUnsquish = function () {\n        var a = this.chart,\n            g = a.renderer,\n            e = this.tickPositions,\n            b = this.ticks,\n            l = this.options.labels,\n            d = l.style,\n            f = this.horiz,\n            u = this.getSlotWidth(),\n            r = Math.max(1, Math.round(u - 2 * l.padding)),\n            k = {},\n            q = this.labelMetrics(),\n            z = d.textOverflow,\n            w = 0;\n        x(l.rotation) || (k.rotation = l.rotation || 0);\n        e.forEach(function (a) {\n          a = b[a];\n          a.movedLabel && a.replaceMovedLabel();\n          a && a.label && a.label.textPxLength > w && (w = a.label.textPxLength);\n        });\n        this.maxLabelLength = w;\n        if (this.autoRotation) w > r && w > q.h ? k.rotation = this.labelRotation : this.labelRotation = 0;else if (u) {\n          var m = r;\n\n          if (!z) {\n            var G = \"clip\";\n\n            for (r = e.length; !f && r--;) {\n              var c = e[r];\n              if (c = b[c].label) c.styles && \"ellipsis\" === c.styles.textOverflow ? c.css({\n                textOverflow: \"clip\"\n              }) : c.textPxLength > u && c.css({\n                width: u + \"px\"\n              }), c.getBBox().height > this.len / e.length - (q.h - q.f) && (c.specificTextOverflow = \"ellipsis\");\n            }\n          }\n        }\n        k.rotation && (m = w > .5 * a.chartHeight ? .33 * a.chartHeight : w, z || (G = \"ellipsis\"));\n        if (this.labelAlign = l.align || this.autoLabelAlign(this.labelRotation)) k.align = this.labelAlign;\n        e.forEach(function (a) {\n          var g = (a = b[a]) && a.label,\n              e = d.width,\n              l = {};\n          g && (g.attr(k), a.shortenLabel ? a.shortenLabel() : m && !e && \"nowrap\" !== d.whiteSpace && (m < g.textPxLength || \"SPAN\" === g.element.tagName) ? (l.width = m + \"px\", z || (l.textOverflow = g.specificTextOverflow || G), g.css(l)) : g.styles && g.styles.width && !l.width && !e && g.css({\n            width: null\n          }), delete g.specificTextOverflow, a.rotation = k.rotation);\n        }, this);\n        this.tickRotCorr = g.rotCorr(q.b, this.labelRotation || 0, 0 !== this.side);\n      };\n\n      u.prototype.hasData = function () {\n        return this.series.some(function (a) {\n          return a.hasData();\n        }) || this.options.showEmpty && v(this.min) && v(this.max);\n      };\n\n      u.prototype.addTitle = function (a) {\n        var g = this.chart.renderer,\n            b = this.horiz,\n            l = this.opposite,\n            d = this.options.title,\n            f = this.chart.styledMode,\n            u;\n        this.axisTitle || ((u = d.textAlign) || (u = (b ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: l ? \"right\" : \"left\",\n          middle: \"center\",\n          high: l ? \"left\" : \"right\"\n        })[d.align]), this.axisTitle = g.text(d.text || \"\", 0, 0, d.useHTML).attr({\n          zIndex: 7,\n          rotation: d.rotation,\n          align: u\n        }).addClass(\"highcharts-axis-title\"), f || this.axisTitle.css(e(d.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        f || d.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        });\n        this.axisTitle[a ? \"show\" : \"hide\"](a);\n      };\n\n      u.prototype.generateTick = function (a) {\n        var g = this.ticks;\n        g[a] ? g[a].addLabel() : g[a] = new F(this, a);\n      };\n\n      u.prototype.getOffset = function () {\n        var a = this,\n            e = this,\n            b = e.chart,\n            d = e.horiz,\n            f = e.options,\n            u = e.side,\n            r = e.ticks,\n            k = e.tickPositions,\n            z = e.coll,\n            x = e.axisParent,\n            w = b.renderer,\n            m = b.inverted && !e.isZAxis ? [1, 0, 3, 2][u] : u,\n            G = e.hasData(),\n            c = f.title,\n            L = f.labels,\n            n = b.axisOffset;\n        b = b.clipOffset;\n        var p = [-1, 1, 1, -1][u],\n            h = f.className,\n            t,\n            H = 0,\n            Q = 0,\n            K = 0;\n        e.showAxis = t = G || f.showEmpty;\n        e.staggerLines = e.horiz && L.staggerLines || void 0;\n\n        if (!e.axisGroup) {\n          var S = function (e, g, b) {\n            return w.g(e).attr({\n              zIndex: b\n            }).addClass(\"highcharts-\".concat(z.toLowerCase()).concat(g, \" \") + (a.isRadial ? \"highcharts-radial-axis\".concat(g, \" \") : \"\") + (h || \"\")).add(x);\n          };\n\n          e.gridGroup = S(\"grid\", \"-grid\", f.gridZIndex);\n          e.axisGroup = S(\"axis\", \"\", f.zIndex);\n          e.labelGroup = S(\"axis-labels\", \"-labels\", L.zIndex);\n        }\n\n        G || e.isLinked ? (k.forEach(function (a) {\n          e.generateTick(a);\n        }), e.renderUnsquish(), e.reserveSpaceDefault = 0 === u || 2 === u || {\n          1: \"left\",\n          3: \"right\"\n        }[u] === e.labelAlign, g(L.reserveSpace, \"center\" === e.labelAlign ? !0 : null, e.reserveSpaceDefault) && k.forEach(function (a) {\n          K = Math.max(r[a].getLabelSize(), K);\n        }), e.staggerLines && (K *= e.staggerLines), e.labelOffset = K * (e.opposite ? -1 : 1)) : l(r, function (a, e) {\n          a.destroy();\n          delete r[e];\n        });\n\n        if (c && c.text && !1 !== c.enabled && (e.addTitle(t), t && !1 !== c.reserveSpace)) {\n          e.titleOffset = H = e.axisTitle.getBBox()[d ? \"height\" : \"width\"];\n          var M = c.offset;\n          Q = v(M) ? 0 : g(c.margin, d ? 5 : 10);\n        }\n\n        e.renderLine();\n        e.offset = p * g(f.offset, n[u] ? n[u] + (f.margin || 0) : 0);\n        e.tickRotCorr = e.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        c = 0 === u ? -e.labelMetrics().h : 2 === u ? e.tickRotCorr.y : 0;\n        G = Math.abs(K) + Q;\n        K && (G = G - c + p * (d ? g(L.y, e.tickRotCorr.y + 8 * p) : L.x));\n        e.axisTitleMargin = g(M, G);\n        e.getMaxLabelDimensions && (e.maxLabelDimensions = e.getMaxLabelDimensions(r, k));\n        \"colorAxis\" !== z && (d = this.tickSize(\"tick\"), n[u] = Math.max(n[u], (e.axisTitleMargin || 0) + H + p * e.offset, G, k && k.length && d ? d[0] + p * e.offset : 0), f = !e.axisLine || f.offset ? 0 : 2 * Math.floor(e.axisLine.strokeWidth() / 2), b[m] = Math.max(b[m], f));\n        q(this, \"afterGetOffset\");\n      };\n\n      u.prototype.getLinePath = function (a) {\n        var e = this.chart,\n            g = this.opposite,\n            b = this.offset,\n            l = this.horiz,\n            d = this.left + (g ? this.width : 0) + b;\n        b = e.chartHeight - this.bottom - (g ? this.height : 0) + b;\n        g && (a *= -1);\n        return e.renderer.crispLine([[\"M\", l ? this.left : d, l ? b : this.top], [\"L\", l ? e.chartWidth - this.right : d, l ? b : e.chartHeight - this.bottom]], a);\n      };\n\n      u.prototype.renderLine = function () {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      };\n\n      u.prototype.getTitlePosition = function () {\n        var a = this.horiz,\n            e = this.left,\n            g = this.top,\n            b = this.len,\n            l = this.options.title,\n            d = a ? e : g,\n            f = this.opposite,\n            u = this.offset,\n            r = l.x,\n            k = l.y,\n            z = this.axisTitle,\n            x = this.chart.renderer.fontMetrics(l.style.fontSize, z);\n        z = z ? Math.max(z.getBBox(!1, 0).height - x.h - 1, 0) : 0;\n        b = {\n          low: d + (a ? 0 : b),\n          middle: d + b / 2,\n          high: d + (a ? b : 0)\n        }[l.align];\n        e = (a ? g + this.height : e) + (a ? 1 : -1) * (f ? -1 : 1) * (this.axisTitleMargin || 0) + [-z, z, x.f, -z][this.side];\n        a = {\n          x: a ? b + r : e + (f ? this.width : 0) + u + r,\n          y: a ? e + k - (f ? this.height : 0) + u : b + k\n        };\n        q(this, \"afterGetTitlePosition\", {\n          titlePosition: a\n        });\n        return a;\n      };\n\n      u.prototype.renderMinorTick = function (a, e) {\n        var g = this.minorTicks;\n        g[a] || (g[a] = new F(this, a, \"minor\"));\n        e && g[a].isNew && g[a].render(null, !0);\n        g[a].render(null, !1, 1);\n      };\n\n      u.prototype.renderTick = function (a, e, g) {\n        var b = this.ticks;\n        if (!this.isLinked || a >= this.min && a <= this.max || this.grid && this.grid.isColumn) b[a] || (b[a] = new F(this, a)), g && b[a].isNew && b[a].render(e, !0, -1), b[a].render(e);\n      };\n\n      u.prototype.render = function () {\n        var e = this,\n            g = e.chart,\n            b = e.logarithmic,\n            d = e.options,\n            f = e.isLinked,\n            u = e.tickPositions,\n            r = e.axisTitle,\n            k = e.ticks,\n            z = e.minorTicks,\n            x = e.alternateBands,\n            w = d.stackLabels,\n            m = d.alternateGridColor,\n            G = e.tickmarkOffset,\n            c = e.axisLine,\n            n = e.showAxis,\n            v = p(g.renderer.globalAnimation),\n            h,\n            t;\n        e.labelEdge.length = 0;\n        e.overlap = !1;\n        [k, z, x].forEach(function (a) {\n          l(a, function (a) {\n            a.isActive = !1;\n          });\n        });\n\n        if (e.hasData() || f) {\n          var H = e.chart.hasRendered && e.old && a(e.old.min);\n          e.minorTickInterval && !e.categories && e.getMinorTickPositions().forEach(function (a) {\n            e.renderMinorTick(a, H);\n          });\n          u.length && (u.forEach(function (a, g) {\n            e.renderTick(a, g, H);\n          }), G && (0 === e.min || e.single) && (k[-1] || (k[-1] = new F(e, -1, null, !0)), k[-1].render(-1)));\n          m && u.forEach(function (a, l) {\n            t = \"undefined\" !== typeof u[l + 1] ? u[l + 1] + G : e.max - G;\n            0 === l % 2 && a < e.max && t <= e.max + (g.polar ? -G : G) && (x[a] || (x[a] = new D.PlotLineOrBand(e)), h = a + G, x[a].options = {\n              from: b ? b.lin2log(h) : h,\n              to: b ? b.lin2log(t) : t,\n              color: m,\n              className: \"highcharts-alternate-grid\"\n            }, x[a].render(), x[a].isActive = !0);\n          });\n          e._addedPlotLB || (e._addedPlotLB = !0, (d.plotLines || []).concat(d.plotBands || []).forEach(function (a) {\n            e.addPlotBandOrLine(a);\n          }));\n        }\n\n        [k, z, x].forEach(function (a) {\n          var e = [],\n              b = v.duration;\n          l(a, function (a, g) {\n            a.isActive || (a.render(g, !1, 0), a.isActive = !1, e.push(g));\n          });\n          L(function () {\n            for (var g = e.length; g--;) a[e[g]] && !a[e[g]].isActive && (a[e[g]].destroy(), delete a[e[g]]);\n          }, a !== x && g.hasRendered && b ? b : 0);\n        });\n        c && (c[c.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(c.strokeWidth())\n        }), c.isPlaced = !0, c[n ? \"show\" : \"hide\"](n));\n        r && n && (d = e.getTitlePosition(), r[r.isNew ? \"attr\" : \"animate\"](d), r.isNew = !1);\n        w && w.enabled && e.stacking && e.stacking.renderStackTotals();\n        e.old = {\n          len: e.len,\n          max: e.max,\n          min: e.min,\n          transA: e.transA,\n          userMax: e.userMax,\n          userMin: e.userMin\n        };\n        e.isDirty = !1;\n        q(this, \"afterRender\");\n      };\n\n      u.prototype.redraw = function () {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {\n          a.render();\n        }));\n        this.series.forEach(function (a) {\n          a.isDirty = !0;\n        });\n      };\n\n      u.prototype.getKeepProps = function () {\n        return this.keepProps || u.keepProps;\n      };\n\n      u.prototype.destroy = function (a) {\n        var e = this,\n            g = e.plotLinesAndBands,\n            b = this.eventOptions;\n        q(this, \"destroy\", {\n          keepEvents: a\n        });\n        a || z(e);\n        [e.ticks, e.minorTicks, e.alternateBands].forEach(function (a) {\n          K(a);\n        });\n        if (g) for (a = g.length; a--;) g[a].destroy();\n        \"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (a) {\n          e[a] && (e[a] = e[a].destroy());\n        });\n\n        for (var d in e.plotLinesAndBandsGroups) e.plotLinesAndBandsGroups[d] = e.plotLinesAndBandsGroups[d].destroy();\n\n        l(e, function (a, g) {\n          -1 === e.getKeepProps().indexOf(g) && delete e[g];\n        });\n        this.eventOptions = b;\n      };\n\n      u.prototype.drawCrosshair = function (a, e) {\n        var b = this.crosshair,\n            l = g(b && b.snap, !0),\n            d = this.chart,\n            f,\n            u = this.cross;\n        q(this, \"drawCrosshair\", {\n          e: a,\n          point: e\n        });\n        a || (a = this.cross && this.cross.e);\n\n        if (b && !1 !== (v(e) || !l)) {\n          l ? v(e) && (f = g(\"colorAxis\" !== this.coll ? e.crosshairPos : null, this.isXAxis ? e.plotX : this.len - e.plotY)) : f = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);\n\n          if (v(f)) {\n            var r = {\n              value: e && (this.isXAxis ? e.x : g(e.stackY, e.y)),\n              translatedValue: f\n            };\n            d.polar && H(r, {\n              isCrosshair: !0,\n              chartX: a && a.chartX,\n              chartY: a && a.chartY,\n              point: e\n            });\n            r = this.getPlotLinePath(r) || null;\n          }\n\n          if (!v(r)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          l = this.categories && !this.isRadial;\n          u || (this.cross = u = d.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (l ? \"category \" : \"thin \") + (b.className || \"\")).attr({\n            zIndex: g(b.zIndex, 2)\n          }).add(), d.styledMode || (u.attr({\n            stroke: b.color || (l ? B.parse(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": g(b.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), b.dashStyle && u.attr({\n            dashstyle: b.dashStyle\n          })));\n          u.show().attr({\n            d: r\n          });\n          l && !b.width && u.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = a;\n        } else this.hideCrosshair();\n\n        q(this, \"afterDrawCrosshair\", {\n          e: a,\n          point: e\n        });\n      };\n\n      u.prototype.hideCrosshair = function () {\n        this.cross && this.cross.hide();\n        q(this, \"afterHideCrosshair\");\n      };\n\n      u.prototype.hasVerticalPanning = function () {\n        var a = this.chart.options.chart.panning;\n        return !!(a && a.enabled && /y/.test(a.type));\n      };\n\n      u.prototype.validatePositiveValue = function (e) {\n        return a(e) && 0 < e;\n      };\n\n      u.prototype.update = function (a, b) {\n        var l = this.chart;\n        a = e(this.userOptions, a);\n        this.destroy(!0);\n        this.init(l, a);\n        l.isDirtyBox = !0;\n        g(b, !0) && l.redraw();\n      };\n\n      u.prototype.remove = function (a) {\n        for (var e = this.chart, b = this.coll, l = this.series, d = l.length; d--;) l[d] && l[d].remove(!1);\n\n        M(e.axes, this);\n        M(e[b], this);\n        e[b].forEach(function (a, e) {\n          a.options.index = a.userOptions.index = e;\n        });\n        this.destroy();\n        e.isDirtyBox = !0;\n        g(a, !0) && e.redraw();\n      };\n\n      u.prototype.setTitle = function (a, e) {\n        this.update({\n          title: a\n        }, e);\n      };\n\n      u.prototype.setCategories = function (a, e) {\n        this.update({\n          categories: a\n        }, e);\n      };\n\n      u.defaultOptions = h.defaultXAxisOptions;\n      u.keepProps = \"extKey hcEvents names series userMax userMin\".split(\" \");\n      return u;\n    }();\n\n    \"\";\n    return c;\n  });\n  O(h, \"Core/Axis/DateTimeAxis.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    var h = c.addEvent,\n        B = c.getMagnitude,\n        E = c.normalizeTickInterval,\n        A = c.timeUnits,\n        D;\n\n    (function (c) {\n      function y() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n      }\n\n      function p(k) {\n        \"datetime\" !== k.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new b(this));\n      }\n\n      var t = [];\n\n      c.compose = function (b) {\n        -1 === t.indexOf(b) && (t.push(b), b.keepProps.push(\"dateTime\"), b.prototype.getTimeTicks = y, h(b, \"init\", p));\n        return b;\n      };\n\n      var b = function () {\n        function b(b) {\n          this.axis = b;\n        }\n\n        b.prototype.normalizeTimeTickInterval = function (b, k) {\n          var f = k || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n          k = f[f.length - 1];\n          var d = A[k[0]],\n              m = k[1],\n              c;\n\n          for (c = 0; c < f.length && !(k = f[c], d = A[k[0]], m = k[1], f[c + 1] && b <= (d * m[m.length - 1] + A[f[c + 1][0]]) / 2); c++);\n\n          d === A.year && b < 5 * d && (m = [1, 2, 5]);\n          b = E(b / d, m, \"year\" === k[0] ? Math.max(B(b / d), 1) : 1);\n          return {\n            unitRange: d,\n            count: b,\n            unitName: k[0]\n          };\n        };\n\n        b.prototype.getXDateFormat = function (b, k) {\n          var f = this.axis,\n              d = f.chart.time;\n          return f.closestPointRange ? d.getDateFormat(f.closestPointRange, b, f.options.startOfWeek, k) || d.resolveDTLFormat(k.year).main : d.resolveDTLFormat(k.day).main;\n        };\n\n        return b;\n      }();\n\n      c.Additions = b;\n    })(D || (D = {}));\n\n    return D;\n  });\n  O(h, \"Core/Axis/LogarithmicAxis.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    var h = c.addEvent,\n        B = c.normalizeTickInterval,\n        E = c.pick,\n        A;\n\n    (function (c) {\n      function F(b) {\n        var k = this.logarithmic;\n        \"logarithmic\" !== b.userOptions.type ? this.logarithmic = void 0 : k || (this.logarithmic = new t(this));\n      }\n\n      function y() {\n        var b = this.logarithmic;\n        b && (this.lin2val = function (k) {\n          return b.lin2log(k);\n        }, this.val2lin = function (k) {\n          return b.log2lin(k);\n        });\n      }\n\n      var p = [];\n\n      c.compose = function (b) {\n        -1 === p.indexOf(b) && (p.push(b), b.keepProps.push(\"logarithmic\"), h(b, \"init\", F), h(b, \"afterInit\", y));\n        return b;\n      };\n\n      var t = function () {\n        function b(b) {\n          this.axis = b;\n        }\n\n        b.prototype.getLogTickPositions = function (b, c, m, f) {\n          var d = this.axis,\n              k = d.len,\n              n = d.options,\n              p = [];\n          f || (this.minorAutoInterval = void 0);\n          if (.5 <= b) b = Math.round(b), p = d.getLinearTickPositions(b, c, m);else if (.08 <= b) {\n            var h = Math.floor(c),\n                t,\n                q = n = void 0;\n\n            for (k = .3 < b ? [1, 2, 4] : .15 < b ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; h < m + 1 && !q; h++) {\n              var w = k.length;\n\n              for (t = 0; t < w && !q; t++) {\n                var a = this.log2lin(this.lin2log(h) * k[t]);\n                a > c && (!f || n <= m) && \"undefined\" !== typeof n && p.push(n);\n                n > m && (q = !0);\n                n = a;\n              }\n            }\n          } else c = this.lin2log(c), m = this.lin2log(m), b = f ? d.getMinorTickInterval() : n.tickInterval, b = E(\"auto\" === b ? null : b, this.minorAutoInterval, n.tickPixelInterval / (f ? 5 : 1) * (m - c) / ((f ? k / d.tickPositions.length : k) || 1)), b = B(b), p = d.getLinearTickPositions(b, c, m).map(this.log2lin), f || (this.minorAutoInterval = b / 5);\n          f || (d.tickInterval = b);\n          return p;\n        };\n\n        b.prototype.lin2log = function (b) {\n          return Math.pow(10, b);\n        };\n\n        b.prototype.log2lin = function (b) {\n          return Math.log(b) / Math.LN10;\n        };\n\n        return b;\n      }();\n\n      c.Additions = t;\n    })(A || (A = {}));\n\n    return A;\n  });\n  O(h, \"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    var h = c.erase,\n        B = c.extend,\n        E = c.isNumber,\n        A;\n\n    (function (c) {\n      var F = [],\n          y;\n\n      c.compose = function (c, b) {\n        y || (y = c);\n        -1 === F.indexOf(b) && (F.push(b), B(b.prototype, p.prototype));\n        return b;\n      };\n\n      var p = function () {\n        function c() {}\n\n        c.prototype.getPlotBandPath = function (b, k, c) {\n          void 0 === c && (c = this.options);\n          var m = this.getPlotLinePath({\n            value: k,\n            force: !0,\n            acrossPanes: c.acrossPanes\n          }),\n              f = [],\n              d = this.horiz;\n          k = !E(this.min) || !E(this.max) || b < this.min && k < this.min || b > this.max && k > this.max;\n          b = this.getPlotLinePath({\n            value: b,\n            force: !0,\n            acrossPanes: c.acrossPanes\n          });\n          c = 1;\n\n          if (b && m) {\n            if (k) {\n              var n = b.toString() === m.toString();\n              c = 0;\n            }\n\n            for (k = 0; k < b.length; k += 2) {\n              var p = b[k],\n                  h = b[k + 1],\n                  t = m[k],\n                  H = m[k + 1];\n              \"M\" !== p[0] && \"L\" !== p[0] || \"M\" !== h[0] && \"L\" !== h[0] || \"M\" !== t[0] && \"L\" !== t[0] || \"M\" !== H[0] && \"L\" !== H[0] || (d && t[1] === p[1] ? (t[1] += c, H[1] += c) : d || t[2] !== p[2] || (t[2] += c, H[2] += c), f.push([\"M\", p[1], p[2]], [\"L\", h[1], h[2]], [\"L\", H[1], H[2]], [\"L\", t[1], t[2]], [\"Z\"]));\n              f.isFlat = n;\n            }\n          }\n\n          return f;\n        };\n\n        c.prototype.addPlotBand = function (b) {\n          return this.addPlotBandOrLine(b, \"plotBands\");\n        };\n\n        c.prototype.addPlotLine = function (b) {\n          return this.addPlotBandOrLine(b, \"plotLines\");\n        };\n\n        c.prototype.addPlotBandOrLine = function (b, k) {\n          var c = this,\n              m = this.userOptions,\n              f = new y(this, b);\n          this.visible && (f = f.render());\n\n          if (f) {\n            this._addedPlotLB || (this._addedPlotLB = !0, (m.plotLines || []).concat(m.plotBands || []).forEach(function (b) {\n              c.addPlotBandOrLine(b);\n            }));\n\n            if (k) {\n              var d = m[k] || [];\n              d.push(b);\n              m[k] = d;\n            }\n\n            this.plotLinesAndBands.push(f);\n          }\n\n          return f;\n        };\n\n        c.prototype.removePlotBandOrLine = function (b) {\n          var k = this.plotLinesAndBands,\n              c = this.options,\n              m = this.userOptions;\n\n          if (k) {\n            for (var f = k.length; f--;) k[f].id === b && k[f].destroy();\n\n            [c.plotLines || [], m.plotLines || [], c.plotBands || [], m.plotBands || []].forEach(function (d) {\n              for (f = d.length; f--;) (d[f] || {}).id === b && h(d, d[f]);\n            });\n          }\n        };\n\n        c.prototype.removePlotBand = function (b) {\n          this.removePlotBandOrLine(b);\n        };\n\n        c.prototype.removePlotLine = function (b) {\n          this.removePlotBandOrLine(b);\n        };\n\n        return c;\n      }();\n    })(A || (A = {}));\n\n    return A;\n  });\n  O(h, \"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\", [h[\"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    var I = h.arrayMax,\n        E = h.arrayMin,\n        A = h.defined,\n        D = h.destroyObjectProperties,\n        F = h.erase,\n        y = h.fireEvent,\n        p = h.merge,\n        t = h.objectEach,\n        b = h.pick;\n\n    h = function () {\n      function k(b, k) {\n        this.axis = b;\n        k && (this.options = k, this.id = k.id);\n      }\n\n      k.compose = function (b) {\n        return c.compose(k, b);\n      };\n\n      k.prototype.render = function () {\n        y(this, \"render\");\n        var k = this,\n            c = k.axis,\n            f = c.horiz,\n            d = c.logarithmic,\n            v = k.options,\n            h = v.color,\n            M = b(v.zIndex, 0),\n            N = v.events,\n            H = {},\n            q = c.chart.renderer,\n            w = v.label,\n            a = k.label,\n            x = v.to,\n            e = v.from,\n            u = v.value,\n            l = k.svgElem,\n            g = [],\n            G = A(e) && A(x);\n        g = A(u);\n        var z = !l,\n            r = {\n          \"class\": \"highcharts-plot-\" + (G ? \"band \" : \"line \") + (v.className || \"\")\n        },\n            L = G ? \"bands\" : \"lines\";\n        d && (e = d.log2lin(e), x = d.log2lin(x), u = d.log2lin(u));\n        c.chart.styledMode || (g ? (r.stroke = h || \"#999999\", r[\"stroke-width\"] = b(v.width, 1), v.dashStyle && (r.dashstyle = v.dashStyle)) : G && (r.fill = h || \"#e6ebf5\", v.borderWidth && (r.stroke = v.borderColor, r[\"stroke-width\"] = v.borderWidth)));\n        H.zIndex = M;\n        L += \"-\" + M;\n        (d = c.plotLinesAndBandsGroups[L]) || (c.plotLinesAndBandsGroups[L] = d = q.g(\"plot-\" + L).attr(H).add());\n        z && (k.svgElem = l = q.path().attr(r).add(d));\n        if (g) g = c.getPlotLinePath({\n          value: u,\n          lineWidth: l.strokeWidth(),\n          acrossPanes: v.acrossPanes\n        });else if (G) g = c.getPlotBandPath(e, x, v);else return;\n        !k.eventsAdded && N && (t(N, function (a, e) {\n          l.on(e, function (a) {\n            N[e].apply(k, [a]);\n          });\n        }), k.eventsAdded = !0);\n        (z || !l.d) && g && g.length ? l.attr({\n          d: g\n        }) : l && (g ? (l.show(), l.animate({\n          d: g\n        })) : l.d && (l.hide(), a && (k.label = a = a.destroy())));\n        w && (A(w.text) || A(w.formatter)) && g && g.length && 0 < c.width && 0 < c.height && !g.isFlat ? (w = p({\n          align: f && G && \"center\",\n          x: f ? !G && 4 : 10,\n          verticalAlign: !f && G && \"middle\",\n          y: f ? G ? 16 : 10 : G ? 6 : -4,\n          rotation: f && !G && 90\n        }, w), this.renderLabel(w, g, G, M)) : a && a.hide();\n        return k;\n      };\n\n      k.prototype.renderLabel = function (b, k, f, d) {\n        var c = this.axis,\n            m = c.chart.renderer,\n            n = this.label;\n        n || (this.label = n = m.text(this.getLabelText(b), 0, 0, b.useHTML).attr({\n          align: b.textAlign || b.align,\n          rotation: b.rotation,\n          \"class\": \"highcharts-plot-\" + (f ? \"band\" : \"line\") + \"-label \" + (b.className || \"\"),\n          zIndex: d\n        }).add(), c.chart.styledMode || n.css(p({\n          textOverflow: \"ellipsis\"\n        }, b.style)));\n        d = k.xBounds || [k[0][1], k[1][1], f ? k[2][1] : k[0][1]];\n        k = k.yBounds || [k[0][2], k[1][2], f ? k[2][2] : k[0][2]];\n        f = E(d);\n        m = E(k);\n        n.align(b, !1, {\n          x: f,\n          y: m,\n          width: I(d) - f,\n          height: I(k) - m\n        });\n        n.alignValue && \"left\" !== n.alignValue || n.css({\n          width: (90 === n.rotation ? c.height - (n.alignAttr.y - c.top) : c.width - (n.alignAttr.x - c.left)) + \"px\"\n        });\n        n.show(!0);\n      };\n\n      k.prototype.getLabelText = function (b) {\n        return A(b.formatter) ? b.formatter.call(this) : b.text;\n      };\n\n      k.prototype.destroy = function () {\n        F(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        D(this);\n      };\n\n      return k;\n    }();\n\n    \"\";\n    \"\";\n    return h;\n  });\n  O(h, \"Core/Tooltip.js\", [h[\"Core/FormatUtilities.js\"], h[\"Core/Globals.js\"], h[\"Core/Renderer/RendererUtilities.js\"], h[\"Core/Renderer/RendererRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A) {\n    var D = c.format,\n        F = h.doc,\n        y = B.distribute,\n        p = A.addEvent,\n        t = A.clamp,\n        b = A.css,\n        k = A.defined,\n        n = A.discardElement,\n        m = A.extend,\n        f = A.fireEvent,\n        d = A.isArray,\n        v = A.isNumber,\n        K = A.isString,\n        M = A.merge,\n        N = A.pick,\n        H = A.splat,\n        q = A.syncTimeout;\n\n    c = function () {\n      function c(a, b) {\n        this.allowShared = !0;\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.chart = a;\n        this.init(a, b);\n      }\n\n      c.prototype.applyFilter = function () {\n        var a = this.chart;\n        a.renderer.definition({\n          tagName: \"filter\",\n          attributes: {\n            id: \"drop-shadow-\" + a.index,\n            opacity: .5\n          },\n          children: [{\n            tagName: \"feGaussianBlur\",\n            attributes: {\n              \"in\": \"SourceAlpha\",\n              stdDeviation: 1\n            }\n          }, {\n            tagName: \"feOffset\",\n            attributes: {\n              dx: 1,\n              dy: 1\n            }\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              attributes: {\n                type: \"linear\",\n                slope: .3\n              }\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              attributes: {\n                \"in\": \"SourceGraphic\"\n              }\n            }]\n          }]\n        });\n      };\n\n      c.prototype.bodyFormatter = function (a) {\n        return a.map(function (a) {\n          var e = a.series.tooltipOptions;\n          return (e[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, e[(a.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      };\n\n      c.prototype.cleanSplit = function (a) {\n        this.chart.series.forEach(function (b) {\n          var e = b && b.tt;\n          e && (!e.isActive || a ? b.tt = e.destroy() : e.isActive = !1);\n        });\n      };\n\n      c.prototype.defaultFormatter = function (a) {\n        var b = this.points || H(this);\n        var e = [a.tooltipFooterHeaderFormatter(b[0])];\n        e = e.concat(a.bodyFormatter(b));\n        e.push(a.tooltipFooterHeaderFormatter(b[0], !0));\n        return e;\n      };\n\n      c.prototype.destroy = function () {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), n(this.container));\n        A.clearTimeout(this.hideTimer);\n        A.clearTimeout(this.tooltipTimeout);\n      };\n\n      c.prototype.getAnchor = function (a, b) {\n        var e = this.chart,\n            d = e.pointer,\n            l = e.inverted,\n            g = e.plotTop,\n            f = e.plotLeft,\n            k,\n            r,\n            c = 0,\n            q = 0;\n        a = H(a);\n        this.followPointer && b ? (\"undefined\" === typeof b.chartX && (b = d.normalize(b)), d = [b.chartX - f, b.chartY - g]) : a[0].tooltipPos ? d = a[0].tooltipPos : (a.forEach(function (a) {\n          k = a.series.yAxis;\n          r = a.series.xAxis;\n          c += a.plotX || 0;\n          q += a.plotLow ? (a.plotLow + (a.plotHigh || 0)) / 2 : a.plotY || 0;\n          r && k && (l ? (c += g + e.plotHeight - r.len - r.pos, q += f + e.plotWidth - k.len - k.pos) : (c += r.pos - f, q += k.pos - g));\n        }), c /= a.length, q /= a.length, d = [l ? e.plotWidth - q : c, l ? e.plotHeight - c : q], this.shared && 1 < a.length && b && (l ? d[0] = b.chartX - f : d[1] = b.chartY - g));\n        return d.map(Math.round);\n      };\n\n      c.prototype.getLabel = function () {\n        var a = this,\n            d = this.chart.styledMode,\n            e = this.options,\n            f = this.split && this.allowShared,\n            l = \"tooltip\" + (k(e.className) ? \" \" + e.className : \"\"),\n            g = e.style.pointerEvents || (!this.followPointer && e.stickOnContact ? \"auto\" : \"none\"),\n            c = function () {\n          a.inContact = !0;\n        },\n            q = function (e) {\n          var g = a.chart.hoverSeries;\n          a.inContact = a.shouldStickOnContact() && a.chart.pointer.inClass(e.relatedTarget, \"highcharts-tooltip\");\n          if (!a.inContact && g && g.onMouseOut) g.onMouseOut();\n        },\n            r,\n            w = this.chart.renderer;\n\n        if (a.label) {\n          var m = !a.label.hasClass(\"highcharts-label\");\n          (f && !m || !f && m) && a.destroy();\n        }\n\n        if (!this.label) {\n          if (this.outside) {\n            m = this.chart.options.chart.style;\n            var n = E.getRendererType();\n            this.container = r = h.doc.createElement(\"div\");\n            r.className = \"highcharts-tooltip-container\";\n            b(r, {\n              position: \"absolute\",\n              top: \"1px\",\n              pointerEvents: g,\n              zIndex: Math.max(this.options.style.zIndex || 0, (m && m.zIndex || 0) + 3)\n            });\n            p(r, \"mouseenter\", c);\n            p(r, \"mouseleave\", q);\n            h.doc.body.appendChild(r);\n            this.renderer = w = new n(r, 0, 0, m, void 0, void 0, w.styledMode);\n          }\n\n          f ? this.label = w.g(l) : (this.label = w.label(\"\", 0, 0, e.shape, void 0, void 0, e.useHTML, void 0, l).attr({\n            padding: e.padding,\n            r: e.borderRadius\n          }), d || this.label.attr({\n            fill: e.backgroundColor,\n            \"stroke-width\": e.borderWidth\n          }).css(e.style).css({\n            pointerEvents: g\n          }).shadow(e.shadow));\n          d && e.shadow && (this.applyFilter(), this.label.attr({\n            filter: \"url(#drop-shadow-\" + this.chart.index + \")\"\n          }));\n\n          if (a.outside && !a.split) {\n            var C = this.label,\n                v = C.xSetter,\n                t = C.ySetter;\n\n            C.xSetter = function (e) {\n              v.call(C, a.distance);\n              r.style.left = e + \"px\";\n            };\n\n            C.ySetter = function (e) {\n              t.call(C, a.distance);\n              r.style.top = e + \"px\";\n            };\n          }\n\n          this.label.on(\"mouseenter\", c).on(\"mouseleave\", q).attr({\n            zIndex: 8\n          }).add();\n        }\n\n        return this.label;\n      };\n\n      c.prototype.getPosition = function (a, b, e) {\n        var d = this.chart,\n            l = this.distance,\n            g = {},\n            f = d.inverted && e.h || 0,\n            k = this.outside,\n            r = k ? F.documentElement.clientWidth - 2 * l : d.chartWidth,\n            c = k ? Math.max(F.body.scrollHeight, F.documentElement.scrollHeight, F.body.offsetHeight, F.documentElement.offsetHeight, F.documentElement.clientHeight) : d.chartHeight,\n            q = d.pointer.getChartPosition(),\n            x = function (g) {\n          var f = \"x\" === g;\n          return [g, f ? r : c, f ? a : b].concat(k ? [f ? a * q.scaleX : b * q.scaleY, f ? q.left - l + (e.plotX + d.plotLeft) * q.scaleX : q.top - l + (e.plotY + d.plotTop) * q.scaleY, 0, f ? r : c] : [f ? a : b, f ? e.plotX + d.plotLeft : e.plotY + d.plotTop, f ? d.plotLeft : d.plotTop, f ? d.plotLeft + d.plotWidth : d.plotTop + d.plotHeight]);\n        },\n            w = x(\"y\"),\n            m = x(\"x\"),\n            n;\n\n        x = !!e.negative;\n        !d.polar && d.hoverSeries && d.hoverSeries.yAxis && d.hoverSeries.yAxis.reversed && (x = !x);\n\n        var v = !this.followPointer && N(e.ttBelow, !d.inverted === x),\n            p = function (a, e, b, d, r, u, c) {\n          var z = k ? \"y\" === a ? l * q.scaleY : l * q.scaleX : l,\n              x = (b - d) / 2,\n              w = d < r - l,\n              G = r + l + d < e,\n              m = r - z - b + x;\n          r = r + z - x;\n          if (v && G) g[a] = r;else if (!v && w) g[a] = m;else if (w) g[a] = Math.min(c - d, 0 > m - f ? m : m - f);else if (G) g[a] = Math.max(u, r + f + b > e ? r : r + f);else return !1;\n        },\n            h = function (a, e, b, d, f) {\n          var r;\n          f < l || f > e - l ? r = !1 : g[a] = f < b / 2 ? 1 : f > e - d / 2 ? e - d - 2 : f - b / 2;\n          return r;\n        },\n            P = function (a) {\n          var e = w;\n          w = m;\n          m = e;\n          n = a;\n        },\n            t = function () {\n          !1 !== p.apply(0, w) ? !1 !== h.apply(0, m) || n || (P(!0), t()) : n ? g.x = g.y = 0 : (P(!0), t());\n        };\n\n        (d.inverted || 1 < this.len) && P();\n        t();\n        return g;\n      };\n\n      c.prototype.hide = function (a) {\n        var b = this;\n        A.clearTimeout(this.hideTimer);\n        a = N(a, this.options.hideDelay);\n        this.isHidden || (this.hideTimer = q(function () {\n          b.getLabel().fadeOut(a ? void 0 : a);\n          b.isHidden = !0;\n        }, a));\n      };\n\n      c.prototype.init = function (a, b) {\n        this.chart = a;\n        this.options = b;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = b.split && !a.inverted && !a.polar;\n        this.shared = b.shared || this.split;\n        this.outside = N(b.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));\n      };\n\n      c.prototype.shouldStickOnContact = function () {\n        return !(this.followPointer || !this.options.stickOnContact);\n      };\n\n      c.prototype.isStickyOnContact = function () {\n        return !(!this.shouldStickOnContact() || !this.inContact);\n      };\n\n      c.prototype.move = function (a, b, e, d) {\n        var l = this,\n            g = l.now,\n            f = !1 !== l.options.animation && !l.isHidden && (1 < Math.abs(a - g.x) || 1 < Math.abs(b - g.y)),\n            u = l.followPointer || 1 < l.len;\n        m(g, {\n          x: f ? (2 * g.x + a) / 3 : a,\n          y: f ? (g.y + b) / 2 : b,\n          anchorX: u ? void 0 : f ? (2 * g.anchorX + e) / 3 : e,\n          anchorY: u ? void 0 : f ? (g.anchorY + d) / 2 : d\n        });\n        l.getLabel().attr(g);\n        l.drawTracker();\n        f && (A.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          l && l.move(a, b, e, d);\n        }, 32));\n      };\n\n      c.prototype.refresh = function (a, b) {\n        var e = this.chart,\n            u = this.options,\n            l = H(a),\n            g = l[0],\n            k = [],\n            c = u.formatter || this.defaultFormatter,\n            r = this.shared,\n            q = e.styledMode,\n            x = {};\n\n        if (u.enabled && g.series) {\n          A.clearTimeout(this.hideTimer);\n          this.allowShared = !(!d(a) && a.series && a.series.noSharedTooltip);\n          this.followPointer = !this.split && g.series.tooltipOptions.followPointer;\n          a = this.getAnchor(a, b);\n          var w = a[0],\n              m = a[1];\n          r && this.allowShared ? (e.pointer.applyInactiveState(l), l.forEach(function (a) {\n            a.setState(\"hover\");\n            k.push(a.getLabelConfig());\n          }), x = {\n            x: g.category,\n            y: g.y\n          }, x.points = k) : x = g.getLabelConfig();\n          this.len = k.length;\n          c = c.call(x, this);\n          r = g.series;\n          this.distance = N(r.tooltipOptions.distance, 16);\n          if (!1 === c) this.hide();else {\n            if (this.split && this.allowShared) this.renderSplit(c, l);else {\n              var n = w,\n                  v = m;\n              b && e.pointer.isDirectTouch && (n = b.chartX - e.plotLeft, v = b.chartY - e.plotTop);\n              if (e.polar || !1 === r.options.clip || l.some(function (a) {\n                return a.series.shouldShowTooltip(n, v);\n              })) b = this.getLabel(), u.style.width && !q || b.css({\n                width: this.chart.spacingBox.width + \"px\"\n              }), b.attr({\n                text: c && c.join ? c.join(\"\") : c\n              }), b.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + N(g.colorIndex, r.colorIndex)), q || b.attr({\n                stroke: u.borderColor || g.color || r.color || \"#666666\"\n              }), this.updatePosition({\n                plotX: w,\n                plotY: m,\n                negative: g.negative,\n                ttBelow: g.ttBelow,\n                h: a[2] || 0\n              });else {\n                this.hide();\n                return;\n              }\n            }\n            this.isHidden && this.label && this.label.attr({\n              opacity: 1\n            }).show();\n            this.isHidden = !1;\n          }\n          f(this, \"refresh\");\n        }\n      };\n\n      c.prototype.renderSplit = function (a, b) {\n        function e(a, e, g, b, l) {\n          void 0 === l && (l = !0);\n          g ? (e = D ? 0 : E, a = t(a - b / 2, R.left, R.right - b - (d.outside ? A : 0))) : (e -= I, a = l ? a - b - H : a + H, a = t(a, l ? a : R.left, R.right));\n          return {\n            x: a,\n            y: e\n          };\n        }\n\n        var d = this,\n            l = d.chart,\n            g = d.chart,\n            f = g.chartWidth,\n            k = g.chartHeight,\n            r = g.plotHeight,\n            c = g.plotLeft,\n            q = g.plotTop,\n            x = g.pointer,\n            w = g.scrollablePixelsY;\n        w = void 0 === w ? 0 : w;\n        var n = g.scrollablePixelsX,\n            v = g.scrollingContainer;\n        v = void 0 === v ? {\n          scrollLeft: 0,\n          scrollTop: 0\n        } : v;\n        var p = v.scrollLeft;\n        v = v.scrollTop;\n        var h = g.styledMode,\n            H = d.distance,\n            P = d.options,\n            W = d.options.positioner,\n            R = d.outside && \"number\" !== typeof n ? F.documentElement.getBoundingClientRect() : {\n          left: p,\n          right: p + f,\n          top: v,\n          bottom: v + k\n        },\n            M = d.getLabel(),\n            V = this.renderer || l.renderer,\n            D = !(!l.xAxis[0] || !l.xAxis[0].opposite);\n        l = x.getChartPosition();\n        var A = l.left;\n        l = l.top;\n        var I = q + v,\n            B = 0,\n            E = r - w;\n        K(a) && (a = [!1, a]);\n        a = a.slice(0, b.length + 1).reduce(function (a, g, l) {\n          if (!1 !== g && \"\" !== g) {\n            l = b[l - 1] || {\n              isHeader: !0,\n              plotX: b[0].plotX,\n              plotY: r,\n              series: {}\n            };\n            var f = l.isHeader,\n                u = f ? d : l.series;\n            g = g.toString();\n            var k = u.tt,\n                z = l.isHeader;\n            var x = l.series;\n            var w = \"highcharts-color-\" + N(l.colorIndex, x.colorIndex, \"none\");\n            k || (k = {\n              padding: P.padding,\n              r: P.borderRadius\n            }, h || (k.fill = P.backgroundColor, k[\"stroke-width\"] = P.borderWidth), k = V.label(\"\", 0, 0, P[z ? \"headerShape\" : \"shape\"], void 0, void 0, P.useHTML).addClass((z ? \"highcharts-tooltip-header \" : \"\") + \"highcharts-tooltip-box \" + w).attr(k).add(M));\n            k.isActive = !0;\n            k.attr({\n              text: g\n            });\n            h || k.css(P.style).shadow(P.shadow).attr({\n              stroke: P.borderColor || l.color || x.color || \"#333333\"\n            });\n            u = u.tt = k;\n            z = u.getBBox();\n            g = z.width + u.strokeWidth();\n            f && (B = z.height, E += B, D && (I -= B));\n            x = l.plotX;\n            x = void 0 === x ? 0 : x;\n            w = l.plotY;\n            w = void 0 === w ? 0 : w;\n            k = l.series;\n\n            if (l.isHeader) {\n              x = c + x;\n              var m = q + r / 2;\n            } else {\n              var G = k.xAxis,\n                  L = k.yAxis;\n              x = G.pos + t(x, -H, G.len + H);\n              k.shouldShowTooltip(0, L.pos - q + w, {\n                ignoreX: !0\n              }) && (m = L.pos + w);\n            }\n\n            x = t(x, R.left - H, R.right + H);\n            \"number\" === typeof m ? (z = z.height + 1, w = W ? W.call(d, g, z, l) : e(x, m, f, g), a.push({\n              align: W ? 0 : void 0,\n              anchorX: x,\n              anchorY: m,\n              boxWidth: g,\n              point: l,\n              rank: N(w.rank, f ? 1 : 0),\n              size: z,\n              target: w.y,\n              tt: u,\n              x: w.x\n            })) : u.isActive = !1;\n          }\n\n          return a;\n        }, []);\n        !W && a.some(function (a) {\n          var e = (d.outside ? A : 0) + a.anchorX;\n          return e < R.left && e + a.boxWidth < R.right ? !0 : e < A - R.left + a.boxWidth && R.right - e > e;\n        }) && (a = a.map(function (a) {\n          var g = e(a.anchorX, a.anchorY, a.point.isHeader, a.boxWidth, !1);\n          return m(a, {\n            target: g.y,\n            x: g.x\n          });\n        }));\n        d.cleanSplit();\n        y(a, E);\n        var O = A,\n            Z = A;\n        a.forEach(function (a) {\n          var e = a.x,\n              g = a.boxWidth;\n          a = a.isHeader;\n          a || (d.outside && A + e < O && (O = A + e), !a && d.outside && O + g > Z && (Z = A + e));\n        });\n        a.forEach(function (a) {\n          var e = a.x,\n              g = a.anchorX,\n              b = a.pos,\n              l = a.point.isHeader;\n          b = {\n            visibility: \"undefined\" === typeof b ? \"hidden\" : \"inherit\",\n            x: e,\n            y: b + I,\n            anchorX: g,\n            anchorY: a.anchorY\n          };\n\n          if (d.outside && e < g) {\n            var f = A - O;\n            0 < f && (l || (b.x = e + f, b.anchorX = g + f), l && (b.x = (Z - O) / 2, b.anchorX = g + f));\n          }\n\n          a.tt.attr(b);\n        });\n        a = d.container;\n        w = d.renderer;\n        d.outside && a && w && (g = M.getBBox(), w.setSize(g.width + g.x, g.height + g.y, !1), a.style.left = O + \"px\", a.style.top = l + \"px\");\n      };\n\n      c.prototype.drawTracker = function () {\n        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {\n          var a = this.chart,\n              b = this.label,\n              e = this.shared ? a.hoverPoints : a.hoverPoint;\n\n          if (b && e) {\n            var d = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n            e = this.getAnchor(e);\n            var l = b.getBBox();\n            e[0] += a.plotLeft - b.translateX;\n            e[1] += a.plotTop - b.translateY;\n            d.x = Math.min(0, e[0]);\n            d.y = Math.min(0, e[1]);\n            d.width = 0 > e[0] ? Math.max(Math.abs(e[0]), l.width - e[0]) : Math.max(Math.abs(e[0]), l.width);\n            d.height = 0 > e[1] ? Math.max(Math.abs(e[1]), l.height - Math.abs(e[1])) : Math.max(Math.abs(e[1]), l.height);\n            this.tracker ? this.tracker.attr(d) : (this.tracker = b.renderer.rect(d).addClass(\"highcharts-tracker\").add(b), a.styledMode || this.tracker.attr({\n              fill: \"rgba(0,0,0,0)\"\n            }));\n          }\n        }\n      };\n\n      c.prototype.styledModeFormat = function (a) {\n        return a.replace('style=\"font-size: 10px\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex}\"');\n      };\n\n      c.prototype.tooltipFooterHeaderFormatter = function (a, b) {\n        var e = a.series,\n            d = e.tooltipOptions,\n            l = e.xAxis,\n            g = l && l.dateTime;\n        l = {\n          isFooter: b,\n          labelConfig: a\n        };\n        var k = d.xDateFormat,\n            c = d[b ? \"footerFormat\" : \"headerFormat\"];\n        f(this, \"headerFormatter\", l, function (b) {\n          g && !k && v(a.key) && (k = g.getXDateFormat(a.key, d.dateTimeLabelFormats));\n          g && k && (a.point && a.point.tooltipDateKeys || [\"key\"]).forEach(function (a) {\n            c = c.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + k + \"}\");\n          });\n          e.chart.styledMode && (c = this.styledModeFormat(c));\n          b.text = D(c, {\n            point: a,\n            series: e\n          }, this.chart);\n        });\n        return l.text;\n      };\n\n      c.prototype.update = function (a) {\n        this.destroy();\n        M(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, M(!0, this.options, a));\n      };\n\n      c.prototype.updatePosition = function (a) {\n        var d = this.chart,\n            e = this.options,\n            f = d.pointer,\n            l = this.getLabel();\n        f = f.getChartPosition();\n        var g = (e.positioner || this.getPosition).call(this, l.width, l.height, a),\n            k = a.plotX + d.plotLeft;\n        a = a.plotY + d.plotTop;\n\n        if (this.outside) {\n          e = e.borderWidth + 2 * this.distance;\n          this.renderer.setSize(l.width + e, l.height + e, !1);\n          if (1 !== f.scaleX || 1 !== f.scaleY) b(this.container, {\n            transform: \"scale(\".concat(f.scaleX, \", \").concat(f.scaleY, \")\")\n          }), k *= f.scaleX, a *= f.scaleY;\n          k += f.left - g.x;\n          a += f.top - g.y;\n        }\n\n        this.move(Math.round(g.x), Math.round(g.y || 0), k, a);\n      };\n\n      return c;\n    }();\n\n    \"\";\n    return c;\n  });\n  O(h, \"Core/Series/Point.js\", [h[\"Core/Renderer/HTML/AST.js\"], h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A) {\n    var D = h.animObject,\n        F = B.defaultOptions,\n        y = E.format,\n        p = A.addEvent,\n        t = A.defined,\n        b = A.erase,\n        k = A.extend,\n        n = A.fireEvent,\n        m = A.getNestedProperty,\n        f = A.isArray,\n        d = A.isFunction,\n        v = A.isNumber,\n        K = A.isObject,\n        M = A.merge,\n        N = A.objectEach,\n        H = A.pick,\n        q = A.syncTimeout,\n        w = A.removeEvent,\n        a = A.uniqueKey;\n\n    h = function () {\n      function x() {\n        this.colorIndex = this.category = void 0;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.shapeArgs = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n\n      x.prototype.animateBeforeDestroy = function () {\n        var a = this,\n            b = {\n          x: a.startXPos,\n          opacity: 0\n        },\n            d = a.getGraphicalProps();\n        d.singular.forEach(function (e) {\n          a[e] = a[e].animate(\"dataLabel\" === e ? {\n            x: a[e].startXPos,\n            y: a[e].startYPos,\n            opacity: 0\n          } : b);\n        });\n        d.plural.forEach(function (e) {\n          a[e].forEach(function (e) {\n            e.element && e.animate(k({\n              x: a.startXPos\n            }, e.startYPos ? {\n              x: e.startXPos,\n              y: e.startYPos\n            } : {}));\n          });\n        });\n      };\n\n      x.prototype.applyOptions = function (a, b) {\n        var e = this.series,\n            g = e.options.pointValKey || e.pointValKey;\n        a = x.prototype.optionsToObject.call(this, a);\n        k(this, a);\n        this.options = this.options ? k(this.options, a) : a;\n        a.group && delete this.group;\n        a.dataLabels && delete this.dataLabels;\n        g && (this.y = x.prototype.getNestedProperty.call(this, g));\n        this.formatPrefix = (this.isNull = H(this.isValid && !this.isValid(), null === this.x || !v(this.y))) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && \"undefined\" === typeof b && e.xAxis && e.xAxis.hasNames && (this.x = e.xAxis.nameToX(this));\n        \"undefined\" === typeof this.x && e ? this.x = \"undefined\" === typeof b ? e.autoIncrement() : b : v(a.x) && e.options.relativeXValue && (this.x = e.autoIncrement(a.x));\n        return this;\n      };\n\n      x.prototype.destroy = function () {\n        function a() {\n          if (d.graphic || d.dataLabel || d.dataLabels) w(d), d.destroyElements();\n\n          for (r in d) d[r] = null;\n        }\n\n        var d = this,\n            l = d.series,\n            g = l.chart;\n        l = l.options.dataSorting;\n        var f = g.hoverPoints,\n            k = D(d.series.chart.renderer.globalAnimation),\n            r;\n        d.legendItem && g.legend.destroyItem(d);\n        f && (d.setState(), b(f, d), f.length || (g.hoverPoints = null));\n        if (d === g.hoverPoint) d.onMouseOut();\n        l && l.enabled ? (this.animateBeforeDestroy(), q(a, k.duration)) : a();\n        g.pointCount--;\n      };\n\n      x.prototype.destroyElements = function (a) {\n        var e = this;\n        a = e.getGraphicalProps(a);\n        a.singular.forEach(function (a) {\n          e[a] = e[a].destroy();\n        });\n        a.plural.forEach(function (a) {\n          e[a].forEach(function (a) {\n            a.element && a.destroy();\n          });\n          delete e[a];\n        });\n      };\n\n      x.prototype.firePointEvent = function (a, b, d) {\n        var e = this,\n            l = this.series.options;\n        (l.point.events[a] || e.options && e.options.events && e.options.events[a]) && e.importEvents();\n        \"click\" === a && l.allowPointSelect && (d = function (a) {\n          e.select && e.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        n(e, a, b, d);\n      };\n\n      x.prototype.getClassName = function () {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      };\n\n      x.prototype.getGraphicalProps = function (a) {\n        var e = this,\n            b = [],\n            g = {\n          singular: [],\n          plural: []\n        },\n            d;\n        a = a || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        a.graphic && b.push(\"graphic\", \"upperGraphic\", \"shadowGroup\");\n        a.dataLabel && b.push(\"dataLabel\", \"dataLabelPath\", \"dataLabelUpper\", \"connector\");\n\n        for (d = b.length; d--;) {\n          var f = b[d];\n          e[f] && g.singular.push(f);\n        }\n\n        [\"dataLabel\", \"connector\"].forEach(function (b) {\n          var d = b + \"s\";\n          a[b] && e[d] && g.plural.push(d);\n        });\n        return g;\n      };\n\n      x.prototype.getLabelConfig = function () {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      };\n\n      x.prototype.getNestedProperty = function (a) {\n        if (a) return 0 === a.indexOf(\"custom.\") ? m(a, this.options) : this[a];\n      };\n\n      x.prototype.getZone = function () {\n        var a = this.series,\n            b = a.zones;\n        a = a.zoneAxis || \"y\";\n        var d,\n            g = 0;\n\n        for (d = b[g]; this[a] >= d.value;) d = b[++g];\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = d && d.color && !this.options.color ? d.color : this.nonZonedColor;\n        return d;\n      };\n\n      x.prototype.hasNewShapeType = function () {\n        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n      };\n\n      x.prototype.init = function (e, b, d) {\n        this.series = e;\n        this.applyOptions(b, d);\n        this.id = t(this.id) ? this.id : a();\n        this.resolveColor();\n        e.chart.pointCount++;\n        n(this, \"afterInit\");\n        return this;\n      };\n\n      x.prototype.optionsToObject = function (a) {\n        var e = this.series,\n            b = e.options.keys,\n            g = b || e.pointArrayMap || [\"y\"],\n            d = g.length,\n            k = {},\n            r = 0,\n            c = 0;\n        if (v(a) || null === a) k[g[0]] = a;else if (f(a)) for (!b && a.length > d && (e = typeof a[0], \"string\" === e ? k.name = a[0] : \"number\" === e && (k.x = a[0]), r++); c < d;) b && \"undefined\" === typeof a[r] || (0 < g[c].indexOf(\".\") ? x.prototype.setNestedProperty(k, a[r], g[c]) : k[g[c]] = a[r]), r++, c++;else \"object\" === typeof a && (k = a, a.dataLabels && (e._hasPointLabels = !0), a.marker && (e._hasPointMarkers = !0));\n        return k;\n      };\n\n      x.prototype.resolveColor = function () {\n        var a = this.series,\n            b = a.chart.styledMode;\n        var d = a.chart.options.chart.colorCount;\n        delete this.nonZonedColor;\n\n        if (a.options.colorByPoint) {\n          if (!b) {\n            d = a.options.colors || a.chart.options.colors;\n            var g = d[a.colorCounter];\n            d = d.length;\n          }\n\n          b = a.colorCounter;\n          a.colorCounter++;\n          a.colorCounter === d && (a.colorCounter = 0);\n        } else b || (g = a.color), b = a.colorIndex;\n\n        this.colorIndex = H(this.options.colorIndex, b);\n        this.color = H(this.options.color, g);\n      };\n\n      x.prototype.setNestedProperty = function (a, b, d) {\n        d.split(\".\").reduce(function (a, e, d, l) {\n          a[e] = l.length - 1 === d ? b : K(a[e], !0) ? a[e] : {};\n          return a[e];\n        }, a);\n        return a;\n      };\n\n      x.prototype.tooltipFormatter = function (a) {\n        var e = this.series,\n            b = e.tooltipOptions,\n            g = H(b.valueDecimals, \"\"),\n            d = b.valuePrefix || \"\",\n            f = b.valueSuffix || \"\";\n        e.chart.styledMode && (a = e.chart.tooltip.styledModeFormat(a));\n        (e.pointArrayMap || [\"y\"]).forEach(function (e) {\n          e = \"{point.\" + e;\n          if (d || f) a = a.replace(RegExp(e + \"}\", \"g\"), d + e + \"}\" + f);\n          a = a.replace(RegExp(e + \"}\", \"g\"), e + \":,.\" + g + \"f}\");\n        });\n        return y(a, {\n          point: this,\n          series: this.series\n        }, e.chart);\n      };\n\n      x.prototype.update = function (a, b, d, g) {\n        function e() {\n          f.applyOptions(a);\n          var e = k && f.hasDummyGraphic;\n          e = null === f.y ? !e : e;\n          k && e && (f.graphic = k.destroy(), delete f.hasDummyGraphic);\n          K(a, !0) && (k && k.element && a && a.marker && \"undefined\" !== typeof a.marker.symbol && (f.graphic = k.destroy()), a && a.dataLabels && f.dataLabel && (f.dataLabel = f.dataLabel.destroy()), f.connector && (f.connector = f.connector.destroy()));\n          q = f.index;\n          l.updateParallelArrays(f, q);\n          u.data[q] = K(u.data[q], !0) || K(a, !0) ? f.options : H(a, u.data[q]);\n          l.isDirty = l.isDirtyData = !0;\n          !l.fixedBox && l.hasCartesianSeries && (c.isDirtyBox = !0);\n          \"point\" === u.legendType && (c.isDirtyLegend = !0);\n          b && c.redraw(d);\n        }\n\n        var f = this,\n            l = f.series,\n            k = f.graphic,\n            c = l.chart,\n            u = l.options,\n            q;\n        b = H(b, !0);\n        !1 === g ? e() : f.firePointEvent(\"update\", {\n          options: a\n        }, e);\n      };\n\n      x.prototype.remove = function (a, b) {\n        this.series.removePoint(this.series.data.indexOf(this), a, b);\n      };\n\n      x.prototype.select = function (a, b) {\n        var e = this,\n            g = e.series,\n            d = g.chart;\n        this.selectedStaging = a = H(a, !e.selected);\n        e.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: b\n        }, function () {\n          e.selected = e.options.selected = a;\n          g.options.data[g.data.indexOf(e)] = e.options;\n          e.setState(a && \"select\");\n          b || d.getSelectedPoints().forEach(function (a) {\n            var g = a.series;\n            a.selected && a !== e && (a.selected = a.options.selected = !1, g.options.data[g.data.indexOf(a)] = a.options, a.setState(d.hoverPoints && g.options.inactiveOtherPoints ? \"inactive\" : \"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      };\n\n      x.prototype.onMouseOver = function (a) {\n        var e = this.series.chart,\n            b = e.pointer;\n        a = a ? b.normalize(a) : b.getChartCoordinatesFromPoint(this, e.inverted);\n        b.runPointActions(a, this);\n      };\n\n      x.prototype.onMouseOut = function () {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      };\n\n      x.prototype.importEvents = function () {\n        if (!this.hasImportedEvents) {\n          var a = this,\n              b = M(a.series.options.point, a.options).events;\n          a.events = b;\n          N(b, function (e, g) {\n            d(e) && p(a, g, e);\n          });\n          this.hasImportedEvents = !0;\n        }\n      };\n\n      x.prototype.setState = function (a, b) {\n        var e = this.series,\n            g = this.state,\n            d = e.options.states[a || \"normal\"] || {},\n            f = F.plotOptions[e.type].marker && e.options.marker,\n            r = f && !1 === f.enabled,\n            q = f && f.states && f.states[a || \"normal\"] || {},\n            u = !1 === q.enabled,\n            w = this.marker || {},\n            x = e.chart,\n            m = f && e.markerAttribs,\n            p = e.halo,\n            h,\n            t = e.stateMarkerGraphic;\n        a = a || \"\";\n\n        if (!(a === this.state && !b || this.selected && \"select\" !== a || !1 === d.enabled || a && (u || r && !1 === q.enabled) || a && w.states && w.states[a] && !1 === w.states[a].enabled)) {\n          this.state = a;\n          m && (h = e.markerAttribs(this, a));\n\n          if (this.graphic && !this.hasDummyGraphic) {\n            g && this.graphic.removeClass(\"highcharts-point-\" + g);\n            a && this.graphic.addClass(\"highcharts-point-\" + a);\n\n            if (!x.styledMode) {\n              var K = e.pointAttribs(this, a);\n              var P = H(x.options.chart.animation, d.animation);\n              e.options.inactiveOtherPoints && v(K.opacity) && ((this.dataLabels || []).forEach(function (a) {\n                a && a.animate({\n                  opacity: K.opacity\n                }, P);\n              }), this.connector && this.connector.animate({\n                opacity: K.opacity\n              }, P));\n              this.graphic.animate(K, P);\n            }\n\n            h && this.graphic.animate(h, H(x.options.chart.animation, q.animation, f.animation));\n            t && t.hide();\n          } else {\n            if (a && q) {\n              g = w.symbol || e.symbol;\n              t && t.currentSymbol !== g && (t = t.destroy());\n              if (h) if (t) t[b ? \"animate\" : \"attr\"]({\n                x: h.x,\n                y: h.y\n              });else g && (e.stateMarkerGraphic = t = x.renderer.symbol(g, h.x, h.y, h.width, h.height).add(e.markerGroup), t.currentSymbol = g);\n              !x.styledMode && t && \"inactive\" !== this.state && t.attr(e.pointAttribs(this, a));\n            }\n\n            t && (t[a && this.isInside ? \"show\" : \"hide\"](), t.element.point = this, t.addClass(this.getClassName(), !0));\n          }\n\n          d = d.halo;\n          h = (t = this.graphic || t) && t.visibility || \"inherit\";\n          d && d.size && t && \"hidden\" !== h && !this.isCluster ? (p || (e.halo = p = x.renderer.path().add(t.parentGroup)), p.show()[b ? \"animate\" : \"attr\"]({\n            d: this.haloPath(d.size)\n          }), p.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + H(this.colorIndex, e.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: h,\n            zIndex: -1\n          }), p.point = this, x.styledMode || p.attr(k({\n            fill: this.color || e.color,\n            \"fill-opacity\": d.opacity\n          }, c.filterUserAttributes(d.attributes || {})))) : p && p.point && p.point.haloPath && p.animate({\n            d: p.point.haloPath(0)\n          }, null, p.hide);\n          n(this, \"afterSetState\", {\n            state: a\n          });\n        }\n      };\n\n      x.prototype.haloPath = function (a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      };\n\n      return x;\n    }();\n\n    \"\";\n    return h;\n  });\n  O(h, \"Core/Pointer.js\", [h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Tooltip.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E) {\n    var A = c.parse,\n        D = h.charts,\n        F = h.noop,\n        y = E.addEvent,\n        p = E.attr,\n        t = E.css,\n        b = E.defined,\n        k = E.extend,\n        n = E.find,\n        m = E.fireEvent,\n        f = E.isNumber,\n        d = E.isObject,\n        v = E.objectEach,\n        K = E.offset,\n        M = E.pick,\n        N = E.splat;\n\n    c = function () {\n      function c(b, d) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.eventsToUnbind = [];\n        this.chart = b;\n        this.hasDragged = !1;\n        this.options = d;\n        this.init(b, d);\n      }\n\n      c.prototype.applyInactiveState = function (b) {\n        var d = [],\n            a;\n        (b || []).forEach(function (b) {\n          a = b.series;\n          d.push(a);\n          a.linkedParent && d.push(a.linkedParent);\n          a.linkedSeries && (d = d.concat(a.linkedSeries));\n          a.navigatorSeries && d.push(a.navigatorSeries);\n        });\n        this.chart.series.forEach(function (a) {\n          -1 === d.indexOf(a) ? a.setState(\"inactive\", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState(\"inactive\");\n        });\n      };\n\n      c.prototype.destroy = function () {\n        var b = this;\n        this.eventsToUnbind.forEach(function (b) {\n          return b();\n        });\n        this.eventsToUnbind = [];\n        h.chartCount || (c.unbindDocumentMouseUp && (c.unbindDocumentMouseUp = c.unbindDocumentMouseUp()), c.unbindDocumentTouchEnd && (c.unbindDocumentTouchEnd = c.unbindDocumentTouchEnd()));\n        clearInterval(b.tooltipTimeout);\n        v(b, function (d, a) {\n          b[a] = void 0;\n        });\n      };\n\n      c.prototype.drag = function (b) {\n        var f = this.chart,\n            a = f.options.chart,\n            c = this.zoomHor,\n            e = this.zoomVert,\n            k = f.plotLeft,\n            l = f.plotTop,\n            g = f.plotWidth,\n            q = f.plotHeight,\n            m = this.mouseDownX || 0,\n            r = this.mouseDownY || 0,\n            n = d(a.panning) ? a.panning && a.panning.enabled : a.panning,\n            v = a.panKey && b[a.panKey + \"Key\"],\n            p = b.chartX,\n            C = b.chartY,\n            h = this.selectionMarker;\n        if (!h || !h.touch) if (p < k ? p = k : p > k + g && (p = k + g), C < l ? C = l : C > l + q && (C = l + q), this.hasDragged = Math.sqrt(Math.pow(m - p, 2) + Math.pow(r - C, 2)), 10 < this.hasDragged) {\n          var t = f.isInsidePlot(m - k, r - l, {\n            visiblePlotOnly: !0\n          });\n          !f.hasCartesianSeries && !f.mapView || !this.zoomX && !this.zoomY || !t || v || h || (this.selectionMarker = h = f.renderer.rect(k, l, c ? 1 : g, e ? 1 : q, 0).attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), f.styledMode || h.attr({\n            fill: a.selectionMarkerFill || A(\"#335cad\").setOpacity(.25).get()\n          }));\n          h && c && (c = p - m, h.attr({\n            width: Math.abs(c),\n            x: (0 < c ? 0 : c) + m\n          }));\n          h && e && (c = C - r, h.attr({\n            height: Math.abs(c),\n            y: (0 < c ? 0 : c) + r\n          }));\n          t && !h && n && f.pan(b, a.panning);\n        }\n      };\n\n      c.prototype.dragStart = function (b) {\n        var d = this.chart;\n        d.mouseIsDown = b.type;\n        d.cancelClick = !1;\n        d.mouseDownX = this.mouseDownX = b.chartX;\n        d.mouseDownY = this.mouseDownY = b.chartY;\n      };\n\n      c.prototype.drop = function (d) {\n        var c = this,\n            a = this.chart,\n            q = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var e = this.selectionMarker,\n              u = e.attr ? e.attr(\"x\") : e.x,\n              l = e.attr ? e.attr(\"y\") : e.y,\n              g = e.attr ? e.attr(\"width\") : e.width,\n              n = e.attr ? e.attr(\"height\") : e.height,\n              z = {\n            originalEvent: d,\n            xAxis: [],\n            yAxis: [],\n            x: u,\n            y: l,\n            width: g,\n            height: n\n          },\n              r = !!a.mapView;\n          if (this.hasDragged || q) a.axes.forEach(function (a) {\n            if (a.zoomEnabled && b(a.min) && (q || c[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[a.coll]]) && f(u) && f(l)) {\n              var e = a.horiz,\n                  k = \"touchend\" === d.type ? a.minPixelPadding : 0,\n                  m = a.toValue((e ? u : l) + k);\n              e = a.toValue((e ? u + g : l + n) - k);\n              z[a.coll].push({\n                axis: a,\n                min: Math.min(m, e),\n                max: Math.max(m, e)\n              });\n              r = !0;\n            }\n          }), r && m(a, \"selection\", z, function (e) {\n            a.zoom(k(e, q ? {\n              animation: !1\n            } : null));\n          });\n          f(a.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          q && this.scaleGroups();\n        }\n\n        a && f(a.index) && (t(a.container, {\n          cursor: a._cursor\n        }), a.cancelClick = 10 < this.hasDragged, a.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      };\n\n      c.prototype.findNearestKDPoint = function (b, f, a) {\n        var c = this.chart,\n            e = c.hoverPoint;\n        c = c.tooltip;\n        if (e && c && c.isStickyOnContact()) return e;\n        var k;\n        b.forEach(function (e) {\n          var g = !(e.noSharedTooltip && f) && 0 > e.options.findNearestPointBy.indexOf(\"y\");\n          e = e.searchPoint(a, g);\n\n          if ((g = d(e, !0) && e.series) && !(g = !d(k, !0))) {\n            g = k.distX - e.distX;\n            var b = k.dist - e.dist,\n                l = (e.series.group && e.series.group.zIndex) - (k.series.group && k.series.group.zIndex);\n            g = 0 < (0 !== g && f ? g : 0 !== b ? b : 0 !== l ? l : k.series.index > e.series.index ? -1 : 1);\n          }\n\n          g && (k = e);\n        });\n        return k;\n      };\n\n      c.prototype.getChartCoordinatesFromPoint = function (b, d) {\n        var a = b.series,\n            c = a.xAxis;\n        a = a.yAxis;\n        var e = b.shapeArgs;\n\n        if (c && a) {\n          var k = M(b.clientX, b.plotX),\n              l = b.plotY || 0;\n          b.isNode && e && f(e.x) && f(e.y) && (k = e.x, l = e.y);\n          return d ? {\n            chartX: a.len + a.pos - l,\n            chartY: c.len + c.pos - k\n          } : {\n            chartX: k + c.pos,\n            chartY: l + a.pos\n          };\n        }\n\n        if (e && e.x && e.y) return {\n          chartX: e.x,\n          chartY: e.y\n        };\n      };\n\n      c.prototype.getChartPosition = function () {\n        if (this.chartPosition) return this.chartPosition;\n        var b = this.chart.container,\n            d = K(b);\n        this.chartPosition = {\n          left: d.left,\n          top: d.top,\n          scaleX: 1,\n          scaleY: 1\n        };\n        var a = b.offsetWidth;\n        b = b.offsetHeight;\n        2 < a && 2 < b && (this.chartPosition.scaleX = d.width / a, this.chartPosition.scaleY = d.height / b);\n        return this.chartPosition;\n      };\n\n      c.prototype.getCoordinates = function (b) {\n        var d = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (a) {\n          d[a.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: a,\n            value: a.toValue(b[a.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return d;\n      };\n\n      c.prototype.getHoverData = function (b, f, a, c, e, k) {\n        var l = [];\n        c = !(!c || !b);\n\n        var g = function (a) {\n          return a.visible && !(!e && a.directTouch) && M(a.options.enableMouseTracking, !0);\n        },\n            q = {\n          chartX: k ? k.chartX : void 0,\n          chartY: k ? k.chartY : void 0,\n          shared: e\n        };\n\n        m(this, \"beforeGetHoverData\", q);\n        var u = f && !f.stickyTracking ? [f] : a.filter(function (a) {\n          return a.stickyTracking && (q.filter || g)(a);\n        });\n        var r = c || !k ? b : this.findNearestKDPoint(u, e, k);\n        f = r && r.series;\n        r && (e && !f.noSharedTooltip ? (u = a.filter(function (a) {\n          return q.filter ? q.filter(a) : g(a) && !a.noSharedTooltip;\n        }), u.forEach(function (a) {\n          var e = n(a.points, function (a) {\n            return a.x === r.x && !a.isNull;\n          });\n          d(e) && (a.boosted && a.boost && (e = a.boost.getPoint(e)), l.push(e));\n        })) : l.push(r));\n        q = {\n          hoverPoint: r\n        };\n        m(this, \"afterGetHoverData\", q);\n        return {\n          hoverPoint: q.hoverPoint,\n          hoverSeries: f,\n          hoverPoints: l\n        };\n      };\n\n      c.prototype.getPointFromEvent = function (b) {\n        b = b.target;\n\n        for (var d; b && !d;) d = b.point, b = b.parentNode;\n\n        return d;\n      };\n\n      c.prototype.onTrackerMouseOut = function (b) {\n        b = b.relatedTarget || b.toElement;\n        var d = this.chart.hoverSeries;\n        this.isDirectTouch = !1;\n        if (!(!d || !b || d.stickyTracking || this.inClass(b, \"highcharts-tooltip\") || this.inClass(b, \"highcharts-series-\" + d.index) && this.inClass(b, \"highcharts-tracker\"))) d.onMouseOut();\n      };\n\n      c.prototype.inClass = function (b, d) {\n        for (var a; b;) {\n          if (a = p(b, \"class\")) {\n            if (-1 !== a.indexOf(d)) return !0;\n            if (-1 !== a.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          b = b.parentElement;\n        }\n      };\n\n      c.prototype.init = function (b, d) {\n        this.options = d;\n        this.chart = b;\n        this.runChartClick = !(!d.chart.events || !d.chart.events.click);\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        B && (b.tooltip = new B(b, d.tooltip), this.followTouchMove = M(d.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      };\n\n      c.prototype.normalize = function (b, d) {\n        var a = b.touches,\n            f = a ? a.length ? a.item(0) : M(a.changedTouches, b.changedTouches)[0] : b;\n        d || (d = this.getChartPosition());\n        a = f.pageX - d.left;\n        f = f.pageY - d.top;\n        a /= d.scaleX;\n        f /= d.scaleY;\n        return k(b, {\n          chartX: Math.round(a),\n          chartY: Math.round(f)\n        });\n      };\n\n      c.prototype.onContainerClick = function (b) {\n        var d = this.chart,\n            a = d.hoverPoint;\n        b = this.normalize(b);\n        var f = d.plotLeft,\n            e = d.plotTop;\n        d.cancelClick || (a && this.inClass(b.target, \"highcharts-tracker\") ? (m(a.series, \"click\", k(b, {\n          point: a\n        })), d.hoverPoint && a.firePointEvent(\"click\", b)) : (k(b, this.getCoordinates(b)), d.isInsidePlot(b.chartX - f, b.chartY - e, {\n          visiblePlotOnly: !0\n        }) && m(d, \"click\", b)));\n      };\n\n      c.prototype.onContainerMouseDown = function (b) {\n        var d = 1 === ((b.buttons || b.button) & 1);\n        b = this.normalize(b);\n        if (h.isFirefox && 0 !== b.button) this.onContainerMouseMove(b);\n        if (\"undefined\" === typeof b.button || d) this.zoomOption(b), d && b.preventDefault && b.preventDefault(), this.dragStart(b);\n      };\n\n      c.prototype.onContainerMouseLeave = function (b) {\n        var d = D[M(c.hoverChartIndex, -1)],\n            a = this.chart.tooltip;\n        a && a.shouldStickOnContact() && this.inClass(b.relatedTarget, \"highcharts-tooltip-container\") || (b = this.normalize(b), d && (b.relatedTarget || b.toElement) && (d.pointer.reset(), d.pointer.chartPosition = void 0), a && !a.isHidden && this.reset());\n      };\n\n      c.prototype.onContainerMouseEnter = function (b) {\n        delete this.chartPosition;\n      };\n\n      c.prototype.onContainerMouseMove = function (b) {\n        var d = this.chart;\n        b = this.normalize(b);\n        this.setHoverChartIndex();\n        b.preventDefault || (b.returnValue = !1);\n        (\"mousedown\" === d.mouseIsDown || this.touchSelect(b)) && this.drag(b);\n        d.openMenu || !this.inClass(b.target, \"highcharts-tracker\") && !d.isInsidePlot(b.chartX - d.plotLeft, b.chartY - d.plotTop, {\n          visiblePlotOnly: !0\n        }) || (this.inClass(b.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(b));\n      };\n\n      c.prototype.onDocumentTouchEnd = function (b) {\n        var d = D[M(c.hoverChartIndex, -1)];\n        d && d.pointer.drop(b);\n      };\n\n      c.prototype.onContainerTouchMove = function (b) {\n        if (this.touchSelect(b)) this.onContainerMouseMove(b);else this.touch(b);\n      };\n\n      c.prototype.onContainerTouchStart = function (b) {\n        if (this.touchSelect(b)) this.onContainerMouseDown(b);else this.zoomOption(b), this.touch(b, !0);\n      };\n\n      c.prototype.onDocumentMouseMove = function (b) {\n        var d = this.chart,\n            a = this.chartPosition;\n        b = this.normalize(b, a);\n        var f = d.tooltip;\n        !a || f && f.isStickyOnContact() || d.isInsidePlot(b.chartX - d.plotLeft, b.chartY - d.plotTop, {\n          visiblePlotOnly: !0\n        }) || this.inClass(b.target, \"highcharts-tracker\") || this.reset();\n      };\n\n      c.prototype.onDocumentMouseUp = function (b) {\n        var d = D[M(c.hoverChartIndex, -1)];\n        d && d.pointer.drop(b);\n      };\n\n      c.prototype.pinch = function (b) {\n        var d = this,\n            a = d.chart,\n            f = d.pinchDown,\n            e = b.touches || [],\n            c = e.length,\n            l = d.lastValidTouch,\n            g = d.hasZoom,\n            q = {},\n            z = 1 === c && (d.inClass(b.target, \"highcharts-tracker\") && a.runTrackerClick || d.runChartClick),\n            r = {},\n            n = d.selectionMarker;\n        1 < c ? d.initiated = !0 : 1 === c && this.followTouchMove && (d.initiated = !1);\n        g && d.initiated && !z && !1 !== b.cancelable && b.preventDefault();\n        [].map.call(e, function (a) {\n          return d.normalize(a);\n        });\n        \"touchstart\" === b.type ? ([].forEach.call(e, function (a, e) {\n          f[e] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), l.x = [f[0].chartX, f[1] && f[1].chartX], l.y = [f[0].chartY, f[1] && f[1].chartY], a.axes.forEach(function (e) {\n          if (e.zoomEnabled) {\n            var b = a.bounds[e.horiz ? \"h\" : \"v\"],\n                g = e.minPixelPadding,\n                d = e.toPixels(Math.min(M(e.options.min, e.dataMin), e.dataMin)),\n                f = e.toPixels(Math.max(M(e.options.max, e.dataMax), e.dataMax)),\n                l = Math.max(d, f);\n            b.min = Math.min(e.pos, Math.min(d, f) - g);\n            b.max = Math.max(e.pos + e.len, l + g);\n          }\n        }), d.res = !0) : d.followTouchMove && 1 === c ? this.runPointActions(d.normalize(b)) : f.length && (m(a, \"touchpan\", {\n          originalEvent: b\n        }, function () {\n          n || (d.selectionMarker = n = k({\n            destroy: F,\n            touch: !0\n          }, a.plotBox));\n          d.pinchTranslate(f, e, q, n, r, l);\n          d.hasPinched = g;\n          d.scaleGroups(q, r);\n        }), d.res && (d.res = !1, this.reset(!1, 0)));\n      };\n\n      c.prototype.pinchTranslate = function (b, d, a, f, e, c) {\n        this.zoomHor && this.pinchTranslateDirection(!0, b, d, a, f, e, c);\n        this.zoomVert && this.pinchTranslateDirection(!1, b, d, a, f, e, c);\n      };\n\n      c.prototype.pinchTranslateDirection = function (b, d, a, f, e, c, l, g) {\n        var k = this.chart,\n            u = b ? \"x\" : \"y\",\n            r = b ? \"X\" : \"Y\",\n            m = \"chart\" + r,\n            q = b ? \"width\" : \"height\",\n            x = k[\"plot\" + (b ? \"Left\" : \"Top\")],\n            n = k.inverted,\n            w = k.bounds[b ? \"h\" : \"v\"],\n            v = 1 === d.length,\n            p = d[0][m],\n            h = !v && d[1][m];\n\n        d = function () {\n          \"number\" === typeof K && 20 < Math.abs(p - h) && (H = g || Math.abs(R - K) / Math.abs(p - h));\n          P = (x - R) / H + p;\n          t = k[\"plot\" + (b ? \"Width\" : \"Height\")] / H;\n        };\n\n        var t,\n            P,\n            H = g || 1,\n            R = a[0][m],\n            K = !v && a[1][m];\n        d();\n        a = P;\n\n        if (a < w.min) {\n          a = w.min;\n          var y = !0;\n        } else a + t > w.max && (a = w.max - t, y = !0);\n\n        y ? (R -= .8 * (R - l[u][0]), \"number\" === typeof K && (K -= .8 * (K - l[u][1])), d()) : l[u] = [R, K];\n        n || (c[u] = P - x, c[q] = t);\n        c = n ? 1 / H : H;\n        e[q] = t;\n        e[u] = a;\n        f[n ? b ? \"scaleY\" : \"scaleX\" : \"scale\" + r] = H;\n        f[\"translate\" + r] = c * x + (R - c * p);\n      };\n\n      c.prototype.reset = function (b, d) {\n        var a = this.chart,\n            f = a.hoverSeries,\n            e = a.hoverPoint,\n            c = a.hoverPoints,\n            l = a.tooltip,\n            g = l && l.shared ? c : e;\n        b && g && N(g).forEach(function (a) {\n          a.series.isCartesian && \"undefined\" === typeof a.plotX && (b = !1);\n        });\n        if (b) l && g && N(g).length && (l.refresh(g), l.shared && c ? c.forEach(function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : e && (e.setState(e.state, !0), a.axes.forEach(function (a) {\n          a.crosshair && e.series[a.coll] === a && a.drawCrosshair(null, e);\n        })));else {\n          if (e) e.onMouseOut();\n          c && c.forEach(function (a) {\n            a.setState();\n          });\n          if (f) f.onMouseOut();\n          l && l.hide(d);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          a.axes.forEach(function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = a.hoverPoints = a.hoverPoint = null;\n        }\n      };\n\n      c.prototype.runPointActions = function (b, d) {\n        var a = this.chart,\n            f = a.tooltip && a.tooltip.options.enabled ? a.tooltip : void 0,\n            e = f ? f.shared : !1,\n            k = d || a.hoverPoint,\n            l = k && k.series || a.hoverSeries;\n        d = this.getHoverData(k, l, a.series, (!b || \"touchmove\" !== b.type) && (!!d || l && l.directTouch && this.isDirectTouch), e, b);\n        k = d.hoverPoint;\n        l = d.hoverSeries;\n        var g = d.hoverPoints;\n        d = l && l.tooltipOptions.followPointer && !l.tooltipOptions.split;\n        var m = e && l && !l.noSharedTooltip;\n\n        if (k && (k !== a.hoverPoint || f && f.isHidden)) {\n          (a.hoverPoints || []).forEach(function (a) {\n            -1 === g.indexOf(a) && a.setState();\n          });\n          if (a.hoverSeries !== l) l.onMouseOver();\n          this.applyInactiveState(g);\n          (g || []).forEach(function (a) {\n            a.setState(\"hover\");\n          });\n          a.hoverPoint && a.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!k.series) return;\n          a.hoverPoints = g;\n          a.hoverPoint = k;\n          k.firePointEvent(\"mouseOver\", void 0, function () {\n            f && k && f.refresh(m ? g : k, b);\n          });\n        } else d && f && !f.isHidden && (e = f.getAnchor([{}], b), a.isInsidePlot(e[0], e[1], {\n          visiblePlotOnly: !0\n        }) && f.updatePosition({\n          plotX: e[0],\n          plotY: e[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = y(a.container.ownerDocument, \"mousemove\", function (a) {\n          var e = D[c.hoverChartIndex];\n          if (e) e.pointer.onDocumentMouseMove(a);\n        }), this.eventsToUnbind.push(this.unDocMouseMove));\n        a.axes.forEach(function (e) {\n          var d = M((e.crosshair || {}).snap, !0),\n              f;\n          d && ((f = a.hoverPoint) && f.series[e.coll] === e || (f = n(g, function (a) {\n            return a.series && a.series[e.coll] === e;\n          })));\n          f || !d ? e.drawCrosshair(b, f) : e.hideCrosshair();\n        });\n      };\n\n      c.prototype.scaleGroups = function (b, d) {\n        var a = this.chart;\n        a.series.forEach(function (f) {\n          var e = b || f.getPlotBox();\n          f.group && (f.xAxis && f.xAxis.zoomEnabled || a.mapView) && (f.group.attr(e), f.markerGroup && (f.markerGroup.attr(e), f.markerGroup.clip(d ? a.clipRect : null)), f.dataLabelsGroup && f.dataLabelsGroup.attr(e));\n        });\n        a.clipRect.attr(d || a.clipBox);\n      };\n\n      c.prototype.setDOMEvents = function () {\n        var b = this,\n            d = this.chart.container,\n            a = d.ownerDocument;\n        d.onmousedown = this.onContainerMouseDown.bind(this);\n        d.onmousemove = this.onContainerMouseMove.bind(this);\n        d.onclick = this.onContainerClick.bind(this);\n        this.eventsToUnbind.push(y(d, \"mouseenter\", this.onContainerMouseEnter.bind(this)));\n        this.eventsToUnbind.push(y(d, \"mouseleave\", this.onContainerMouseLeave.bind(this)));\n        c.unbindDocumentMouseUp || (c.unbindDocumentMouseUp = y(a, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n\n        for (var f = this.chart.renderTo.parentElement; f && \"BODY\" !== f.tagName;) this.eventsToUnbind.push(y(f, \"scroll\", function () {\n          delete b.chartPosition;\n        })), f = f.parentElement;\n\n        h.hasTouch && (this.eventsToUnbind.push(y(d, \"touchstart\", this.onContainerTouchStart.bind(this), {\n          passive: !1\n        })), this.eventsToUnbind.push(y(d, \"touchmove\", this.onContainerTouchMove.bind(this), {\n          passive: !1\n        })), c.unbindDocumentTouchEnd || (c.unbindDocumentTouchEnd = y(a, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n          passive: !1\n        })));\n      };\n\n      c.prototype.setHoverChartIndex = function () {\n        var b = this.chart,\n            d = h.charts[M(c.hoverChartIndex, -1)];\n        if (d && d !== b) d.pointer.onContainerMouseLeave({\n          relatedTarget: b.container\n        });\n        d && d.mouseIsDown || (c.hoverChartIndex = b.index);\n      };\n\n      c.prototype.touch = function (b, d) {\n        var a = this.chart,\n            f;\n        this.setHoverChartIndex();\n        if (1 === b.touches.length) {\n          if (b = this.normalize(b), (f = a.isInsidePlot(b.chartX - a.plotLeft, b.chartY - a.plotTop, {\n            visiblePlotOnly: !0\n          })) && !a.openMenu) {\n            d && this.runPointActions(b);\n\n            if (\"touchmove\" === b.type) {\n              d = this.pinchDown;\n              var e = d[0] ? 4 <= Math.sqrt(Math.pow(d[0].chartX - b.chartX, 2) + Math.pow(d[0].chartY - b.chartY, 2)) : !1;\n            }\n\n            M(e, !0) && this.pinch(b);\n          } else d && this.reset();\n        } else 2 === b.touches.length && this.pinch(b);\n      };\n\n      c.prototype.touchSelect = function (b) {\n        return !(!this.chart.options.chart.zooming.singleTouch || !b.touches || 1 !== b.touches.length);\n      };\n\n      c.prototype.zoomOption = function (b) {\n        var d = this.chart,\n            a = d.options.chart;\n        d = d.inverted;\n        var f = a.zooming.type || \"\";\n        /touch/.test(b.type) && (f = M(a.zooming.pinchType, f));\n        this.zoomX = b = /x/.test(f);\n        this.zoomY = a = /y/.test(f);\n        this.zoomHor = b && !d || a && d;\n        this.zoomVert = a && !d || b && d;\n        this.hasZoom = b || a;\n      };\n\n      return c;\n    }();\n\n    \"\";\n    return c;\n  });\n  O(h, \"Core/MSPointer.js\", [h[\"Core/Globals.js\"], h[\"Core/Pointer.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    function I() {\n      var b = [];\n\n      b.item = function (b) {\n        return this[b];\n      };\n\n      n(f, function (d) {\n        b.push({\n          pageX: d.pageX,\n          pageY: d.pageY,\n          target: d.target\n        });\n      });\n      return b;\n    }\n\n    function A(b, d, f, c) {\n      var k = F[h.hoverChartIndex || NaN];\n      \"touch\" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !k || (k = k.pointer, c(b), k[d]({\n        type: f,\n        target: b.currentTarget,\n        preventDefault: p,\n        touches: I()\n      }));\n    }\n\n    var D = this && this.__extends || function () {\n      var b = function (d, f) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var f in d) d.hasOwnProperty(f) && (b[f] = d[f]);\n        };\n\n        return b(d, f);\n      };\n\n      return function (d, f) {\n        function c() {\n          this.constructor = d;\n        }\n\n        b(d, f);\n        d.prototype = null === f ? Object.create(f) : (c.prototype = f.prototype, new c());\n      };\n    }(),\n        F = c.charts,\n        y = c.doc,\n        p = c.noop,\n        t = c.win,\n        b = B.addEvent,\n        k = B.css,\n        n = B.objectEach,\n        m = B.removeEvent,\n        f = {},\n        d = !!t.PointerEvent;\n\n    return function (n) {\n      function v() {\n        return null !== n && n.apply(this, arguments) || this;\n      }\n\n      D(v, n);\n\n      v.isRequired = function () {\n        return !(c.hasTouch || !t.PointerEvent && !t.MSPointerEvent);\n      };\n\n      v.prototype.batchMSEvents = function (b) {\n        b(this.chart.container, d ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n        b(this.chart.container, d ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n        b(y, d ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n      };\n\n      v.prototype.destroy = function () {\n        this.batchMSEvents(m);\n        n.prototype.destroy.call(this);\n      };\n\n      v.prototype.init = function (b, d) {\n        n.prototype.init.call(this, b, d);\n        this.hasZoom && k(b.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      };\n\n      v.prototype.onContainerPointerDown = function (b) {\n        A(b, \"onContainerTouchStart\", \"touchstart\", function (b) {\n          f[b.pointerId] = {\n            pageX: b.pageX,\n            pageY: b.pageY,\n            target: b.currentTarget\n          };\n        });\n      };\n\n      v.prototype.onContainerPointerMove = function (b) {\n        A(b, \"onContainerTouchMove\", \"touchmove\", function (b) {\n          f[b.pointerId] = {\n            pageX: b.pageX,\n            pageY: b.pageY\n          };\n          f[b.pointerId].target || (f[b.pointerId].target = b.currentTarget);\n        });\n      };\n\n      v.prototype.onDocumentPointerUp = function (b) {\n        A(b, \"onDocumentTouchEnd\", \"touchend\", function (b) {\n          delete f[b.pointerId];\n        });\n      };\n\n      v.prototype.setDOMEvents = function () {\n        n.prototype.setDOMEvents.call(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(b);\n      };\n\n      return v;\n    }(h);\n  });\n  O(h, \"Core/Legend/Legend.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/Globals.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Renderer/RendererUtilities.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A, D) {\n    var F = c.animObject,\n        y = c.setAnimation,\n        p = h.format;\n    c = B.isFirefox;\n    var t = B.marginNames;\n    B = B.win;\n    var b = A.distribute,\n        k = D.addEvent,\n        n = D.createElement,\n        m = D.css,\n        f = D.defined,\n        d = D.discardElement,\n        v = D.find,\n        K = D.fireEvent,\n        M = D.isNumber,\n        N = D.merge,\n        H = D.pick,\n        q = D.relativeLength,\n        w = D.stableSort,\n        a = D.syncTimeout;\n    A = D.wrap;\n\n    D = function () {\n      function c(a, b) {\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = void 0;\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = a;\n        this.init(a, b);\n      }\n\n      c.prototype.init = function (a, b) {\n        this.chart = a;\n        this.setOptions(b);\n        b.enabled && (this.render(), k(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = k(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      };\n\n      c.prototype.setOptions = function (a) {\n        var b = H(a.padding, 8);\n        this.options = a;\n        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = N(this.itemStyle, a.itemHiddenStyle));\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.itemMarginBottom = a.itemMarginBottom || 0;\n        this.padding = b;\n        this.initialItemY = b - 5;\n        this.symbolWidth = H(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n        this.baseline = void 0;\n      };\n\n      c.prototype.update = function (a, b) {\n        var e = this.chart;\n        this.setOptions(N(!0, this.options, a));\n        this.destroy();\n        e.isDirtyLegend = e.isDirtyBox = !0;\n        H(b, !0) && e.redraw();\n        K(this, \"afterUpdate\");\n      };\n\n      c.prototype.colorizeItem = function (a, b) {\n        a.legendGroup[b ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var e = this.options,\n              g = a.legendItem,\n              d = a.legendLine,\n              f = a.legendSymbol,\n              c = this.itemHiddenStyle.color;\n          e = b ? e.itemStyle.color : c;\n          var k = b ? a.color || c : c,\n              u = a.options && a.options.marker,\n              m = {\n            fill: k\n          };\n          g && g.css({\n            fill: e,\n            color: e\n          });\n          d && d.attr({\n            stroke: k\n          });\n          f && (u && f.isMarker && (m = a.pointAttribs(), b || (m.stroke = m.fill = c)), f.attr(m));\n        }\n\n        K(this, \"afterColorizeItem\", {\n          item: a,\n          visible: b\n        });\n      };\n\n      c.prototype.positionItems = function () {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      };\n\n      c.prototype.positionItem = function (a) {\n        var b = this,\n            e = this.options,\n            g = e.symbolPadding,\n            d = !e.rtl,\n            c = a._legendItemPos;\n        e = c[0];\n        c = c[1];\n        var k = a.checkbox,\n            m = a.legendGroup;\n        m && m.element && (g = {\n          translateX: d ? e : this.legendWidth - e - 2 * g - 4,\n          translateY: c\n        }, d = function () {\n          K(b, \"afterPositionItem\", {\n            item: a\n          });\n        }, f(m.translateY) ? m.animate(g, void 0, d) : (m.attr(g), d()));\n        k && (k.x = e, k.y = c);\n      };\n\n      c.prototype.destroyItem = function (a) {\n        var b = a.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (b) {\n          a[b] && (a[b] = a[b].destroy());\n        });\n        b && d(a.checkbox);\n      };\n\n      c.prototype.destroy = function () {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        this.getAllItems().forEach(function (b) {\n          [\"legendItem\", \"legendGroup\"].forEach(a, b);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(a, this);\n        this.display = null;\n      };\n\n      c.prototype.positionCheckboxes = function () {\n        var a = this.group && this.group.alignAttr,\n            b = this.clipHeight || this.legendHeight,\n            d = this.titleHeight;\n\n        if (a) {\n          var g = a.translateY;\n          this.allItems.forEach(function (e) {\n            var f = e.checkbox;\n\n            if (f) {\n              var l = g + d + f.y + (this.scrollOffset || 0) + 3;\n              m(f, {\n                left: a.translateX + e.checkboxOffset + f.x - 20 + \"px\",\n                top: l + \"px\",\n                display: this.proximate || l > g - 6 && l < g + b - 6 ? \"\" : \"none\"\n              });\n            }\n          }, this);\n        }\n      };\n\n      c.prototype.renderTitle = function () {\n        var a = this.options,\n            b = this.padding,\n            d = a.title,\n            g = 0;\n        d.text && (this.title || (this.title = this.chart.renderer.label(d.text, b - 3, b - 4, void 0, void 0, void 0, a.useHTML, void 0, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(d.style), this.title.add(this.group)), d.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), a = this.title.getBBox(), g = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: g\n        }));\n        this.titleHeight = g;\n      };\n\n      c.prototype.setText = function (a) {\n        var b = this.options;\n        a.legendItem.attr({\n          text: b.labelFormat ? p(b.labelFormat, a, this.chart) : b.labelFormatter.call(a)\n        });\n      };\n\n      c.prototype.renderItem = function (a) {\n        var b = this.chart,\n            e = b.renderer,\n            g = this.options,\n            d = this.symbolWidth,\n            f = g.symbolPadding || 0,\n            c = this.itemStyle,\n            k = this.itemHiddenStyle,\n            m = \"horizontal\" === g.layout ? H(g.itemDistance, 20) : 0,\n            n = !g.rtl,\n            q = !a.series,\n            x = !q && a.series.drawLegendSymbol ? a.series : a,\n            v = x.options,\n            p = this.createCheckboxForItem && v && v.showCheckbox,\n            h = g.useHTML,\n            w = a.options.className,\n            P = a.legendItem;\n        v = d + f + m + (p ? 20 : 0);\n        P || (a.legendGroup = e.g(\"legend-item\").addClass(\"highcharts-\" + x.type + \"-series highcharts-color-\" + a.colorIndex + (w ? \" \" + w : \"\") + (q ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = P = e.text(\"\", n ? d + f : -f, this.baseline || 0, h), b.styledMode || P.css(N(a.visible ? c : k)), P.attr({\n          align: n ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (this.fontMetrics = e.fontMetrics(b.styledMode ? 12 : c.fontSize, P), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, P.attr(\"y\", this.baseline), this.symbolHeight = g.symbolHeight || this.fontMetrics.f, g.squareSymbol && (this.symbolWidth = H(g.symbolWidth, Math.max(this.symbolHeight, 16)), v = this.symbolWidth + f + m + (p ? 20 : 0), n && P.attr(\"x\", this.symbolWidth + f))), x.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, P, h));\n        p && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);\n        this.colorizeItem(a, a.visible);\n        !b.styledMode && c.width || P.css({\n          width: (g.itemWidth || this.widthOption || b.spacingBox.width) - v + \"px\"\n        });\n        this.setText(a);\n        b = P.getBBox();\n        e = this.fontMetrics && this.fontMetrics.h || 0;\n        a.itemWidth = a.checkboxOffset = g.itemWidth || a.legendItemWidth || b.width + v;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || (b.height > 1.5 * e ? b.height : e));\n      };\n\n      c.prototype.layoutItem = function (a) {\n        var b = this.options,\n            e = this.padding,\n            g = \"horizontal\" === b.layout,\n            d = a.itemHeight,\n            f = this.itemMarginBottom,\n            c = this.itemMarginTop,\n            k = g ? H(b.itemDistance, 20) : 0,\n            m = this.maxLegendWidth;\n        b = b.alignColumns && this.totalItemWidth > m ? this.maxItemWidth : a.itemWidth;\n        g && this.itemX - e + b > m && (this.itemX = e, this.lastLineHeight && (this.itemY += c + this.lastLineHeight + f), this.lastLineHeight = 0);\n        this.lastItemY = c + this.itemY + f;\n        this.lastLineHeight = Math.max(d, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        g ? this.itemX += b : (this.itemY += c + d + f, this.lastLineHeight = d);\n        this.offsetWidth = this.widthOption || Math.max((g ? this.itemX - e - (a.checkbox ? 0 : k) : b) + e, this.offsetWidth);\n      };\n\n      c.prototype.getAllItems = function () {\n        var a = [];\n        this.chart.series.forEach(function (b) {\n          var e = b && b.options;\n          b && H(e.showInLegend, f(e.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || (\"point\" === e.legendType ? b.data : b)));\n        });\n        K(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      };\n\n      c.prototype.getAlignment = function () {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      };\n\n      c.prototype.adjustMargins = function (a, b) {\n        var e = this.chart,\n            g = this.options,\n            d = this.getAlignment();\n        d && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (l, c) {\n          l.test(d) && !f(a[c]) && (e[t[c]] = Math.max(e[t[c]], e.legend[(c + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][c] * g[c % 2 ? \"x\" : \"y\"] + H(g.margin, 12) + b[c] + (e.titleOffset[c] || 0)));\n        });\n      };\n\n      c.prototype.proximatePositions = function () {\n        var a = this.chart,\n            d = [],\n            f = \"left\" === this.options.align;\n        this.allItems.forEach(function (b) {\n          var e;\n          var g = f;\n\n          if (b.yAxis) {\n            b.xAxis.options.reversed && (g = !g);\n            b.points && (e = v(g ? b.points : b.points.slice(0).reverse(), function (a) {\n              return M(a.plotY);\n            }));\n            g = this.itemMarginTop + b.legendItem.getBBox().height + this.itemMarginBottom;\n            var l = b.yAxis.top - a.plotTop;\n            b.visible ? (e = e ? e.plotY : b.yAxis.height, e += l - .3 * g) : e = l + b.yAxis.height;\n            d.push({\n              target: e,\n              size: g,\n              item: b\n            });\n          }\n        }, this);\n        b(d, a.plotHeight).forEach(function (b) {\n          b.item._legendItemPos && b.pos && (b.item._legendItemPos[1] = a.plotTop - a.spacing[0] + b.pos);\n        });\n      };\n\n      c.prototype.render = function () {\n        var a = this.chart,\n            b = a.renderer,\n            d = this.options,\n            g = this.padding,\n            f = this.getAllItems(),\n            c = this.group,\n            k = this.box;\n        this.itemX = g;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = q(d.width, a.spacingBox.width - g);\n        var m = a.spacingBox.width - 2 * g - d.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (m /= 2);\n        this.maxLegendWidth = this.widthOption || m;\n        c || (this.group = c = b.g(\"legend\").addClass(d.className || \"\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = b.g().attr({\n          zIndex: 1\n        }).add(c), this.scrollGroup = b.g().add(this.contentGroup));\n        this.renderTitle();\n        w(f, function (a, b) {\n          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n        });\n        d.reversed && f.reverse();\n        this.allItems = f;\n        this.display = m = !!f.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        f.forEach(this.renderItem, this);\n        f.forEach(this.layoutItem, this);\n        f = (this.widthOption || this.offsetWidth) + g;\n        var n = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        n = this.handleOverflow(n);\n        n += g;\n        k || (this.box = k = b.rect().addClass(\"highcharts-legend-box\").attr({\n          r: d.borderRadius\n        }).add(c));\n        a.styledMode || k.attr({\n          stroke: d.borderColor,\n          \"stroke-width\": d.borderWidth || 0,\n          fill: d.backgroundColor || \"none\"\n        }).shadow(d.shadow);\n        if (0 < f && 0 < n) k[k.placed ? \"animate\" : \"attr\"](k.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: f,\n          height: n\n        }, k.strokeWidth()));\n        c[m ? \"show\" : \"hide\"]();\n        a.styledMode && \"none\" === c.getStyle(\"display\") && (f = n = 0);\n        this.legendWidth = f;\n        this.legendHeight = n;\n        m && this.align();\n        this.proximate || this.positionItems();\n        K(this, \"afterRender\");\n      };\n\n      c.prototype.align = function (a) {\n        void 0 === a && (a = this.chart.spacingBox);\n        var b = this.chart,\n            e = this.options,\n            d = a.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < b.titleOffset[0] ? d += b.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < b.titleOffset[2] && (d -= b.titleOffset[2]);\n        d !== a.y && (a = N(a, {\n          y: d\n        }));\n        b.hasRendered || (this.group.placed = !1);\n        this.group.align(N(e, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? \"top\" : e.verticalAlign\n        }), !0, a);\n      };\n\n      c.prototype.handleOverflow = function (a) {\n        var b = this,\n            e = this.chart,\n            d = e.renderer,\n            f = this.options,\n            c = f.y,\n            k = \"top\" === f.verticalAlign,\n            m = this.padding,\n            n = f.maxHeight,\n            q = f.navigation,\n            x = H(q.animation, !0),\n            v = q.arrowSize || 12,\n            p = this.pages,\n            h = this.allItems,\n            w = function (a) {\n          \"number\" === typeof a ? y.attr({\n            height: a\n          }) : y && (b.clipRect = y.destroy(), b.contentGroup.clip());\n          b.contentGroup.div && (b.contentGroup.div.style.clip = a ? \"rect(\" + m + \"px,9999px,\" + (m + a) + \"px,0)\" : \"auto\");\n        },\n            t = function (a) {\n          b[a] = d.circle(0, 0, 1.3 * v).translate(v / 2, v / 2).add(R);\n          e.styledMode || b[a].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n          return b[a];\n        },\n            P,\n            K;\n\n        c = e.spacingBox.height + (k ? -c : c) - m;\n        var R = this.nav,\n            y = this.clipRect;\n        \"horizontal\" !== f.layout || \"middle\" === f.verticalAlign || f.floating || (c /= 2);\n        n && (c = Math.min(c, n));\n        p.length = 0;\n        a && 0 < c && a > c && !1 !== q.enabled ? (this.clipHeight = P = Math.max(c - 20 - this.titleHeight - m, 0), this.currentPage = H(this.currentPage, 1), this.fullHeight = a, h.forEach(function (a, b) {\n          var e = a._legendItemPos[1],\n              d = Math.round(a.legendItem.getBBox().height),\n              g = p.length;\n          if (!g || e - p[g - 1] > P && (K || e) !== p[g - 1]) p.push(K || e), g++;\n          a.pageIx = g - 1;\n          K && (h[b - 1].pageIx = g - 1);\n          b === h.length - 1 && e + d - p[g - 1] > P && d <= P && (p.push(e), a.pageIx = g);\n          e !== K && (K = e);\n        }), y || (y = b.clipRect = d.clipRect(0, m, 9999, 0), b.contentGroup.clip(y)), w(P), R || (this.nav = R = d.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = d.symbol(\"triangle\", 0, 0, v, v).add(R), t(\"upTracker\").on(\"click\", function () {\n          b.scroll(-1, x);\n        }), this.pager = d.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), !e.styledMode && q.style && this.pager.css(q.style), this.pager.add(R), this.down = d.symbol(\"triangle-down\", 0, 0, v, v).add(R), t(\"downTracker\").on(\"click\", function () {\n          b.scroll(1, x);\n        })), b.scroll(0), a = c) : R && (w(), this.nav = R.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      };\n\n      c.prototype.scroll = function (b, d) {\n        var e = this,\n            g = this.chart,\n            f = this.pages,\n            c = f.length,\n            k = this.clipHeight,\n            m = this.options.navigation,\n            n = this.pager,\n            u = this.padding,\n            q = this.currentPage + b;\n        q > c && (q = c);\n        0 < q && (\"undefined\" !== typeof d && y(d, g), this.nav.attr({\n          translateX: u,\n          translateY: k + this.padding + 7 + this.titleHeight,\n          visibility: \"inherit\"\n        }), [this.up, this.upTracker].forEach(function (a) {\n          a.attr({\n            \"class\": 1 === q ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), n.attr({\n          text: q + \"/\" + c\n        }), [this.down, this.downTracker].forEach(function (a) {\n          a.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": q === c ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), g.styledMode || (this.up.attr({\n          fill: 1 === q ? m.inactiveColor : m.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === q ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: q === c ? m.inactiveColor : m.activeColor\n        }), this.downTracker.css({\n          cursor: q === c ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -f[q - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = q, this.positionCheckboxes(), b = F(H(d, g.renderer.globalAnimation, !0)), a(function () {\n          K(e, \"afterScroll\", {\n            currentPage: q\n          });\n        }, b.duration));\n      };\n\n      c.prototype.setItemEvents = function (a, b, d) {\n        var e = this,\n            f = e.chart.renderer.boxWrapper,\n            c = a instanceof E,\n            l = \"highcharts-legend-\" + (c ? \"point\" : \"series\") + \"-active\",\n            k = e.chart.styledMode,\n            m = function (b) {\n          e.allItems.forEach(function (e) {\n            a !== e && [e].concat(e.linkedSeries || []).forEach(function (a) {\n              a.setState(b, !c);\n            });\n          });\n        };\n\n        (d ? [b, a.legendSymbol] : [a.legendGroup]).forEach(function (d) {\n          if (d) d.on(\"mouseover\", function () {\n            a.visible && m(\"inactive\");\n            a.setState(\"hover\");\n            a.visible && f.addClass(l);\n            k || b.css(e.options.itemHoverStyle);\n          }).on(\"mouseout\", function () {\n            e.chart.styledMode || b.css(N(a.visible ? e.itemStyle : e.itemHiddenStyle));\n            m(\"\");\n            f.removeClass(l);\n            a.setState();\n          }).on(\"click\", function (b) {\n            var e = function () {\n              a.setVisible && a.setVisible();\n              m(a.visible ? \"inactive\" : \"\");\n            };\n\n            f.removeClass(l);\n            b = {\n              browserEvent: b\n            };\n            a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, e) : K(a, \"legendItemClick\", b, e);\n          });\n        });\n      };\n\n      c.prototype.createCheckboxForItem = function (a) {\n        a.checkbox = n(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        k(a.checkbox, \"click\", function (b) {\n          K(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      };\n\n      return c;\n    }();\n\n    (/Trident\\/7\\.0/.test(B.navigator && B.navigator.userAgent) || c) && A(D.prototype, \"positionItem\", function (a, b) {\n      var e = this,\n          d = function () {\n        b._legendItemPos && a.call(e, b);\n      };\n\n      d();\n      e.bubbleLegend || setTimeout(d);\n    });\n    \"\";\n    return D;\n  });\n  O(h, \"Core/Series/SeriesRegistry.js\", [h[\"Core/Globals.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E) {\n    var A = h.defaultOptions,\n        D = E.extendClass,\n        F = E.merge,\n        y;\n\n    (function (p) {\n      function h(b, c) {\n        var k = A.plotOptions || {},\n            m = c.defaultOptions,\n            f = c.prototype;\n        f.type = b;\n        f.pointClass || (f.pointClass = B);\n        m && (k[b] = m);\n        p.seriesTypes[b] = c;\n      }\n\n      p.seriesTypes = c.seriesTypes;\n      p.registerSeriesType = h;\n\n      p.seriesType = function (b, c, n, m, f) {\n        var d = A.plotOptions || {};\n        c = c || \"\";\n        d[b] = F(d[c], n);\n        h(b, D(p.seriesTypes[c] || function () {}, m));\n        p.seriesTypes[b].prototype.type = b;\n        f && (p.seriesTypes[b].prototype.pointClass = D(B, f));\n        return p.seriesTypes[b];\n      };\n    })(y || (y = {}));\n\n    return y;\n  });\n  O(h, \"Core/Chart/Chart.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Axis/Axis.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/Foundation.js\"], h[\"Core/Globals.js\"], h[\"Core/Legend/Legend.js\"], h[\"Core/MSPointer.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Pointer.js\"], h[\"Core/Renderer/RendererRegistry.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Renderer/SVG/SVGRenderer.js\"], h[\"Core/Time.js\"], h[\"Core/Utilities.js\"], h[\"Core/Renderer/HTML/AST.js\"]], function (c, h, B, E, A, D, F, y, p, t, b, k, n, m, f) {\n    var d = c.animate,\n        v = c.animObject,\n        K = c.setAnimation,\n        M = B.numberFormat,\n        N = E.registerEventOptions,\n        H = A.charts,\n        q = A.doc,\n        w = A.marginNames,\n        a = A.svg,\n        x = A.win,\n        e = y.defaultOptions,\n        u = y.defaultTime,\n        l = b.seriesTypes,\n        g = m.addEvent,\n        G = m.attr,\n        z = m.cleanRecursively,\n        r = m.createElement,\n        L = m.css,\n        Q = m.defined,\n        S = m.discardElement,\n        C = m.erase,\n        J = m.error,\n        Y = m.extend,\n        ca = m.find,\n        I = m.fireEvent,\n        aa = m.getStyle,\n        P = m.isArray,\n        W = m.isNumber,\n        R = m.isObject,\n        ba = m.isString,\n        V = m.merge,\n        X = m.objectEach,\n        T = m.pick,\n        da = m.pInt,\n        ha = m.relativeLength,\n        O = m.removeEvent,\n        ea = m.splat,\n        Z = m.syncTimeout,\n        ia = m.uniqueKey;\n\n    c = function () {\n      function b(a, b, e) {\n        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;\n        this.sharedClips = {};\n        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;\n        this.getArgs(a, b, e);\n      }\n\n      b.chart = function (a, e, d) {\n        return new b(a, e, d);\n      };\n\n      b.prototype.getArgs = function (a, b, e) {\n        ba(a) || a.nodeName ? (this.renderTo = a, this.init(b, e)) : this.init(a, b);\n      };\n\n      b.prototype.init = function (a, b) {\n        var d = a.plotOptions || {};\n        I(this, \"init\", {\n          args: arguments\n        }, function () {\n          var g = V(e, a),\n              f = g.chart;\n          X(g.plotOptions, function (a, b) {\n            R(a) && (a.tooltip = d[b] && V(d[b].tooltip) || void 0);\n          });\n          g.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;\n          this.userOptions = a;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = b;\n          this.isResizing = 0;\n          var c = f.zooming = f.zooming || {};\n          a.chart && !a.chart.zooming && (c.resetButton = f.resetZoomButton);\n          c.key = T(c.key, f.zoomKey);\n          c.pinchType = T(c.pinchType, f.pinchType);\n          c.singleTouch = T(c.singleTouch, f.zoomBySingleTouch);\n          c.type = T(c.type, f.zoomType);\n          this.options = g;\n          this.axes = [];\n          this.series = [];\n          this.time = a.time && Object.keys(a.time).length ? new n(a.time) : A.time;\n          this.numberFormatter = f.numberFormatter || M;\n          this.styledMode = f.styledMode;\n          this.hasCartesianSeries = f.showAxes;\n          this.index = H.length;\n          H.push(this);\n          A.chartCount++;\n          N(this, f);\n          this.xAxis = [];\n          this.yAxis = [];\n          this.pointCount = this.colorCounter = this.symbolCounter = 0;\n          I(this, \"afterInit\");\n          this.firstRender();\n        });\n      };\n\n      b.prototype.initSeries = function (a) {\n        var b = this.options.chart;\n        b = a.type || b.type || b.defaultSeriesType;\n        var e = l[b];\n        e || J(17, !0, this, {\n          missingModuleFor: b\n        });\n        b = new e();\n        \"function\" === typeof b.init && b.init(this, a);\n        return b;\n      };\n\n      b.prototype.setSeriesData = function () {\n        this.getSeriesOrderByLinks().forEach(function (a) {\n          a.points || a.data || !a.enabledDataSorting || a.setData(a.options.data, !1);\n        });\n      };\n\n      b.prototype.getSeriesOrderByLinks = function () {\n        return this.series.concat().sort(function (a, b) {\n          return a.linkedSeries.length || b.linkedSeries.length ? b.linkedSeries.length - a.linkedSeries.length : 0;\n        });\n      };\n\n      b.prototype.orderSeries = function (a) {\n        var b = this.series;\n        a = a || 0;\n\n        for (var e = b.length; a < e; ++a) b[a] && (b[a].index = a, b[a].name = b[a].getName());\n      };\n\n      b.prototype.isInsidePlot = function (a, b, e) {\n        void 0 === e && (e = {});\n        var d = this.inverted,\n            g = this.plotBox,\n            f = this.plotLeft,\n            c = this.plotTop,\n            l = this.scrollablePlotBox,\n            k = 0;\n        var r = 0;\n        e.visiblePlotOnly && this.scrollingContainer && (r = this.scrollingContainer, k = r.scrollLeft, r = r.scrollTop);\n        var m = e.series;\n        g = e.visiblePlotOnly && l || g;\n        l = e.inverted ? b : a;\n        b = e.inverted ? a : b;\n        a = {\n          x: l,\n          y: b,\n          isInsidePlot: !0\n        };\n\n        if (!e.ignoreX) {\n          var n = m && (d ? m.yAxis : m.xAxis) || {\n            pos: f,\n            len: Infinity\n          };\n          l = e.paneCoordinates ? n.pos + l : f + l;\n          l >= Math.max(k + f, n.pos) && l <= Math.min(k + f + g.width, n.pos + n.len) || (a.isInsidePlot = !1);\n        }\n\n        !e.ignoreY && a.isInsidePlot && (d = m && (d ? m.xAxis : m.yAxis) || {\n          pos: c,\n          len: Infinity\n        }, e = e.paneCoordinates ? d.pos + b : c + b, e >= Math.max(r + c, d.pos) && e <= Math.min(r + c + g.height, d.pos + d.len) || (a.isInsidePlot = !1));\n        I(this, \"afterIsInsidePlot\", a);\n        return a.isInsidePlot;\n      };\n\n      b.prototype.redraw = function (a) {\n        I(this, \"beforeRedraw\");\n        var b = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n            e = this.series,\n            d = this.pointer,\n            g = this.legend,\n            f = this.userOptions.legend,\n            c = this.renderer,\n            l = c.isHidden(),\n            k = [],\n            r = this.isDirtyBox,\n            m = this.isDirtyLegend;\n        this.setResponsive && this.setResponsive(!1);\n        K(this.hasRendered ? a : !1, this);\n        l && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (a = e.length; a--;) {\n          var n = e[a];\n\n          if (n.options.stacking || n.options.centerInCategory) {\n            var q = !0;\n\n            if (n.isDirty) {\n              var u = !0;\n              break;\n            }\n          }\n        }\n\n        if (u) for (a = e.length; a--;) n = e[a], n.options.stacking && (n.isDirty = !0);\n        e.forEach(function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (\"function\" === typeof a.updateTotals && a.updateTotals(), m = !0) : f && (f.labelFormatter || f.labelFormat) && (m = !0));\n          a.isDirtyData && I(a, \"updatedData\");\n        });\n        m && g && g.options.enabled && (g.render(), this.isDirtyLegend = !1);\n        q && this.getStacks();\n        b.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        });\n        this.getMargins();\n        b.forEach(function (a) {\n          a.isDirty && (r = !0);\n        });\n        b.forEach(function (a) {\n          var b = a.min + \",\" + a.max;\n          a.extKey !== b && (a.extKey = b, k.push(function () {\n            I(a, \"afterSetExtremes\", Y(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (r || q) && a.redraw();\n        });\n        r && this.drawChartBox();\n        I(this, \"predraw\");\n        e.forEach(function (a) {\n          (r || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        d && d.reset(!0);\n        c.draw();\n        I(this, \"redraw\");\n        I(this, \"render\");\n        l && this.temporaryDisplay(!0);\n        k.forEach(function (a) {\n          a.call();\n        });\n      };\n\n      b.prototype.get = function (a) {\n        function b(b) {\n          return b.id === a || b.options && b.options.id === a;\n        }\n\n        for (var e = this.series, d = ca(this.axes, b) || ca(this.series, b), g = 0; !d && g < e.length; g++) d = ca(e[g].points || [], b);\n\n        return d;\n      };\n\n      b.prototype.getAxes = function () {\n        var a = this,\n            b = this.options,\n            e = b.xAxis = ea(b.xAxis || {});\n        b = b.yAxis = ea(b.yAxis || {});\n        I(this, \"getAxes\");\n        e.forEach(function (a, b) {\n          a.index = b;\n          a.isX = !0;\n        });\n        b.forEach(function (a, b) {\n          a.index = b;\n        });\n        e.concat(b).forEach(function (b) {\n          new h(a, b);\n        });\n        I(this, \"afterGetAxes\");\n      };\n\n      b.prototype.getSelectedPoints = function () {\n        return this.series.reduce(function (a, b) {\n          b.getPointsCollection().forEach(function (b) {\n            T(b.selectedStaging, b.selected) && a.push(b);\n          });\n          return a;\n        }, []);\n      };\n\n      b.prototype.getSelectedSeries = function () {\n        return this.series.filter(function (a) {\n          return a.selected;\n        });\n      };\n\n      b.prototype.setTitle = function (a, b, e) {\n        this.applyDescription(\"title\", a);\n        this.applyDescription(\"subtitle\", b);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(e);\n      };\n\n      b.prototype.applyDescription = function (a, b) {\n        var e = this,\n            d = \"title\" === a ? {\n          color: \"#333333\",\n          fontSize: this.options.isStock ? \"16px\" : \"18px\"\n        } : {\n          color: \"#666666\"\n        };\n        d = this.options[a] = V(!this.styledMode && {\n          style: d\n        }, this.options[a], b);\n        var g = this[a];\n        g && b && (this[a] = g = g.destroy());\n        d && !g && (g = this.renderer.text(d.text, 0, 0, d.useHTML).attr({\n          align: d.align,\n          \"class\": \"highcharts-\" + a,\n          zIndex: d.zIndex || 4\n        }).add(), g.update = function (b) {\n          e[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[a]](b);\n        }, this.styledMode || g.css(d.style), this[a] = g);\n      };\n\n      b.prototype.layOutTitles = function (a) {\n        var b = [0, 0, 0],\n            e = this.renderer,\n            d = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (a) {\n          var g = this[a],\n              f = this.options[a],\n              c = f.verticalAlign || \"top\";\n          a = \"title\" === a ? \"top\" === c ? -3 : 0 : \"top\" === c ? b[0] + 2 : 0;\n          var l;\n\n          if (g) {\n            this.styledMode || (l = f.style && f.style.fontSize);\n            l = e.fontMetrics(l, g).b;\n            g.css({\n              width: (f.width || d.width + (f.widthAdjust || 0)) + \"px\"\n            });\n            var k = Math.round(g.getBBox(f.useHTML).height);\n            g.align(Y({\n              y: \"bottom\" === c ? l : a + l,\n              height: k\n            }, f), !1, \"spacingBox\");\n            f.floating || (\"top\" === c ? b[0] = Math.ceil(b[0] + k) : \"bottom\" === c && (b[2] = Math.ceil(b[2] + k)));\n          }\n        }, this);\n        b[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (b[0] += this.options.title.margin);\n        b[2] && \"bottom\" === this.options.caption.verticalAlign && (b[2] += this.options.caption.margin);\n        var g = !this.titleOffset || this.titleOffset.join(\",\") !== b.join(\",\");\n        this.titleOffset = b;\n        I(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && g && (this.isDirtyBox = this.isDirtyLegend = g, this.hasRendered && T(a, !0) && this.isDirtyBox && this.redraw());\n      };\n\n      b.prototype.getChartSize = function () {\n        var a = this.options.chart,\n            b = a.width;\n        a = a.height;\n        var e = this.renderTo;\n        Q(b) || (this.containerWidth = aa(e, \"width\"));\n        Q(a) || (this.containerHeight = aa(e, \"height\"));\n        this.chartWidth = Math.max(0, b || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, ha(a, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      };\n\n      b.prototype.temporaryDisplay = function (a) {\n        var b = this.renderTo;\n        if (a) for (; b && b.style;) b.hcOrigStyle && (L(b, b.hcOrigStyle), delete b.hcOrigStyle), b.hcOrigDetached && (q.body.removeChild(b), b.hcOrigDetached = !1), b = b.parentNode;else for (; b && b.style;) {\n          q.body.contains(b) || b.parentNode || (b.hcOrigDetached = !0, q.body.appendChild(b));\n          if (\"none\" === aa(b, \"display\", !1) || b.hcOricDetached) b.hcOrigStyle = {\n            display: b.style.display,\n            height: b.style.height,\n            overflow: b.style.overflow\n          }, a = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, b !== this.renderTo && (a.height = 0), L(b, a), b.offsetWidth || b.style.setProperty(\"display\", \"block\", \"important\");\n          b = b.parentNode;\n          if (b === q.body) break;\n        }\n      };\n\n      b.prototype.setClassName = function (a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      };\n\n      b.prototype.getContainer = function () {\n        var b = this.options,\n            e = b.chart,\n            d = ia(),\n            g,\n            c = this.renderTo;\n        c || (this.renderTo = c = e.renderTo);\n        ba(c) && (this.renderTo = c = q.getElementById(c));\n        c || J(13, !0, this);\n        var l = da(G(c, \"data-highcharts-chart\"));\n        W(l) && H[l] && H[l].hasRendered && H[l].destroy();\n        G(c, \"data-highcharts-chart\", this.index);\n        c.innerHTML = f.emptyHTML;\n        e.skipClone || c.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        l = this.chartWidth;\n        var m = this.chartHeight;\n        L(c, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (g = Y({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: l + \"px\",\n          height: m + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n          userSelect: \"none\",\n          \"touch-action\": \"manipulation\",\n          outline: \"none\"\n        }, e.style || {}));\n        this.container = d = r(\"div\", {\n          id: d\n        }, g, c);\n        this._cursor = d.style.cursor;\n        this.renderer = new (e.renderer || !a ? t.getRendererType(e.renderer) : k)(d, l, m, void 0, e.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);\n        K(void 0, this);\n        this.setClassName(e.className);\n        if (this.styledMode) for (var n in b.defs) this.renderer.definition(b.defs[n]);else this.renderer.setStyle(e.style);\n        this.renderer.chartIndex = this.index;\n        I(this, \"afterGetContainer\");\n      };\n\n      b.prototype.getMargins = function (a) {\n        var b = this.spacing,\n            e = this.margin,\n            d = this.titleOffset;\n        this.resetMargins();\n        d[0] && !Q(e[0]) && (this.plotTop = Math.max(this.plotTop, d[0] + b[0]));\n        d[2] && !Q(e[2]) && (this.marginBottom = Math.max(this.marginBottom, d[2] + b[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(e, b);\n        I(this, \"getMargins\");\n        a || this.getAxisMargins();\n      };\n\n      b.prototype.getAxisMargins = function () {\n        var a = this,\n            b = a.axisOffset = [0, 0, 0, 0],\n            e = a.colorAxis,\n            d = a.margin,\n            g = function (a) {\n          a.forEach(function (a) {\n            a.visible && a.getOffset();\n          });\n        };\n\n        a.hasCartesianSeries ? g(a.axes) : e && e.length && g(e);\n        w.forEach(function (e, g) {\n          Q(d[g]) || (a[e] += b[g]);\n        });\n        a.setChartSize();\n      };\n\n      b.prototype.reflow = function (a) {\n        var b = this,\n            e = b.options.chart,\n            d = b.renderTo,\n            g = Q(e.width) && Q(e.height),\n            f = e.width || aa(d, \"width\");\n        e = e.height || aa(d, \"height\");\n        d = a ? a.target : x;\n        delete b.pointer.chartPosition;\n\n        if (!g && !b.isPrinting && f && e && (d === x || d === q)) {\n          if (f !== b.containerWidth || e !== b.containerHeight) m.clearTimeout(b.reflowTimeout), b.reflowTimeout = Z(function () {\n            b.container && b.setSize(void 0, void 0, !1);\n          }, a ? 100 : 0);\n          b.containerWidth = f;\n          b.containerHeight = e;\n        }\n      };\n\n      b.prototype.setReflow = function (a) {\n        var b = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = g(x, \"resize\", function (a) {\n          b.options && b.reflow(a);\n        }), g(this, \"destroy\", this.unbindReflow));\n      };\n\n      b.prototype.setSize = function (a, b, e) {\n        var g = this,\n            f = g.renderer;\n        g.isResizing += 1;\n        K(e, g);\n        e = f.globalAnimation;\n        g.oldChartHeight = g.chartHeight;\n        g.oldChartWidth = g.chartWidth;\n        \"undefined\" !== typeof a && (g.options.chart.width = a);\n        \"undefined\" !== typeof b && (g.options.chart.height = b);\n        g.getChartSize();\n        g.styledMode || (e ? d : L)(g.container, {\n          width: g.chartWidth + \"px\",\n          height: g.chartHeight + \"px\"\n        }, e);\n        g.setChartSize(!0);\n        f.setSize(g.chartWidth, g.chartHeight, e);\n        g.axes.forEach(function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        g.isDirtyLegend = !0;\n        g.isDirtyBox = !0;\n        g.layOutTitles();\n        g.getMargins();\n        g.redraw(e);\n        g.oldChartHeight = null;\n        I(g, \"resize\");\n        Z(function () {\n          g && I(g, \"endResize\", null, function () {\n            --g.isResizing;\n          });\n        }, v(e).duration);\n      };\n\n      b.prototype.setChartSize = function (a) {\n        var b = this.inverted,\n            e = this.renderer,\n            d = this.chartWidth,\n            g = this.chartHeight,\n            f = this.options.chart,\n            c = this.spacing,\n            l = this.clipOffset,\n            k,\n            r,\n            m,\n            n;\n        this.plotLeft = k = Math.round(this.plotLeft);\n        this.plotTop = r = Math.round(this.plotTop);\n        this.plotWidth = m = Math.max(0, Math.round(d - k - this.marginRight));\n        this.plotHeight = n = Math.max(0, Math.round(g - r - this.marginBottom));\n        this.plotSizeX = b ? n : m;\n        this.plotSizeY = b ? m : n;\n        this.plotBorderWidth = f.plotBorderWidth || 0;\n        this.spacingBox = e.spacingBox = {\n          x: c[3],\n          y: c[0],\n          width: d - c[3] - c[1],\n          height: g - c[0] - c[2]\n        };\n        this.plotBox = e.plotBox = {\n          x: k,\n          y: r,\n          width: m,\n          height: n\n        };\n        b = 2 * Math.floor(this.plotBorderWidth / 2);\n        d = Math.ceil(Math.max(b, l[3]) / 2);\n        g = Math.ceil(Math.max(b, l[0]) / 2);\n        this.clipBox = {\n          x: d,\n          y: g,\n          width: Math.floor(this.plotSizeX - Math.max(b, l[1]) / 2 - d),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(b, l[2]) / 2 - g))\n        };\n        a || (this.axes.forEach(function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        }), e.alignElements());\n        I(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      };\n\n      b.prototype.resetMargins = function () {\n        I(this, \"resetMargins\");\n        var a = this,\n            b = a.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (e) {\n          var d = b[e],\n              g = R(d) ? d : [d, d, d, d];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (d, f) {\n            a[e][f] = T(b[e + d], g[f]);\n          });\n        });\n        w.forEach(function (b, e) {\n          a[b] = T(a.margin[e], a.spacing[e]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      };\n\n      b.prototype.drawChartBox = function () {\n        var a = this.options.chart,\n            b = this.renderer,\n            e = this.chartWidth,\n            d = this.chartHeight,\n            g = this.styledMode,\n            f = this.plotBGImage,\n            c = a.backgroundColor,\n            l = a.plotBackgroundColor,\n            k = a.plotBackgroundImage,\n            r = this.plotLeft,\n            m = this.plotTop,\n            n = this.plotWidth,\n            q = this.plotHeight,\n            u = this.plotBox,\n            x = this.clipRect,\n            v = this.clipBox,\n            z = this.chartBackground,\n            p = this.plotBackground,\n            h = this.plotBorder,\n            C,\n            w = \"animate\";\n        z || (this.chartBackground = z = b.rect().addClass(\"highcharts-background\").add(), w = \"attr\");\n        if (g) var L = C = z.strokeWidth();else {\n          L = a.borderWidth || 0;\n          C = L + (a.shadow ? 8 : 0);\n          c = {\n            fill: c || \"none\"\n          };\n          if (L || z[\"stroke-width\"]) c.stroke = a.borderColor, c[\"stroke-width\"] = L;\n          z.attr(c).shadow(a.shadow);\n        }\n        z[w]({\n          x: C / 2,\n          y: C / 2,\n          width: e - C - L % 2,\n          height: d - C - L % 2,\n          r: a.borderRadius\n        });\n        w = \"animate\";\n        p || (w = \"attr\", this.plotBackground = p = b.rect().addClass(\"highcharts-plot-background\").add());\n        p[w](u);\n        g || (p.attr({\n          fill: l || \"none\"\n        }).shadow(a.plotShadow), k && (f ? (k !== f.attr(\"href\") && f.attr(\"href\", k), f.animate(u)) : this.plotBGImage = b.image(k, r, m, n, q).add()));\n        x ? x.animate({\n          width: v.width,\n          height: v.height\n        }) : this.clipRect = b.clipRect(v);\n        w = \"animate\";\n        h || (w = \"attr\", this.plotBorder = h = b.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        g || h.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        h[w](h.crisp({\n          x: r,\n          y: m,\n          width: n,\n          height: q\n        }, -h.strokeWidth()));\n        this.isDirtyBox = !1;\n        I(this, \"afterDrawChartBox\");\n      };\n\n      b.prototype.propFromSeries = function () {\n        var a = this,\n            b = a.options.chart,\n            e = a.options.series,\n            d,\n            g,\n            f;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (c) {\n          g = l[b.type || b.defaultSeriesType];\n          f = b[c] || g && g.prototype[c];\n\n          for (d = e && e.length; !f && d--;) (g = l[e[d].type]) && g.prototype[c] && (f = !0);\n\n          a[c] = f;\n        });\n      };\n\n      b.prototype.linkSeries = function () {\n        var a = this,\n            b = a.series;\n        b.forEach(function (a) {\n          a.linkedSeries.length = 0;\n        });\n        b.forEach(function (b) {\n          var e = b.options.linkedTo;\n          ba(e) && (e = \":previous\" === e ? a.series[b.index - 1] : a.get(e)) && e.linkedParent !== b && (e.linkedSeries.push(b), b.linkedParent = e, e.enabledDataSorting && b.setDataSortingOptions(), b.visible = T(b.options.visible, e.options.visible, b.visible));\n        });\n        I(this, \"afterLinkSeries\");\n      };\n\n      b.prototype.renderSeries = function () {\n        this.series.forEach(function (a) {\n          a.translate();\n          a.render();\n        });\n      };\n\n      b.prototype.renderLabels = function () {\n        var a = this,\n            b = a.options.labels;\n        b.items && b.items.forEach(function (e) {\n          var d = Y(b.style, e.style),\n              g = da(d.left) + a.plotLeft,\n              f = da(d.top) + a.plotTop + 12;\n          delete d.left;\n          delete d.top;\n          a.renderer.text(e.html, g, f).attr({\n            zIndex: 2\n          }).css(d).add();\n        });\n      };\n\n      b.prototype.render = function () {\n        var a = this.axes,\n            b = this.colorAxis,\n            e = this.renderer,\n            d = this.options,\n            g = function (a) {\n          a.forEach(function (a) {\n            a.visible && a.render();\n          });\n        },\n            f = 0;\n\n        this.setTitle();\n        this.legend = new D(this, d.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        d = this.plotWidth;\n        a.some(function (a) {\n          if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return f = 21, !0;\n        });\n        var c = this.plotHeight = Math.max(this.plotHeight - f, 0);\n        a.forEach(function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        var l = 1.1 < d / this.plotWidth,\n            k = 1.05 < c / this.plotHeight;\n        if (l || k) a.forEach(function (a) {\n          (a.horiz && l || !a.horiz && k) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? g(a) : b && b.length && g(b);\n        this.seriesGroup || (this.seriesGroup = e.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      };\n\n      b.prototype.addCredits = function (a) {\n        var b = this,\n            e = V(!0, this.options.credits, a);\n        e.enabled && !this.credits && (this.credits = this.renderer.text(e.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          e.href && (x.location.href = e.href);\n        }).attr({\n          align: e.position.align,\n          zIndex: 8\n        }), b.styledMode || this.credits.css(e.style), this.credits.add().align(e.position), this.credits.update = function (a) {\n          b.credits = b.credits.destroy();\n          b.addCredits(a);\n        });\n      };\n\n      b.prototype.destroy = function () {\n        var a = this,\n            b = a.axes,\n            e = a.series,\n            d = a.container,\n            g = d && d.parentNode,\n            c;\n        I(a, \"destroy\");\n        a.renderer.forExport ? C(H, a) : H[a.index] = void 0;\n        A.chartCount--;\n        a.renderTo.removeAttribute(\"data-highcharts-chart\");\n        O(a);\n\n        for (c = b.length; c--;) b[c] = b[c].destroy();\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (c = e.length; c--;) e[c] = e[c].destroy();\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (b) {\n          var e = a[b];\n          e && e.destroy && (a[b] = e.destroy());\n        });\n        d && (d.innerHTML = f.emptyHTML, O(d), g && S(d));\n        X(a, function (b, e) {\n          delete a[e];\n        });\n      };\n\n      b.prototype.firstRender = function () {\n        var a = this,\n            b = a.options;\n\n        if (!a.isReadyToRender || a.isReadyToRender()) {\n          a.getContainer();\n          a.resetMargins();\n          a.setChartSize();\n          a.propFromSeries();\n          a.getAxes();\n          (P(b.series) ? b.series : []).forEach(function (b) {\n            a.initSeries(b);\n          });\n          a.linkSeries();\n          a.setSeriesData();\n          I(a, \"beforeRender\");\n          p && (F.isRequired() ? a.pointer = new F(a, b) : a.pointer = new p(a, b));\n          a.render();\n          a.pointer.getChartPosition();\n          if (!a.renderer.imgCount && !a.hasLoaded) a.onload();\n          a.temporaryDisplay(!0);\n        }\n      };\n\n      b.prototype.onload = function () {\n        this.callbacks.concat([this.callback]).forEach(function (a) {\n          a && \"undefined\" !== typeof this.index && a.apply(this, [this]);\n        }, this);\n        I(this, \"load\");\n        I(this, \"render\");\n        Q(this.index) && this.setReflow(this.options.chart.reflow);\n        this.warnIfA11yModuleNotLoaded();\n        this.hasLoaded = !0;\n      };\n\n      b.prototype.warnIfA11yModuleNotLoaded = function () {\n        var a = this.options,\n            b = this.title;\n        a && !this.accessibility && (this.renderer.boxWrapper.attr({\n          role: \"img\",\n          \"aria-label\": b && b.element.textContent || \"\"\n        }), a.accessibility && !1 === a.accessibility.enabled || J('Highcharts warning: Consider including the \"accessibility.js\" module to make your chart more usable for people with disabilities. Set the \"accessibility.enabled\" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));\n      };\n\n      b.prototype.addSeries = function (a, b, e) {\n        var d = this,\n            g;\n        a && (b = T(b, !0), I(d, \"addSeries\", {\n          options: a\n        }, function () {\n          g = d.initSeries(a);\n          d.isDirtyLegend = !0;\n          d.linkSeries();\n          g.enabledDataSorting && g.setData(a.data, !1);\n          I(d, \"afterAddSeries\", {\n            series: g\n          });\n          b && d.redraw(e);\n        }));\n        return g;\n      };\n\n      b.prototype.addAxis = function (a, b, e, d) {\n        return this.createAxis(b ? \"xAxis\" : \"yAxis\", {\n          axis: a,\n          redraw: e,\n          animation: d\n        });\n      };\n\n      b.prototype.addColorAxis = function (a, b, e) {\n        return this.createAxis(\"colorAxis\", {\n          axis: a,\n          redraw: b,\n          animation: e\n        });\n      };\n\n      b.prototype.createAxis = function (a, b) {\n        a = new h(this, V(b.axis, {\n          index: this[a].length,\n          isX: \"xAxis\" === a\n        }));\n        T(b.redraw, !0) && this.redraw(b.animation);\n        return a;\n      };\n\n      b.prototype.showLoading = function (a) {\n        var b = this,\n            e = b.options,\n            c = e.loading,\n            l = function () {\n          k && L(k, {\n            left: b.plotLeft + \"px\",\n            top: b.plotTop + \"px\",\n            width: b.plotWidth + \"px\",\n            height: b.plotHeight + \"px\"\n          });\n        },\n            k = b.loadingDiv,\n            m = b.loadingSpan;\n\n        k || (b.loadingDiv = k = r(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, b.container));\n        m || (b.loadingSpan = m = r(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, k), g(b, \"redraw\", l));\n        k.className = \"highcharts-loading\";\n        f.setElementHTML(m, T(a, e.lang.loading, \"\"));\n        b.styledMode || (L(k, Y(c.style, {\n          zIndex: 10\n        })), L(m, c.labelStyle), b.loadingShown || (L(k, {\n          opacity: 0,\n          display: \"\"\n        }), d(k, {\n          opacity: c.style.opacity || .5\n        }, {\n          duration: c.showDuration || 0\n        })));\n        b.loadingShown = !0;\n        l();\n      };\n\n      b.prototype.hideLoading = function () {\n        var a = this.options,\n            b = this.loadingDiv;\n        b && (b.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || d(b, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function () {\n            L(b, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      };\n\n      b.prototype.update = function (a, b, e, d) {\n        var g = this,\n            f = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\",\n          caption: \"setCaption\"\n        },\n            c = a.isResponsiveOptions,\n            l = [],\n            k,\n            r;\n        I(g, \"update\", {\n          options: a\n        });\n        c || g.setResponsive(!1, !0);\n        a = z(a, g.options);\n        g.userOptions = V(g.userOptions, a);\n        var m = a.chart;\n\n        if (m) {\n          V(!0, g.options.chart, m);\n          \"className\" in m && g.setClassName(m.className);\n          \"reflow\" in m && g.setReflow(m.reflow);\n\n          if (\"inverted\" in m || \"polar\" in m || \"type\" in m) {\n            g.propFromSeries();\n            var q = !0;\n          }\n\n          \"alignTicks\" in m && (q = !0);\n          \"events\" in m && N(this, m);\n          X(m, function (a, b) {\n            -1 !== g.propsRequireUpdateSeries.indexOf(\"chart.\" + b) && (k = !0);\n            -1 !== g.propsRequireDirtyBox.indexOf(b) && (g.isDirtyBox = !0);\n            -1 !== g.propsRequireReflow.indexOf(b) && (c ? g.isDirtyBox = !0 : r = !0);\n          });\n          !g.styledMode && m.style && g.renderer.setStyle(g.options.chart.style || {});\n        }\n\n        !g.styledMode && a.colors && (this.options.colors = a.colors);\n        a.time && (this.time === u && (this.time = new n(a.time)), V(!0, g.options.time, a.time));\n        X(a, function (b, e) {\n          if (g[e] && \"function\" === typeof g[e].update) g[e].update(b, !1);else if (\"function\" === typeof g[f[e]]) g[f[e]](b);else \"colors\" !== e && -1 === g.collectionsWithUpdate.indexOf(e) && V(!0, g.options[e], a[e]);\n          \"chart\" !== e && -1 !== g.propsRequireUpdateSeries.indexOf(e) && (k = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (b) {\n          if (a[b]) {\n            var d = [];\n            g[b].forEach(function (a, b) {\n              a.options.isInternal || d.push(T(a.options.index, b));\n            });\n            ea(a[b]).forEach(function (a, f) {\n              var c = Q(a.id),\n                  l;\n              c && (l = g.get(a.id));\n              !l && g[b] && (l = g[b][d ? d[f] : f]) && c && Q(l.options.id) && (l = void 0);\n              l && l.coll === b && (l.update(a, !1), e && (l.touched = !0));\n              !l && e && g.collectionsWithInit[b] && (g.collectionsWithInit[b][0].apply(g, [a].concat(g.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);\n            });\n            e && g[b].forEach(function (a) {\n              a.touched || a.options.isInternal ? delete a.touched : l.push(a);\n            });\n          }\n        });\n        l.forEach(function (a) {\n          a.chart && a.remove && a.remove(!1);\n        });\n        q && g.axes.forEach(function (a) {\n          a.update({}, !1);\n        });\n        k && g.getSeriesOrderByLinks().forEach(function (a) {\n          a.chart && a.update({}, !1);\n        }, this);\n        q = m && m.width;\n        m = m && (ba(m.height) ? ha(m.height, q || g.chartWidth) : m.height);\n        r || W(q) && q !== g.chartWidth || W(m) && m !== g.chartHeight ? g.setSize(q, m, d) : T(b, !0) && g.redraw(d);\n        I(g, \"afterUpdate\", {\n          options: a,\n          redraw: b,\n          animation: d\n        });\n      };\n\n      b.prototype.setSubtitle = function (a, b) {\n        this.applyDescription(\"subtitle\", a);\n        this.layOutTitles(b);\n      };\n\n      b.prototype.setCaption = function (a, b) {\n        this.applyDescription(\"caption\", a);\n        this.layOutTitles(b);\n      };\n\n      b.prototype.showResetZoom = function () {\n        function a() {\n          b.zoomOut();\n        }\n\n        var b = this,\n            g = e.lang,\n            d = b.options.chart.zooming.resetButton,\n            f = d.theme,\n            c = \"chart\" === d.relativeTo || \"spacingBox\" === d.relativeTo ? null : \"scrollablePlotBox\";\n        I(this, \"beforeShowResetZoom\", null, function () {\n          b.resetZoomButton = b.renderer.button(g.resetZoom, null, null, a, f).attr({\n            align: d.position.align,\n            title: g.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(d.position, !1, c);\n        });\n        I(this, \"afterShowResetZoom\");\n      };\n\n      b.prototype.zoomOut = function () {\n        I(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      };\n\n      b.prototype.zoom = function (a) {\n        var b = this,\n            e = b.pointer,\n            g = b.inverted ? e.mouseDownX : e.mouseDownY,\n            d = !1,\n            f;\n        !a || a.resetSelection ? (b.axes.forEach(function (a) {\n          f = a.zoom();\n        }), e.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {\n          var c = a.axis,\n              l = b.inverted ? c.left : c.top,\n              k = b.inverted ? l + c.width : l + c.height,\n              r = c.isXAxis,\n              m = !1;\n          if (!r && g >= l && g <= k || r || !Q(g)) m = !0;\n          e[r ? \"zoomX\" : \"zoomY\"] && m && (f = c.zoom(a.min, a.max), c.displayBtn && (d = !0));\n        });\n        var c = b.resetZoomButton;\n        d && !c ? b.showResetZoom() : !d && R(c) && (b.resetZoomButton = c.destroy());\n        f && b.redraw(T(b.options.chart.animation, a && a.animation, 100 > b.pointCount));\n      };\n\n      b.prototype.pan = function (a, b) {\n        var e = this,\n            g = e.hoverPoints;\n        b = \"object\" === typeof b ? b : {\n          enabled: b,\n          type: \"x\"\n        };\n        var d = e.options.chart;\n        d && d.panning && (d.panning = b);\n        var f = b.type,\n            c;\n        I(this, \"pan\", {\n          originalEvent: a\n        }, function () {\n          g && g.forEach(function (a) {\n            a.setState();\n          });\n          var b = e.xAxis;\n          \"xy\" === f ? b = b.concat(e.yAxis) : \"y\" === f && (b = e.yAxis);\n          var d = {};\n          b.forEach(function (b) {\n            if (b.options.panningEnabled && !b.options.isInternal) {\n              var g = b.horiz,\n                  l = a[g ? \"chartX\" : \"chartY\"];\n              g = g ? \"mouseDownX\" : \"mouseDownY\";\n              var k = e[g],\n                  r = b.minPointOffset || 0,\n                  m = b.reversed && !e.inverted || !b.reversed && e.inverted ? -1 : 1,\n                  n = b.getExtremes(),\n                  q = b.toValue(k - l, !0) + r * m,\n                  u = b.toValue(k + b.len - l, !0) - (r * m || b.isXAxis && b.pointRangePadding || 0),\n                  x = u < q;\n              m = b.hasVerticalPanning();\n              k = x ? u : q;\n              q = x ? q : u;\n              var z = b.panningState;\n              !m || b.isXAxis || z && !z.isDirty || b.series.forEach(function (a) {\n                var b = a.getProcessedData(!0);\n                b = a.getExtremes(b.yData, !0);\n                z || (z = {\n                  startMin: Number.MAX_VALUE,\n                  startMax: -Number.MAX_VALUE\n                });\n                W(b.dataMin) && W(b.dataMax) && (z.startMin = Math.min(T(a.options.threshold, Infinity), b.dataMin, z.startMin), z.startMax = Math.max(T(a.options.threshold, -Infinity), b.dataMax, z.startMax));\n              });\n              m = Math.min(T(z && z.startMin, n.dataMin), r ? n.min : b.toValue(b.toPixels(n.min) - b.minPixelPadding));\n              u = Math.max(T(z && z.startMax, n.dataMax), r ? n.max : b.toValue(b.toPixels(n.max) + b.minPixelPadding));\n              b.panningState = z;\n              b.isOrdinal || (r = m - k, 0 < r && (q += r, k = m), r = q - u, 0 < r && (q = u, k -= r), b.series.length && k !== n.min && q !== n.max && k >= m && q <= u && (b.setExtremes(k, q, !1, !1, {\n                trigger: \"pan\"\n              }), !e.resetZoomButton && k !== m && q !== u && f.match(\"y\") && (e.showResetZoom(), b.displayBtn = !1), c = !0), d[g] = l);\n            }\n          });\n          X(d, function (a, b) {\n            e[b] = a;\n          });\n          c && e.redraw(!1);\n          L(e.container, {\n            cursor: \"move\"\n          });\n        });\n      };\n\n      return b;\n    }();\n\n    Y(c.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [c.prototype.addAxis, [!0]],\n        yAxis: [c.prototype.addAxis, [!1]],\n        series: [c.prototype.addSeries]\n      },\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"series\"],\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \")\n    });\n    \"\";\n    return c;\n  });\n  O(h, \"Core/Legend/LegendSymbol.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    var h = c.merge,\n        B = c.pick,\n        E;\n\n    (function (c) {\n      c.drawLineMarker = function (c) {\n        var F = this.options,\n            y = c.symbolWidth,\n            p = c.symbolHeight,\n            t = p / 2,\n            b = this.chart.renderer,\n            k = this.legendGroup;\n        c = c.baseline - Math.round(.3 * c.fontMetrics.b);\n        var n = {},\n            m = F.marker;\n        this.chart.styledMode || (n = {\n          \"stroke-width\": F.lineWidth || 0\n        }, F.dashStyle && (n.dashstyle = F.dashStyle));\n        this.legendLine = b.path([[\"M\", 0, c], [\"L\", y, c]]).addClass(\"highcharts-graph\").attr(n).add(k);\n        m && !1 !== m.enabled && y && (F = Math.min(B(m.radius, t), t), 0 === this.symbol.indexOf(\"url\") && (m = h(m, {\n          width: p,\n          height: p\n        }), F = 0), this.legendSymbol = y = b.symbol(this.symbol, y / 2 - F, c - F, 2 * F, 2 * F, m).addClass(\"highcharts-point\").add(k), y.isMarker = !0);\n      };\n\n      c.drawRectangle = function (c, h) {\n        var y = c.symbolHeight,\n            p = c.options.squareSymbol;\n        h.legendSymbol = this.chart.renderer.rect(p ? (c.symbolWidth - y) / 2 : 0, c.baseline - y + 1, p ? y : c.symbolWidth, y, B(c.options.symbolRadius, y / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(h.legendGroup);\n      };\n    })(E || (E = {}));\n\n    return E;\n  });\n  O(h, \"Core/Series/SeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        defer: !0,\n        formatter: function () {\n          var c = this.series.chart.numberFormatter;\n          return \"number\" !== typeof this.y ? \"\" : c(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 50\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    };\n  });\n  O(h, \"Core/Series/Series.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Foundation.js\"], h[\"Core/Globals.js\"], h[\"Core/Legend/LegendSymbol.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Series/SeriesDefaults.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A, D, F, y, p, t) {\n    var b = c.animObject,\n        k = c.setAnimation,\n        n = h.defaultOptions,\n        m = B.registerEventOptions,\n        f = E.hasTouch,\n        d = E.svg,\n        v = E.win,\n        K = y.seriesTypes,\n        M = t.addEvent,\n        N = t.arrayMax,\n        H = t.arrayMin,\n        q = t.clamp,\n        w = t.cleanRecursively,\n        a = t.correctFloat,\n        x = t.defined,\n        e = t.erase,\n        u = t.error,\n        l = t.extend,\n        g = t.find,\n        G = t.fireEvent,\n        z = t.getNestedProperty,\n        r = t.isArray,\n        L = t.isNumber,\n        Q = t.isString,\n        S = t.merge,\n        C = t.objectEach,\n        J = t.pick,\n        Y = t.removeEvent,\n        I = t.splat,\n        fa = t.syncTimeout;\n\n    c = function () {\n      function c() {\n        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;\n      }\n\n      c.prototype.init = function (a, b) {\n        G(this, \"init\", {\n          options: b\n        });\n        var e = this,\n            g = a.series;\n        this.eventsToUnbind = [];\n        e.chart = a;\n        e.options = e.setOptions(b);\n        b = e.options;\n        e.linkedSeries = [];\n        e.bindAxes();\n        l(e, {\n          name: b.name,\n          state: \"\",\n          visible: !1 !== b.visible,\n          selected: !0 === b.selected\n        });\n        m(this, b);\n        var d = b.events;\n        if (d && d.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;\n        e.getColor();\n        e.getSymbol();\n        e.parallelArrays.forEach(function (a) {\n          e[a + \"Data\"] || (e[a + \"Data\"] = []);\n        });\n        e.isCartesian && (a.hasCartesianSeries = !0);\n        var f;\n        g.length && (f = g[g.length - 1]);\n        e._i = J(f && f._i, -1) + 1;\n        e.opacity = e.options.opacity;\n        a.orderSeries(this.insert(g));\n        b.dataSorting && b.dataSorting.enabled ? e.setDataSortingOptions() : e.points || e.data || e.setData(b.data, !1);\n        G(this, \"afterInit\");\n      };\n\n      c.prototype.is = function (a) {\n        return K[a] && this instanceof K[a];\n      };\n\n      c.prototype.insert = function (a) {\n        var b = this.options.index,\n            e;\n\n        if (L(b)) {\n          for (e = a.length; e--;) if (b >= J(a[e].options.index, a[e]._i)) {\n            a.splice(e + 1, 0, this);\n            break;\n          }\n\n          -1 === e && a.unshift(this);\n          e += 1;\n        } else a.push(this);\n\n        return J(e, a.length - 1);\n      };\n\n      c.prototype.bindAxes = function () {\n        var a = this,\n            b = a.options,\n            e = a.chart,\n            g;\n        G(this, \"bindAxes\", null, function () {\n          (a.axisTypes || []).forEach(function (d) {\n            var f = 0;\n            e[d].forEach(function (e) {\n              g = e.options;\n              if (b[d] === f && !g.isInternal || \"undefined\" !== typeof b[d] && b[d] === g.id || \"undefined\" === typeof b[d] && 0 === g.index) a.insert(e.series), a[d] = e, e.isDirty = !0;\n              g.isInternal || f++;\n            });\n            a[d] || a.optionalAxis === d || u(18, !0, e);\n          });\n        });\n        G(this, \"afterBindAxes\");\n      };\n\n      c.prototype.updateParallelArrays = function (a, b) {\n        var e = a.series,\n            g = arguments,\n            d = L(b) ? function (g) {\n          var d = \"y\" === g && e.toYData ? e.toYData(a) : a[g];\n          e[g + \"Data\"][b] = d;\n        } : function (a) {\n          Array.prototype[b].apply(e[a + \"Data\"], Array.prototype.slice.call(g, 2));\n        };\n        e.parallelArrays.forEach(d);\n      };\n\n      c.prototype.hasData = function () {\n        return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      };\n\n      c.prototype.autoIncrement = function (a) {\n        var b = this.options,\n            e = b.pointIntervalUnit,\n            g = b.relativeXValue,\n            d = this.chart.time,\n            f = this.xIncrement,\n            c;\n        f = J(f, b.pointStart, 0);\n        this.pointInterval = c = J(this.pointInterval, b.pointInterval, 1);\n        g && L(a) && (c *= a);\n        e && (b = new d.Date(f), \"day\" === e ? d.set(\"Date\", b, d.get(\"Date\", b) + c) : \"month\" === e ? d.set(\"Month\", b, d.get(\"Month\", b) + c) : \"year\" === e && d.set(\"FullYear\", b, d.get(\"FullYear\", b) + c), c = b.getTime() - f);\n        if (g && L(a)) return f + c;\n        this.xIncrement = f + c;\n        return f;\n      };\n\n      c.prototype.setDataSortingOptions = function () {\n        var a = this.options;\n        l(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        });\n        x(a.pointRange) || (a.pointRange = 1);\n      };\n\n      c.prototype.setOptions = function (a) {\n        var b = this.chart,\n            e = b.options,\n            g = e.plotOptions,\n            d = b.userOptions || {};\n        a = S(a);\n        b = b.styledMode;\n        var f = {\n          plotOptions: g,\n          userOptions: a\n        };\n        G(this, \"setOptions\", f);\n        var c = f.plotOptions[this.type],\n            l = d.plotOptions || {};\n        this.userOptions = f.userOptions;\n        d = S(c, g.series, d.plotOptions && d.plotOptions[this.type], a);\n        this.tooltipOptions = S(n.tooltip, n.plotOptions.series && n.plotOptions.series.tooltip, n.plotOptions[this.type].tooltip, e.tooltip.userOptions, g.series && g.series.tooltip, g[this.type].tooltip, a.tooltip);\n        this.stickyTracking = J(a.stickyTracking, l[this.type] && l[this.type].stickyTracking, l.series && l.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : d.stickyTracking);\n        null === c.marker && delete d.marker;\n        this.zoneAxis = d.zoneAxis;\n        g = this.zones = (d.zones || []).slice();\n        !d.negativeColor && !d.negativeFillColor || d.zones || (e = {\n          value: d[this.zoneAxis + \"Threshold\"] || d.threshold || 0,\n          className: \"highcharts-negative\"\n        }, b || (e.color = d.negativeColor, e.fillColor = d.negativeFillColor), g.push(e));\n        g.length && x(g[g.length - 1].value) && g.push(b ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        G(this, \"afterSetOptions\", {\n          options: d\n        });\n        return d;\n      };\n\n      c.prototype.getName = function () {\n        return J(this.options.name, \"Series \" + (this.index + 1));\n      };\n\n      c.prototype.getCyclic = function (a, b, e) {\n        var d = this.chart,\n            g = this.userOptions,\n            f = a + \"Index\",\n            c = a + \"Counter\",\n            l = e ? e.length : J(d.options.chart[a + \"Count\"], d[a + \"Count\"]);\n\n        if (!b) {\n          var k = J(g[f], g[\"_\" + f]);\n          x(k) || (d.series.length || (d[c] = 0), g[\"_\" + f] = k = d[c] % l, d[c] += 1);\n          e && (b = e[k]);\n        }\n\n        \"undefined\" !== typeof k && (this[f] = k);\n        this[a] = b;\n      };\n\n      c.prototype.getColor = function () {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || n.plotOptions[this.type].color, this.chart.options.colors);\n      };\n\n      c.prototype.getPointsCollection = function () {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      };\n\n      c.prototype.getSymbol = function () {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      };\n\n      c.prototype.findPointIndex = function (a, b) {\n        var e = a.id,\n            d = a.x,\n            f = this.points,\n            c = this.options.dataSorting,\n            l,\n            k;\n        if (e) c = this.chart.get(e), c instanceof D && (l = c);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (l = function (b) {\n          return !b.touched && b.index === a.index;\n        }, c && c.matchByName ? l = function (b) {\n          return !b.touched && b.name === a.name;\n        } : this.options.relativeXValue && (l = function (b) {\n          return !b.touched && b.options.x === a.x;\n        }), l = g(f, l), !l) return;\n\n        if (l) {\n          var r = l && l.index;\n          \"undefined\" !== typeof r && (k = !0);\n        }\n\n        \"undefined\" === typeof r && L(d) && (r = this.xData.indexOf(d, b));\n        -1 !== r && \"undefined\" !== typeof r && this.cropped && (r = r >= this.cropStart ? r - this.cropStart : r);\n        !k && L(r) && f[r] && f[r].touched && (r = void 0);\n        return r;\n      };\n\n      c.prototype.updateData = function (a, b) {\n        var e = this.options,\n            d = e.dataSorting,\n            g = this.points,\n            f = [],\n            c = this.requireSorting,\n            l = a.length === g.length,\n            k,\n            r,\n            m,\n            n = !0;\n        this.xIncrement = null;\n        a.forEach(function (a, b) {\n          var r = x(a) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, a) || {},\n              n = r.x;\n\n          if (r.id || L(n)) {\n            if (r = this.findPointIndex(r, m), -1 === r || \"undefined\" === typeof r ? f.push(a) : g[r] && a !== e.data[r] ? (g[r].update(a, !1, null, !1), g[r].touched = !0, c && (m = r + 1)) : g[r] && (g[r].touched = !0), !l || b !== r || d && d.enabled || this.hasDerivedData) k = !0;\n          } else f.push(a);\n        }, this);\n        if (k) for (a = g.length; a--;) (r = g[a]) && !r.touched && r.remove && r.remove(!1, b);else !l || d && d.enabled ? n = !1 : (a.forEach(function (a, b) {\n          a !== g[b].y && g[b].update && g[b].update(a, !1, null, !1);\n        }), f.length = 0);\n        g.forEach(function (a) {\n          a && (a.touched = !1);\n        });\n        if (!n) return !1;\n        f.forEach(function (a) {\n          this.addPoint(a, !1, null, null, !1);\n        }, this);\n        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = N(this.xData), this.autoIncrement());\n        return !0;\n      };\n\n      c.prototype.setData = function (a, b, e, d) {\n        void 0 === b && (b = !0);\n        var g = this,\n            f = g.points,\n            c = f && f.length || 0,\n            l = g.options,\n            k = g.chart,\n            m = l.dataSorting,\n            n = g.xAxis,\n            q = l.turboThreshold,\n            x = this.xData,\n            z = this.yData,\n            v = g.pointArrayMap;\n        v = v && v.length;\n        var h = l.keys,\n            C,\n            p = 0,\n            w = 1,\n            G = null;\n\n        if (!k.options.chart.allowMutatingData) {\n          l.data && delete g.options.data;\n          g.userOptions.data && delete g.userOptions.data;\n          var t = S(!0, a);\n        }\n\n        a = t || a || [];\n        t = a.length;\n        m && m.enabled && (a = this.sortData(a));\n        k.options.chart.allowMutatingData && !1 !== d && t && c && !g.cropped && !g.hasGroupedData && g.visible && !g.boosted && (C = this.updateData(a, e));\n\n        if (!C) {\n          g.xIncrement = null;\n          g.colorCounter = 0;\n          this.parallelArrays.forEach(function (a) {\n            g[a + \"Data\"].length = 0;\n          });\n          if (q && t > q) {\n            if (G = g.getFirstValidPoint(a), L(G)) for (e = 0; e < t; e++) x[e] = this.autoIncrement(), z[e] = a[e];else if (r(G)) {\n              if (v) {\n                if (G.length === v) for (e = 0; e < t; e++) x[e] = this.autoIncrement(), z[e] = a[e];else for (e = 0; e < t; e++) d = a[e], x[e] = d[0], z[e] = d.slice(1, v + 1);\n              } else if (h && (p = h.indexOf(\"x\"), w = h.indexOf(\"y\"), p = 0 <= p ? p : 0, w = 0 <= w ? w : 1), 1 === G.length && (w = 0), p === w) for (e = 0; e < t; e++) x[e] = this.autoIncrement(), z[e] = a[e][w];else for (e = 0; e < t; e++) d = a[e], x[e] = d[p], z[e] = d[w];\n            } else u(12, !1, k);\n          } else for (e = 0; e < t; e++) \"undefined\" !== typeof a[e] && (d = {\n            series: g\n          }, g.pointClass.prototype.applyOptions.apply(d, [a[e]]), g.updateParallelArrays(d, e));\n          z && Q(z[0]) && u(14, !0, k);\n          g.data = [];\n          g.options.data = g.userOptions.data = a;\n\n          for (e = c; e--;) f[e] && f[e].destroy && f[e].destroy();\n\n          n && (n.minRange = n.userMinRange);\n          g.isDirty = k.isDirtyBox = !0;\n          g.isDirtyData = !!f;\n          e = !1;\n        }\n\n        \"point\" === l.legendType && (this.processData(), this.generatePoints());\n        b && k.redraw(e);\n      };\n\n      c.prototype.sortData = function (a) {\n        var b = this,\n            e = b.options.dataSorting.sortKey || \"y\",\n            g = function (a, b) {\n          return x(b) && a.pointClass.prototype.optionsToObject.call({\n            series: a\n          }, b) || {};\n        };\n\n        a.forEach(function (e, d) {\n          a[d] = g(b, e);\n          a[d].index = d;\n        }, this);\n        a.concat().sort(function (a, b) {\n          a = z(e, a);\n          b = z(e, b);\n          return b < a ? -1 : b > a ? 1 : 0;\n        }).forEach(function (a, b) {\n          a.x = b;\n        }, this);\n        b.linkedSeries && b.linkedSeries.forEach(function (b) {\n          var e = b.options,\n              d = e.data;\n          e.dataSorting && e.dataSorting.enabled || !d || (d.forEach(function (e, f) {\n            d[f] = g(b, e);\n            a[f] && (d[f].x = a[f].x, d[f].index = f);\n          }), b.setData(d, !1));\n        });\n        return a;\n      };\n\n      c.prototype.getProcessedData = function (a) {\n        var b = this.xAxis,\n            e = this.options,\n            g = e.cropThreshold,\n            d = a || this.getExtremesFromAll || e.getExtremesFromAll,\n            f = this.isCartesian;\n        a = b && b.val2lin;\n        e = !(!b || !b.logarithmic);\n        var c = 0,\n            l = this.xData,\n            k = this.yData,\n            r = this.requireSorting;\n        var m = !1;\n        var n = l.length;\n\n        if (b) {\n          m = b.getExtremes();\n          var q = m.min;\n          var x = m.max;\n          m = !(!b.categories || b.names.length);\n        }\n\n        if (f && this.sorted && !d && (!g || n > g || this.forceCrop)) if (l[n - 1] < q || l[0] > x) l = [], k = [];else if (this.yData && (l[0] < q || l[n - 1] > x)) {\n          var z = this.cropData(this.xData, this.yData, q, x);\n          l = z.xData;\n          k = z.yData;\n          c = z.start;\n          z = !0;\n        }\n\n        for (g = l.length || 1; --g;) if (b = e ? a(l[g]) - a(l[g - 1]) : l[g] - l[g - 1], 0 < b && (\"undefined\" === typeof v || b < v)) var v = b;else 0 > b && r && !m && (u(15, !1, this.chart), r = !1);\n\n        return {\n          xData: l,\n          yData: k,\n          cropped: z,\n          cropStart: c,\n          closestPointRange: v\n        };\n      };\n\n      c.prototype.processData = function (a) {\n        var b = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !b.isDirty && !this.yAxis.isDirty && !a) return !1;\n        a = this.getProcessedData();\n        this.cropped = a.cropped;\n        this.cropStart = a.cropStart;\n        this.processedXData = a.xData;\n        this.processedYData = a.yData;\n        this.closestPointRange = this.basePointRange = a.closestPointRange;\n        G(this, \"afterProcessData\");\n      };\n\n      c.prototype.cropData = function (a, b, e, g, d) {\n        var f = a.length,\n            c,\n            l = 0,\n            k = f;\n        d = J(d, this.cropShoulder);\n\n        for (c = 0; c < f; c++) if (a[c] >= e) {\n          l = Math.max(0, c - d);\n          break;\n        }\n\n        for (e = c; e < f; e++) if (a[e] > g) {\n          k = e + d;\n          break;\n        }\n\n        return {\n          xData: a.slice(l, k),\n          yData: b.slice(l, k),\n          start: l,\n          end: k\n        };\n      };\n\n      c.prototype.generatePoints = function () {\n        var a = this.options,\n            b = this.processedData || a.data,\n            e = this.processedXData,\n            g = this.processedYData,\n            d = this.pointClass,\n            f = e.length,\n            c = this.cropStart || 0,\n            k = this.hasGroupedData,\n            r = a.keys,\n            m = [];\n        a = a.dataGrouping && a.dataGrouping.groupAll ? c : 0;\n        var n,\n            q,\n            u = this.data;\n\n        if (!u && !k) {\n          var z = [];\n          z.length = b.length;\n          u = this.data = z;\n        }\n\n        r && k && (this.options.keys = !1);\n\n        for (q = 0; q < f; q++) {\n          z = c + q;\n\n          if (k) {\n            var x = new d().init(this, [e[q]].concat(I(g[q])));\n            x.dataGroup = this.groupMap[a + q];\n            x.dataGroup.options && (x.options = x.dataGroup.options, l(x, x.dataGroup.options), delete x.dataLabels);\n          } else (x = u[z]) || \"undefined\" === typeof b[z] || (u[z] = x = new d().init(this, b[z], e[q]));\n\n          x && (x.index = k ? a + q : z, m[q] = x);\n        }\n\n        this.options.keys = r;\n        if (u && (f !== (n = u.length) || k)) for (q = 0; q < n; q++) q !== c || k || (q += f), u[q] && (u[q].destroyElements(), u[q].plotX = void 0);\n        this.data = u;\n        this.points = m;\n        G(this, \"afterGeneratePoints\");\n      };\n\n      c.prototype.getXExtremes = function (a) {\n        return {\n          min: H(a),\n          max: N(a)\n        };\n      };\n\n      c.prototype.getExtremes = function (a, b) {\n        var e = this.xAxis,\n            g = this.yAxis,\n            d = this.processedXData || this.xData,\n            f = [],\n            c = this.requireSorting ? this.cropShoulder : 0;\n        g = g ? g.positiveValuesOnly : !1;\n        var l,\n            k = 0,\n            m = 0,\n            n = 0;\n        a = a || this.stackedYData || this.processedYData || [];\n        var q = a.length;\n\n        if (e) {\n          var u = e.getExtremes();\n          k = u.min;\n          m = u.max;\n        }\n\n        for (l = 0; l < q; l++) {\n          var x = d[l];\n          u = a[l];\n          var z = (L(u) || r(u)) && (u.length || 0 < u || !g);\n          x = b || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !e || (d[l + c] || x) >= k && (d[l - c] || x) <= m;\n          if (z && x) if (z = u.length) for (; z--;) L(u[z]) && (f[n++] = u[z]);else f[n++] = u;\n        }\n\n        a = {\n          activeYData: f,\n          dataMin: H(f),\n          dataMax: N(f)\n        };\n        G(this, \"afterGetExtremes\", {\n          dataExtremes: a\n        });\n        return a;\n      };\n\n      c.prototype.applyExtremes = function () {\n        var a = this.getExtremes();\n        this.dataMin = a.dataMin;\n        this.dataMax = a.dataMax;\n        return a;\n      };\n\n      c.prototype.getFirstValidPoint = function (a) {\n        for (var b = a.length, e = 0, g = null; null === g && e < b;) g = a[e], e++;\n\n        return g;\n      };\n\n      c.prototype.translate = function () {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var b = this.options,\n            e = b.stacking,\n            g = this.xAxis,\n            d = g.categories,\n            f = this.enabledDataSorting,\n            c = this.yAxis,\n            l = this.points,\n            k = l.length,\n            m = this.pointPlacementToXValue(),\n            n = !!m,\n            u = b.threshold,\n            z = b.startFromThreshold ? u : 0,\n            v = this.zoneAxis || \"y\",\n            h,\n            p,\n            C = Number.MAX_VALUE;\n\n        for (h = 0; h < k; h++) {\n          var w = l[h],\n              t = w.x,\n              H = void 0,\n              K = void 0,\n              Q = w.y,\n              y = w.low,\n              S = e && c.stacking && c.stacking.stacks[(this.negStacks && Q < (z ? 0 : u) ? \"-\" : \"\") + this.stackKey];\n          if (c.positiveValuesOnly && !c.validatePositiveValue(Q) || g.positiveValuesOnly && !g.validatePositiveValue(t)) w.isNull = !0;\n          w.plotX = p = a(q(g.translate(t, 0, 0, 0, 1, m, \"flags\" === this.type), -1E5, 1E5));\n\n          if (e && this.visible && S && S[t]) {\n            var M = this.getStackIndicator(M, t, this.index);\n            w.isNull || (H = S[t], K = H.points[M.key]);\n          }\n\n          r(K) && (y = K[0], Q = K[1], y === z && M.key === S[t].base && (y = J(L(u) && u, c.min)), c.positiveValuesOnly && 0 >= y && (y = null), w.total = w.stackTotal = H.total, w.percentage = H.total && w.y / H.total * 100, w.stackY = Q, this.irregularWidths || H.setOffset(this.pointXOffset || 0, this.barW || 0));\n          w.yBottom = x(y) ? q(c.translate(y, 0, 1, 0, 1), -1E5, 1E5) : null;\n          this.dataModify && (Q = this.dataModify.modifyValue(Q, h));\n          w.plotY = void 0;\n          L(Q) && (H = c.translate(Q, !1, !0, !1, !0), \"undefined\" !== typeof H && (w.plotY = q(H, -1E5, 1E5)));\n          w.isInside = this.isPointInside(w);\n          w.clientX = n ? a(g.translate(t, 0, 0, 0, 1, m)) : p;\n          w.negative = w[v] < (b[v + \"Threshold\"] || u || 0);\n          w.category = J(d && d[w.x], w.x);\n\n          if (!w.isNull && !1 !== w.visible) {\n            \"undefined\" !== typeof F && (C = Math.min(C, Math.abs(p - F)));\n            var F = p;\n          }\n\n          w.zone = this.zones.length ? w.getZone() : void 0;\n          !w.graphic && this.group && f && (w.isNew = !0);\n        }\n\n        this.closestPointRangePx = C;\n        G(this, \"afterTranslate\");\n      };\n\n      c.prototype.getValidPoints = function (a, b, e) {\n        var g = this.chart;\n        return (a || this.points || []).filter(function (a) {\n          return b && !g.isInsidePlot(a.plotX, a.plotY, {\n            inverted: g.inverted\n          }) ? !1 : !1 !== a.visible && (e || !a.isNull);\n        });\n      };\n\n      c.prototype.getClipBox = function () {\n        var a = this.chart,\n            b = this.xAxis,\n            e = this.yAxis,\n            g = S(a.clipBox);\n        b && b.len !== a.plotSizeX && (g.width = b.len);\n        e && e.len !== a.plotSizeY && (g.height = e.len);\n        return g;\n      };\n\n      c.prototype.getSharedClipKey = function () {\n        return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0);\n      };\n\n      c.prototype.setClip = function () {\n        var a = this.chart,\n            b = this.group,\n            e = this.markerGroup,\n            g = a.sharedClips;\n        a = a.renderer;\n        var d = this.getClipBox(),\n            f = this.getSharedClipKey(),\n            c = g[f];\n        c ? c.animate(d) : g[f] = c = a.clipRect(d);\n        b && b.clip(!1 === this.options.clip ? void 0 : c);\n        e && e.clip();\n      };\n\n      c.prototype.animate = function (a) {\n        var e = this.chart,\n            g = this.group,\n            d = this.markerGroup,\n            f = e.inverted,\n            c = b(this.options.animation),\n            l = [this.getSharedClipKey(), c.duration, c.easing, c.defer].join(),\n            k = e.sharedClips[l],\n            r = e.sharedClips[l + \"m\"];\n        if (a && g) c = this.getClipBox(), k ? k.attr(\"height\", c.height) : (c.width = 0, f && (c.x = e.plotHeight), k = e.renderer.clipRect(c), e.sharedClips[l] = k, r = e.renderer.clipRect({\n          x: f ? (e.plotSizeX || 0) + 99 : -99,\n          y: f ? -e.plotLeft : -e.plotTop,\n          width: 99,\n          height: f ? e.chartWidth : e.chartHeight\n        }), e.sharedClips[l + \"m\"] = r), g.clip(k), d && d.clip(r);else if (k && !k.hasClass(\"highcharts-animating\")) {\n          e = this.getClipBox();\n          var m = c.step;\n          d && d.element.childNodes.length && (c.step = function (a, b) {\n            m && m.apply(b, arguments);\n            r && r.element && r.attr(b.prop, \"width\" === b.prop ? a + 99 : a);\n          });\n          k.addClass(\"highcharts-animating\").animate(e, c);\n        }\n      };\n\n      c.prototype.afterAnimate = function () {\n        var a = this;\n        this.setClip();\n        C(this.chart.sharedClips, function (b, e, g) {\n          b && !a.chart.container.querySelector('[clip-path=\"url(#'.concat(b.id, ')\"]')) && (b.destroy(), delete g[e]);\n        });\n        this.finishedAnimating = !0;\n        G(this, \"afterAnimate\");\n      };\n\n      c.prototype.drawPoints = function () {\n        var a = this.points,\n            b = this.chart,\n            e = this.options.marker,\n            g = this[this.specialGroup] || this.markerGroup,\n            d = this.xAxis,\n            f = J(e.enabled, !d || d.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius),\n            c,\n            l;\n        if (!1 !== e.enabled || this._hasPointMarkers) for (c = 0; c < a.length; c++) {\n          var k = a[c];\n          var r = (l = k.graphic) ? \"animate\" : \"attr\";\n          var m = k.marker || {};\n          var n = !!k.marker;\n\n          if ((f && \"undefined\" === typeof m.enabled || m.enabled) && !k.isNull && !1 !== k.visible) {\n            var q = J(m.symbol, this.symbol, \"rect\");\n            var u = this.markerAttribs(k, k.selected && \"select\");\n            this.enabledDataSorting && (k.startXPos = d.reversed ? -(u.width || 0) : d.width);\n            var z = !1 !== k.isInside;\n            l ? l[z ? \"show\" : \"hide\"](z).animate(u) : z && (0 < (u.width || 0) || k.hasImage) && (k.graphic = l = b.renderer.symbol(q, u.x, u.y, u.width, u.height, n ? m : e).add(g), this.enabledDataSorting && b.hasRendered && (l.attr({\n              x: k.startXPos\n            }), r = \"animate\"));\n            l && \"animate\" === r && l[z ? \"show\" : \"hide\"](z).animate(u);\n            if (l && !b.styledMode) l[r](this.pointAttribs(k, k.selected && \"select\"));\n            l && l.addClass(k.getClassName(), !0);\n          } else l && (k.graphic = l.destroy());\n        }\n      };\n\n      c.prototype.markerAttribs = function (a, b) {\n        var e = this.options,\n            g = e.marker,\n            d = a.marker || {},\n            f = d.symbol || g.symbol,\n            c = J(d.radius, g && g.radius);\n        b && (g = g.states[b], b = d.states && d.states[b], c = J(b && b.radius, g && g.radius, c && c + (g && g.radiusPlus || 0)));\n        a.hasImage = f && 0 === f.indexOf(\"url\");\n        a.hasImage && (c = 0);\n        a = L(c) ? {\n          x: e.crisp ? Math.floor(a.plotX - c) : a.plotX - c,\n          y: a.plotY - c\n        } : {};\n        c && (a.width = a.height = 2 * c);\n        return a;\n      };\n\n      c.prototype.pointAttribs = function (a, b) {\n        var e = this.options.marker,\n            g = a && a.options,\n            d = g && g.marker || {},\n            f = g && g.color,\n            c = a && a.color,\n            l = a && a.zone && a.zone.color,\n            k = this.color;\n        a = J(d.lineWidth, e.lineWidth);\n        g = 1;\n        k = f || l || c || k;\n        f = d.fillColor || e.fillColor || k;\n        c = d.lineColor || e.lineColor || k;\n        b = b || \"normal\";\n        e = e.states[b] || {};\n        b = d.states && d.states[b] || {};\n        a = J(b.lineWidth, e.lineWidth, a + J(b.lineWidthPlus, e.lineWidthPlus, 0));\n        f = b.fillColor || e.fillColor || f;\n        c = b.lineColor || e.lineColor || c;\n        g = J(b.opacity, e.opacity, g);\n        return {\n          stroke: c,\n          \"stroke-width\": a,\n          fill: f,\n          opacity: g\n        };\n      };\n\n      c.prototype.destroy = function (a) {\n        var b = this,\n            g = b.chart,\n            d = /AppleWebKit\\/533/.test(v.navigator.userAgent),\n            f = b.data || [],\n            c,\n            l,\n            k,\n            r;\n        G(b, \"destroy\", {\n          keepEventsForUpdate: a\n        });\n        this.removeEvents(a);\n        (b.axisTypes || []).forEach(function (a) {\n          (r = b[a]) && r.series && (e(r.series, b), r.isDirty = r.forceRedraw = !0);\n        });\n        b.legendItem && b.chart.legend.destroyItem(b);\n\n        for (l = f.length; l--;) (k = f[l]) && k.destroy && k.destroy();\n\n        b.clips && b.clips.forEach(function (a) {\n          return a.destroy();\n        });\n        t.clearTimeout(b.animationTimeout);\n        C(b, function (a, b) {\n          a instanceof p && !a.survive && (c = d && \"group\" === b ? \"hide\" : \"destroy\", a[c]());\n        });\n        g.hoverSeries === b && (g.hoverSeries = void 0);\n        e(g.series, b);\n        g.orderSeries();\n        C(b, function (e, g) {\n          a && \"hcEvents\" === g || delete b[g];\n        });\n      };\n\n      c.prototype.applyZones = function () {\n        var a = this,\n            b = this.chart,\n            e = b.renderer,\n            g = this.zones,\n            d = this.clips || [],\n            f = this.graph,\n            c = this.area,\n            l = Math.max(b.plotWidth, b.plotHeight),\n            k = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            r = b.inverted,\n            m,\n            n,\n            u,\n            z,\n            x,\n            v,\n            w,\n            h,\n            p = !1;\n\n        if (g.length && (f || c) && k && \"undefined\" !== typeof k.min) {\n          var C = k.reversed;\n          var L = k.horiz;\n          f && !this.showLine && f.hide();\n          c && c.hide();\n          var G = k.getExtremes();\n          g.forEach(function (g, t) {\n            m = C ? L ? b.plotWidth : 0 : L ? 0 : k.toPixels(G.min) || 0;\n            m = q(J(n, m), 0, l);\n            n = q(Math.round(k.toPixels(J(g.value, G.max), !0) || 0), 0, l);\n            p && (m = n = k.toPixels(G.max));\n            z = Math.abs(m - n);\n            x = Math.min(m, n);\n            v = Math.max(m, n);\n            k.isXAxis ? (u = {\n              x: r ? v : x,\n              y: 0,\n              width: z,\n              height: l\n            }, L || (u.x = b.plotHeight - u.x)) : (u = {\n              x: 0,\n              y: r ? v : x,\n              width: l,\n              height: z\n            }, L && (u.y = b.plotWidth - u.y));\n            r && e.isVML && (u = k.isXAxis ? {\n              x: 0,\n              y: C ? x : v,\n              height: u.width,\n              width: b.chartWidth\n            } : {\n              x: u.y - b.plotLeft - b.spacingBox.x,\n              y: 0,\n              width: u.height,\n              height: b.chartHeight\n            });\n            d[t] ? d[t].animate(u) : d[t] = e.clipRect(u);\n            w = a[\"zone-area-\" + t];\n            h = a[\"zone-graph-\" + t];\n            f && h && h.clip(d[t]);\n            c && w && w.clip(d[t]);\n            p = g.value > G.max;\n            a.resetZones && 0 === n && (n = void 0);\n          });\n          this.clips = d;\n        } else a.visible && (f && f.show(), c && c.show());\n      };\n\n      c.prototype.invertGroups = function (a) {\n        function b() {\n          [\"group\", \"markerGroup\"].forEach(function (b) {\n            e[b] && (g.renderer.isVML && e[b].attr({\n              width: e.yAxis.len,\n              height: e.xAxis.len\n            }), e[b].width = e.yAxis.len, e[b].height = e.xAxis.len, e[b].invert(e.isRadialSeries ? !1 : a));\n          });\n        }\n\n        var e = this,\n            g = e.chart;\n        e.xAxis && (e.eventsToUnbind.push(M(g, \"resize\", b)), b(), e.invertGroups = b);\n      };\n\n      c.prototype.plotGroup = function (a, b, e, g, d) {\n        var f = this[a],\n            c = !f;\n        e = {\n          visibility: e,\n          zIndex: g || .1\n        };\n        \"undefined\" === typeof this.opacity || this.chart.styledMode || \"inactive\" === this.state || (e.opacity = this.opacity);\n        c && (this[a] = f = this.chart.renderer.g().add(d));\n        f.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (x(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (f.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        f.attr(e)[c ? \"attr\" : \"animate\"](this.getPlotBox());\n        return f;\n      };\n\n      c.prototype.getPlotBox = function () {\n        var a = this.chart,\n            b = this.xAxis,\n            e = this.yAxis;\n        a.inverted && (b = e, e = this.xAxis);\n        return {\n          translateX: b ? b.left : a.plotLeft,\n          translateY: e ? e.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      };\n\n      c.prototype.removeEvents = function (a) {\n        a || Y(this);\n        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind.length = 0);\n      };\n\n      c.prototype.render = function () {\n        var a = this,\n            e = a.chart,\n            g = a.options,\n            d = b(g.animation),\n            f = a.visible ? \"inherit\" : \"hidden\",\n            c = g.zIndex,\n            l = a.hasRendered,\n            k = e.seriesGroup,\n            r = e.inverted;\n        e = !a.finishedAnimating && e.renderer.isSVG ? d.duration : 0;\n        G(this, \"render\");\n        var m = a.plotGroup(\"group\", \"series\", f, c, k);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", f, c, k);\n        !1 !== g.clip && a.setClip();\n        a.animate && e && a.animate(!0);\n        m.inverted = J(a.invertible, a.isCartesian) ? r : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.visible && a.drawPoints();\n        a.drawDataLabels && a.drawDataLabels();\n        a.redrawPoints && a.redrawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(r);\n        a.animate && e && a.animate();\n        l || (e && d.defer && (e += d.defer), a.animationTimeout = fa(function () {\n          a.afterAnimate();\n        }, e || 0));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        G(a, \"afterRender\");\n      };\n\n      c.prototype.redraw = function () {\n        var a = this.chart,\n            b = this.isDirty || this.isDirtyData,\n            e = this.group,\n            g = this.xAxis,\n            d = this.yAxis;\n        e && (a.inverted && e.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), e.animate({\n          translateX: J(g && g.left, a.plotLeft),\n          translateY: J(d && d.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      };\n\n      c.prototype.searchPoint = function (a, b) {\n        var e = this.xAxis,\n            g = this.yAxis,\n            d = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: d ? e.len - a.chartY + e.pos : a.chartX - e.pos,\n          plotY: d ? g.len - a.chartX + g.pos : a.chartY - g.pos\n        }, b, a);\n      };\n\n      c.prototype.buildKDTree = function (a) {\n        function b(a, g, d) {\n          var f = a && a.length;\n\n          if (f) {\n            var c = e.kdAxisArray[g % d];\n            a.sort(function (a, b) {\n              return a[c] - b[c];\n            });\n            f = Math.floor(f / 2);\n            return {\n              point: a[f],\n              left: b(a.slice(0, f), g + 1, d),\n              right: b(a.slice(f + 1), g + 1, d)\n            };\n          }\n        }\n\n        this.buildingKdTree = !0;\n        var e = this,\n            g = -1 < e.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete e.kdTree;\n        fa(function () {\n          e.kdTree = b(e.getValidPoints(null, !e.directTouch), g, g);\n          e.buildingKdTree = !1;\n        }, e.options.kdNow || a && \"touchstart\" === a.type ? 0 : 1);\n      };\n\n      c.prototype.searchKDTree = function (a, b, e) {\n        function g(a, b, e, k) {\n          var r = b.point,\n              m = d.kdAxisArray[e % k],\n              n = r,\n              q = x(a[f]) && x(r[f]) ? Math.pow(a[f] - r[f], 2) : null;\n          var u = x(a[c]) && x(r[c]) ? Math.pow(a[c] - r[c], 2) : null;\n          u = (q || 0) + (u || 0);\n          r.dist = x(u) ? Math.sqrt(u) : Number.MAX_VALUE;\n          r.distX = x(q) ? Math.sqrt(q) : Number.MAX_VALUE;\n          m = a[m] - r[m];\n          u = 0 > m ? \"left\" : \"right\";\n          q = 0 > m ? \"right\" : \"left\";\n          b[u] && (u = g(a, b[u], e + 1, k), n = u[l] < n[l] ? u : r);\n          b[q] && Math.sqrt(m * m) < n[l] && (a = g(a, b[q], e + 1, k), n = a[l] < n[l] ? a : n);\n          return n;\n        }\n\n        var d = this,\n            f = this.kdAxisArray[0],\n            c = this.kdAxisArray[1],\n            l = b ? \"distX\" : \"dist\";\n        b = -1 < d.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(e);\n        if (this.kdTree) return g(a, this.kdTree, b, b);\n      };\n\n      c.prototype.pointPlacementToXValue = function () {\n        var a = this.options,\n            b = a.pointRange,\n            e = this.xAxis;\n        a = a.pointPlacement;\n        \"between\" === a && (a = e.reversed ? -.5 : .5);\n        return L(a) ? a * (b || e.pointRange) : 0;\n      };\n\n      c.prototype.isPointInside = function (a) {\n        var b = this.chart,\n            e = this.xAxis,\n            g = this.yAxis;\n        return \"undefined\" !== typeof a.plotY && \"undefined\" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= (g ? g.len : b.plotHeight) && 0 <= a.plotX && a.plotX <= (e ? e.len : b.plotWidth);\n      };\n\n      c.prototype.drawTracker = function () {\n        var a = this,\n            b = a.options,\n            e = b.trackByArea,\n            g = [].concat(e ? a.areaPath : a.graphPath),\n            c = a.chart,\n            l = c.pointer,\n            k = c.renderer,\n            r = c.options.tooltip.snap,\n            m = a.tracker,\n            n = function (b) {\n          if (c.hoverSeries !== a) a.onMouseOver();\n        },\n            q = \"rgba(192,192,192,\" + (d ? .0001 : .002) + \")\";\n\n        m ? m.attr({\n          d: g\n        }) : a.graph && (a.tracker = k.path(g).attr({\n          visibility: a.visible ? \"inherit\" : \"hidden\",\n          zIndex: 2\n        }).addClass(e ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), c.styledMode || a.tracker.attr({\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          stroke: q,\n          fill: e ? q : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (e ? 0 : 2 * r)\n        }), [a.tracker, a.markerGroup, a.dataLabelsGroup].forEach(function (a) {\n          if (a && (a.addClass(\"highcharts-tracker\").on(\"mouseover\", n).on(\"mouseout\", function (a) {\n            l.onTrackerMouseOut(a);\n          }), b.cursor && !c.styledMode && a.css({\n            cursor: b.cursor\n          }), f)) a.on(\"touchstart\", n);\n        }));\n        G(this, \"afterDrawTracker\");\n      };\n\n      c.prototype.addPoint = function (a, b, e, g, d) {\n        var f = this.options,\n            c = this.data,\n            l = this.chart,\n            k = this.xAxis;\n        k = k && k.hasNames && k.names;\n        var r = f.data,\n            m = this.xData,\n            n;\n        b = J(b, !0);\n        var q = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(q, [a]);\n        var u = q.x;\n        var z = m.length;\n        if (this.requireSorting && u < m[z - 1]) for (n = !0; z && m[z - 1] > u;) z--;\n        this.updateParallelArrays(q, \"splice\", z, 0, 0);\n        this.updateParallelArrays(q, z);\n        k && q.name && (k[u] = q.name);\n        r.splice(z, 0, a);\n        if (n || this.processedData) this.data.splice(z, 0, null), this.processData();\n        \"point\" === f.legendType && this.generatePoints();\n        e && (c[0] && c[0].remove ? c[0].remove(!1) : (c.shift(), this.updateParallelArrays(q, \"shift\"), r.shift()));\n        !1 !== d && G(this, \"addPoint\", {\n          point: q\n        });\n        this.isDirtyData = this.isDirty = !0;\n        b && l.redraw(g);\n      };\n\n      c.prototype.removePoint = function (a, b, e) {\n        var g = this,\n            d = g.data,\n            f = d[a],\n            c = g.points,\n            l = g.chart,\n            r = function () {\n          c && c.length === d.length && c.splice(a, 1);\n          d.splice(a, 1);\n          g.options.data.splice(a, 1);\n          g.updateParallelArrays(f || {\n            series: g\n          }, \"splice\", a, 1);\n          f && f.destroy();\n          g.isDirty = !0;\n          g.isDirtyData = !0;\n          b && l.redraw();\n        };\n\n        k(e, l);\n        b = J(b, !0);\n        f ? f.firePointEvent(\"remove\", null, r) : r();\n      };\n\n      c.prototype.remove = function (a, b, e, g) {\n        function d() {\n          f.destroy(g);\n          c.isDirtyLegend = c.isDirtyBox = !0;\n          c.linkSeries();\n          J(a, !0) && c.redraw(b);\n        }\n\n        var f = this,\n            c = f.chart;\n        !1 !== e ? G(f, \"remove\", null, d) : d();\n      };\n\n      c.prototype.update = function (a, b) {\n        a = w(a, this.userOptions);\n        G(this, \"update\", {\n          options: a\n        });\n        var e = this,\n            g = e.chart,\n            d = e.userOptions,\n            f = e.initialType || e.type,\n            c = g.options.plotOptions,\n            k = K[f].prototype,\n            r = e.finishedAnimating && {\n          animation: !1\n        },\n            m = {},\n            n,\n            q = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n            z = a.type || d.type || g.options.chart.type,\n            x = !(this.hasDerivedData || z && z !== this.type || \"undefined\" !== typeof a.pointStart || \"undefined\" !== typeof a.pointInterval || \"undefined\" !== typeof a.relativeXValue || a.joinBy || a.mapData || e.hasOptionChanged(\"dataGrouping\") || e.hasOptionChanged(\"pointStart\") || e.hasOptionChanged(\"pointInterval\") || e.hasOptionChanged(\"pointIntervalUnit\") || e.hasOptionChanged(\"keys\"));\n        z = z || f;\n        x && (q.push(\"data\", \"isDirtyData\", \"points\", \"processedData\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"_hasPointLabels\", \"clips\", \"nodes\", \"layout\", \"level\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== a.visible && q.push(\"area\", \"graph\"), e.parallelArrays.forEach(function (a) {\n          q.push(a + \"Data\");\n        }), a.data && (a.dataSorting && l(e.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));\n        a = S(d, r, {\n          index: \"undefined\" === typeof d.index ? e.index : d.index,\n          pointStart: J(c && c.series && c.series.pointStart, d.pointStart, e.xData[0])\n        }, !x && {\n          data: e.options.data\n        }, a);\n        x && a.data && (a.data = e.options.data);\n        q = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(q);\n        q.forEach(function (a) {\n          q[a] = e[a];\n          delete e[a];\n        });\n        c = !1;\n\n        if (K[z]) {\n          if (c = z !== e.type, e.remove(!1, !1, !1, !0), c) if (Object.setPrototypeOf) Object.setPrototypeOf(e, K[z].prototype);else {\n            r = Object.hasOwnProperty.call(e, \"hcEvents\") && e.hcEvents;\n\n            for (n in k) e[n] = void 0;\n\n            l(e, K[z].prototype);\n            r ? e.hcEvents = r : delete e.hcEvents;\n          }\n        } else u(17, !0, g, {\n          missingModuleFor: z\n        });\n\n        q.forEach(function (a) {\n          e[a] = q[a];\n        });\n        e.init(g, a);\n\n        if (x && this.points) {\n          var v = e.options;\n          !1 === v.visible ? (m.graphic = 1, m.dataLabel = 1) : e._hasPointLabels || (a = v.marker, k = v.dataLabels, !a || !1 !== a.enabled && (d.marker && d.marker.symbol) === a.symbol || (m.graphic = 1), k && !1 === k.enabled && (m.dataLabel = 1));\n          this.points.forEach(function (a) {\n            a && a.series && (a.resolveColor(), Object.keys(m).length && a.destroyElements(m), !1 === v.showInLegend && a.legendItem && g.legend.destroyItem(a));\n          }, this);\n        }\n\n        e.initialType = f;\n        g.linkSeries();\n        c && e.linkedSeries.length && (e.isDirtyData = !0);\n        G(this, \"afterUpdate\");\n        J(b, !0) && g.redraw(x ? void 0 : !1);\n      };\n\n      c.prototype.setName = function (a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      };\n\n      c.prototype.hasOptionChanged = function (a) {\n        var b = this.options[a],\n            e = this.chart.options.plotOptions,\n            g = this.userOptions[a];\n        return g ? b !== g : b !== J(e && e[this.type] && e[this.type][a], e && e.series && e.series[a], b);\n      };\n\n      c.prototype.onMouseOver = function () {\n        var a = this.chart,\n            b = a.hoverSeries;\n        a.pointer.setHoverChartIndex();\n        if (b && b !== this) b.onMouseOut();\n        this.options.events.mouseOver && G(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      };\n\n      c.prototype.onMouseOut = function () {\n        var a = this.options,\n            b = this.chart,\n            e = b.tooltip,\n            g = b.hoverPoint;\n        b.hoverSeries = null;\n        if (g) g.onMouseOut();\n        this && a.events.mouseOut && G(this, \"mouseOut\");\n        !e || this.stickyTracking || e.shared && !this.noSharedTooltip || e.hide();\n        b.series.forEach(function (a) {\n          a.setState(\"\", !0);\n        });\n      };\n\n      c.prototype.setState = function (a, b) {\n        var e = this,\n            g = e.options,\n            d = e.graph,\n            f = g.inactiveOtherPoints,\n            c = g.states,\n            l = J(c[a || \"normal\"] && c[a || \"normal\"].animation, e.chart.options.chart.animation),\n            k = g.lineWidth,\n            r = 0,\n            m = g.opacity;\n        a = a || \"\";\n\n        if (e.state !== a && ([e.group, e.markerGroup, e.dataLabelsGroup].forEach(function (b) {\n          b && (e.state && b.removeClass(\"highcharts-series-\" + e.state), a && b.addClass(\"highcharts-series-\" + a));\n        }), e.state = a, !e.chart.styledMode)) {\n          if (c[a] && !1 === c[a].enabled) return;\n          a && (k = c[a].lineWidth || k + (c[a].lineWidthPlus || 0), m = J(c[a].opacity, m));\n          if (d && !d.dashstyle) for (g = {\n            \"stroke-width\": k\n          }, d.animate(g, l); e[\"zone-graph-\" + r];) e[\"zone-graph-\" + r].animate(g, l), r += 1;\n          f || [e.group, e.markerGroup, e.dataLabelsGroup, e.labelBySeries].forEach(function (a) {\n            a && a.animate({\n              opacity: m\n            }, l);\n          });\n        }\n\n        b && f && e.points && e.setAllPointsToState(a || void 0);\n      };\n\n      c.prototype.setAllPointsToState = function (a) {\n        this.points.forEach(function (b) {\n          b.setState && b.setState(a);\n        });\n      };\n\n      c.prototype.setVisible = function (a, b) {\n        var e = this,\n            g = e.chart,\n            d = e.legendItem,\n            f = g.options.chart.ignoreHiddenSeries,\n            c = e.visible,\n            l = (e.visible = a = e.options.visible = e.userOptions.visible = \"undefined\" === typeof a ? !c : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (e[a]) e[a][l]();\n        });\n        if (g.hoverSeries === e || (g.hoverPoint && g.hoverPoint.series) === e) e.onMouseOut();\n        d && g.legend.colorizeItem(e, a);\n        e.isDirty = !0;\n        e.options.stacking && g.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        e.linkedSeries.forEach(function (b) {\n          b.setVisible(a, !1);\n        });\n        f && (g.isDirtyBox = !0);\n        G(e, l);\n        !1 !== b && g.redraw();\n      };\n\n      c.prototype.show = function () {\n        this.setVisible(!0);\n      };\n\n      c.prototype.hide = function () {\n        this.setVisible(!1);\n      };\n\n      c.prototype.select = function (a) {\n        this.selected = a = this.options.selected = \"undefined\" === typeof a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        G(this, a ? \"select\" : \"unselect\");\n      };\n\n      c.prototype.shouldShowTooltip = function (a, b, e) {\n        void 0 === e && (e = {});\n        e.series = this;\n        e.visiblePlotOnly = !0;\n        return this.chart.isInsidePlot(a, b, e);\n      };\n\n      c.defaultOptions = F;\n      c.types = y.seriesTypes;\n      c.registerType = y.registerSeriesType;\n      return c;\n    }();\n\n    l(c.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      drawLegendSymbol: A.drawLineMarker,\n      isCartesian: !0,\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: D,\n      requireSorting: !0,\n      sorted: !0\n    });\n    y.series = c;\n    \"\";\n    \"\";\n    return c;\n  });\n  O(h, \"Extensions/ScrollablePlotArea.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Axis/Axis.js\"], h[\"Core/Chart/Chart.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Renderer/RendererRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A, D) {\n    var F = c.stop,\n        y = D.addEvent,\n        p = D.createElement,\n        t = D.defined,\n        b = D.merge,\n        k = D.pick;\n    y(B, \"afterSetChartSize\", function (c) {\n      var k = this.options.chart.scrollablePlotArea,\n          f = k && k.minWidth;\n      k = k && k.minHeight;\n\n      if (!this.renderer.forExport) {\n        if (f) {\n          if (this.scrollablePixelsX = f = Math.max(0, f - this.chartWidth)) {\n            this.scrollablePlotBox = this.renderer.scrollablePlotBox = b(this.plotBox);\n            this.plotBox.width = this.plotWidth += f;\n            this.inverted ? this.clipBox.height += f : this.clipBox.width += f;\n            var d = {\n              1: {\n                name: \"right\",\n                value: f\n              }\n            };\n          }\n        } else k && (this.scrollablePixelsY = f = Math.max(0, k - this.chartHeight), t(f) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = b(this.plotBox), this.plotBox.height = this.plotHeight += f, this.inverted ? this.clipBox.width += f : this.clipBox.height += f, d = {\n          2: {\n            name: \"bottom\",\n            value: f\n          }\n        }));\n\n        d && !c.skipAxes && this.axes.forEach(function (b) {\n          d[b.side] ? b.getPlotLinePath = function () {\n            var f = d[b.side].name,\n                c = this[f];\n            this[f] = c - d[b.side].value;\n            var k = h.prototype.getPlotLinePath.apply(this, arguments);\n            this[f] = c;\n            return k;\n          } : (b.setAxisSize(), b.setAxisTranslation());\n        });\n      }\n    });\n    y(B, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    B.prototype.setUpScrolling = function () {\n      var b = this,\n          c = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (c.overflowX = \"auto\");\n      this.scrollablePixelsY && (c.overflowY = \"auto\");\n      this.scrollingParent = p(\"div\", {\n        className: \"highcharts-scrolling-parent\"\n      }, {\n        position: \"relative\"\n      }, this.renderTo);\n      this.scrollingContainer = p(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, c, this.scrollingParent);\n      y(this.scrollingContainer, \"scroll\", function () {\n        b.pointer && delete b.pointer.chartPosition;\n      });\n      this.innerContainer = p(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    B.prototype.moveFixedElements = function () {\n      var b = this.container,\n          c = this.fixedRenderer,\n          f = \".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n          d;\n      this.scrollablePixelsX && !this.inverted ? d = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? d = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? d = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (d = \".highcharts-yaxis\");\n      d && f.push(\"\" + d + \":not(.highcharts-radial-axis)\", \"\" + d + \"-labels:not(.highcharts-radial-axis-labels)\");\n      f.forEach(function (d) {\n        [].forEach.call(b.querySelectorAll(d), function (b) {\n          (b.namespaceURI === c.SVG_NS ? c.box : c.box.parentNode).appendChild(b);\n          b.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n\n    B.prototype.applyFixed = function () {\n      var b = !this.fixedDiv,\n          c = this.options.chart,\n          f = c.scrollablePlotArea,\n          d = A.getRendererType();\n      b ? (this.fixedDiv = p(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: (c.style && c.style.zIndex || 0) + 2,\n        top: 0\n      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = c = new d(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = c.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": k(f.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), y(this, \"afterShowResetZoom\", this.moveFixedElements), y(this, \"afterApplyDrilldown\", this.moveFixedElements), y(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      if (this.scrollableDirty || b) this.scrollableDirty = !1, this.moveFixedElements();\n      c = this.chartWidth + (this.scrollablePixelsX || 0);\n      d = this.chartHeight + (this.scrollablePixelsY || 0);\n      F(this.container);\n      this.container.style.width = c + \"px\";\n      this.container.style.height = d + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: c,\n        height: d,\n        viewBox: [0, 0, c, d].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: c,\n        height: d\n      });\n      this.scrollingContainer.style.height = this.chartHeight + \"px\";\n      b && (f.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * f.scrollPositionX), f.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * f.scrollPositionY));\n      d = this.axisOffset;\n      b = this.plotTop - d[0] - 1;\n      f = this.plotLeft - d[3] - 1;\n      c = this.plotTop + this.plotHeight + d[2] + 1;\n      d = this.plotLeft + this.plotWidth + d[1] + 1;\n      var v = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n          h = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      b = this.scrollablePixelsX ? [[\"M\", 0, b], [\"L\", this.plotLeft - 1, b], [\"L\", this.plotLeft - 1, c], [\"L\", 0, c], [\"Z\"], [\"M\", v, b], [\"L\", this.chartWidth, b], [\"L\", this.chartWidth, c], [\"L\", v, c], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", f, 0], [\"L\", f, this.plotTop - 1], [\"L\", d, this.plotTop - 1], [\"L\", d, 0], [\"Z\"], [\"M\", f, h], [\"L\", f, this.chartHeight], [\"L\", d, this.chartHeight], [\"L\", d, h], [\"Z\"]] : [[\"M\", 0, 0]];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: b\n      });\n    };\n\n    y(h, \"afterInit\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    y(E, \"show\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    \"\";\n  });\n  O(h, \"Core/Axis/Stacking/StackItem.js\", [h[\"Core/FormatUtilities.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var I = c.format,\n        A = h.series,\n        D = B.defined,\n        F = B.destroyObjectProperties,\n        y = B.isNumber,\n        p = B.pick;\n\n    c = function () {\n      function c(b, c, n, m, f) {\n        var d = b.chart.inverted;\n        this.axis = b;\n        this.isNegative = n;\n        this.options = c = c || {};\n        this.x = m;\n        this.cumulative = this.total = null;\n        this.points = {};\n        this.hasValidPoints = !1;\n        this.stack = f;\n        this.rightCliff = this.leftCliff = 0;\n        this.alignOptions = {\n          align: c.align || (d ? n ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: c.verticalAlign || (d ? \"middle\" : n ? \"bottom\" : \"top\"),\n          y: c.y,\n          x: c.x\n        };\n        this.textAlign = c.textAlign || (d ? n ? \"right\" : \"left\" : \"center\");\n      }\n\n      c.prototype.destroy = function () {\n        F(this, this.axis);\n      };\n\n      c.prototype.render = function (b) {\n        var c = this.axis.chart,\n            n = this.options,\n            m = n.format;\n        m = m ? I(m, this, c) : n.formatter.call(this);\n        this.label ? this.label.attr({\n          text: m,\n          visibility: \"hidden\"\n        }) : (this.label = c.renderer.label(m, null, null, n.shape, null, null, n.useHTML, !1, \"stack-labels\"), m = {\n          r: n.borderRadius || 0,\n          text: m,\n          rotation: n.rotation,\n          padding: p(n.padding, 5),\n          visibility: \"hidden\"\n        }, c.styledMode || (m.fill = n.backgroundColor, m.stroke = n.borderColor, m[\"stroke-width\"] = n.borderWidth, this.label.css(n.style)), this.label.attr(m), this.label.added || this.label.add(b));\n        this.label.labelrank = c.plotSizeY;\n      };\n\n      c.prototype.setOffset = function (b, c, n, m, f) {\n        var d = this.axis,\n            k = d.chart;\n        m = d.translate(d.stacking.usePercentage ? 100 : m ? m : this.total, 0, 0, 0, 1);\n        n = d.translate(n ? n : 0);\n        b = p(f, k.xAxis[0].translate(this.x)) + b;\n        d = D(m) && this.getStackBox(k, this, b, m, c, Math.abs(m - n), d);\n        c = this.label;\n        n = this.isNegative;\n        var h = this.textAlign;\n        c && d && (b = c.getBBox(), f = c.padding, m = \"justify\" === p(this.options.overflow, \"justify\"), h = \"left\" === h ? k.inverted ? -f : f : \"right\" === h ? b.width : k.inverted && \"center\" === h ? b.width / 2 : k.inverted ? n ? b.width + f : -f : b.width / 2, n = k.inverted ? b.height / 2 : n ? -f : b.height, this.alignOptions.x = p(this.options.x, 0), this.alignOptions.y = p(this.options.y, 0), d.x -= h, d.y -= n, c.align(this.alignOptions, null, d), k.isInsidePlot(c.alignAttr.x + h - this.alignOptions.x, c.alignAttr.y + n - this.alignOptions.y) ? c.show() : (c.hide(), m = !1), m && A.prototype.justifyDataLabel.call(this.axis, c, this.alignOptions, c.alignAttr, b, d), c.attr({\n          x: c.alignAttr.x,\n          y: c.alignAttr.y\n        }), p(!m && this.options.crop, !0) && ((k = y(c.x) && y(c.y) && k.isInsidePlot(c.x - f + c.width, c.y) && k.isInsidePlot(c.x + f, c.y)) || c.hide()));\n      };\n\n      c.prototype.getStackBox = function (b, c, n, m, f, d, h) {\n        var k = c.axis.reversed,\n            p = b.inverted,\n            v = h.height + h.pos - (p ? b.plotLeft : b.plotTop);\n        c = c.isNegative && !k || !c.isNegative && k;\n        return {\n          x: p ? c ? m - h.right : m - d + h.pos - b.plotLeft : n + b.xAxis[0].transB - b.plotLeft,\n          y: p ? h.height - n - f : c ? v - m - d : v - m,\n          width: p ? d : f,\n          height: p ? f : d\n        };\n      };\n\n      return c;\n    }();\n\n    \"\";\n    return c;\n  });\n  O(h, \"Core/Axis/Stacking/StackingAxis.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Axis/Axis.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Axis/Stacking/StackItem.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A) {\n    function D() {\n      var b = this,\n          e = b.inverted;\n      b.yAxis.forEach(function (a) {\n        a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);\n      });\n      b.series.forEach(function (g) {\n        var d = g.xAxis && g.xAxis.options || {};\n        !g.options.stacking || !0 !== g.visible && !1 !== b.options.chart.ignoreHiddenSeries || (g.stackKey = [g.type, a(g.options.stack, \"\"), e ? d.top : d.left, e ? d.height : d.width].join());\n      });\n    }\n\n    function F() {\n      var a = this.stacking;\n\n      if (a) {\n        var b = a.stacks;\n        w(b, function (a, e) {\n          M(a);\n          b[e] = null;\n        });\n        a && a.stackTotalGroup && a.stackTotalGroup.destroy();\n      }\n    }\n\n    function y() {\n      this.stacking || (this.stacking = new x(this));\n    }\n\n    function p(a, b, e, d) {\n      !K(a) || a.x !== b || d && a.stackKey !== d ? a = {\n        x: b,\n        index: 0,\n        key: d,\n        stackKey: d\n      } : a.index++;\n      a.key = [e, b, a.index].join();\n      return a;\n    }\n\n    function t() {\n      var a = this,\n          b = a.stackKey,\n          e = a.yAxis.stacking.stacks,\n          d = a.processedXData,\n          f = a[a.options.stacking + \"Stacker\"],\n          c;\n      f && [b, \"-\" + b].forEach(function (b) {\n        for (var g = d.length, l, k; g--;) l = d[g], c = a.getStackIndicator(c, l, a.index, b), (k = (l = e[b] && e[b][l]) && l.points[c.key]) && f.call(a, k, l, g);\n      });\n    }\n\n    function b(a, b, e) {\n      b = b.total ? 100 / b.total : 0;\n      a[0] = v(a[0] * b);\n      a[1] = v(a[1] * b);\n      this.stackedYData[e] = a[1];\n    }\n\n    function k() {\n      var a = this.yAxis.stacking;\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && 1 < this.chart.series.length ? f.setStackedPoints.call(this, \"group\") : a && w(a.stacks, function (b, e) {\n        \"group\" === e.slice(-5) && (w(b, function (a) {\n          return a.destroy();\n        }), delete a.stacks[e]);\n      });\n    }\n\n    function n(b) {\n      var e = b || this.options.stacking;\n\n      if (e && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var g = this.processedXData,\n            d = this.processedYData,\n            f = [],\n            c = d.length,\n            k = this.options,\n            m = k.threshold,\n            q = a(k.startFromThreshold && m, 0);\n        k = k.stack;\n        b = b ? \"\" + this.type + \",\".concat(e) : this.stackKey;\n        var n = \"-\" + b,\n            u = this.negStacks,\n            x = this.yAxis,\n            h = x.stacking.stacks,\n            w = x.stacking.oldStacks,\n            p,\n            t;\n        x.stacking.stacksTouched += 1;\n\n        for (t = 0; t < c; t++) {\n          var y = g[t];\n          var F = d[t];\n          var M = this.getStackIndicator(M, y, this.index);\n          var N = M.key;\n          var A = (p = u && F < (q ? 0 : m)) ? n : b;\n          h[A] || (h[A] = {});\n          h[A][y] || (w[A] && w[A][y] ? (h[A][y] = w[A][y], h[A][y].total = null) : h[A][y] = new E(x, x.options.stackLabels, !!p, y, k));\n          A = h[A][y];\n          null !== F ? (A.points[N] = A.points[this.index] = [a(A.cumulative, q)], K(A.cumulative) || (A.base = N), A.touched = x.stacking.stacksTouched, 0 < M.index && !1 === this.singleStacks && (A.points[N][0] = A.points[this.index + \",\" + y + \",0\"][0])) : A.points[N] = A.points[this.index] = null;\n          \"percent\" === e ? (p = p ? b : n, u && h[p] && h[p][y] ? (p = h[p][y], A.total = p.total = Math.max(p.total, A.total) + Math.abs(F) || 0) : A.total = v(A.total + (Math.abs(F) || 0))) : \"group\" === e ? (H(F) && (F = F[0]), null !== F && (A.total = (A.total || 0) + 1)) : A.total = v(A.total + (F || 0));\n          A.cumulative = \"group\" === e ? (A.total || 1) - 1 : a(A.cumulative, q) + (F || 0);\n          null !== F && (A.points[N].push(A.cumulative), f[t] = A.cumulative, A.hasValidPoints = !0);\n        }\n\n        \"percent\" === e && (x.stacking.usePercentage = !0);\n        \"group\" !== e && (this.stackedYData = f);\n        x.stacking.oldStacks = {};\n      }\n    }\n\n    var m = c.getDeferredAnimation,\n        f = B.series.prototype,\n        d = A.addEvent,\n        v = A.correctFloat,\n        K = A.defined,\n        M = A.destroyObjectProperties,\n        N = A.fireEvent,\n        H = A.isArray,\n        q = A.isNumber,\n        w = A.objectEach,\n        a = A.pick,\n        x = function () {\n      function a(a) {\n        this.oldStacks = {};\n        this.stacks = {};\n        this.stacksTouched = 0;\n        this.axis = a;\n      }\n\n      a.prototype.buildStacks = function () {\n        var a = this.axis,\n            b = a.series,\n            e = a.options.reversedStacks,\n            d = b.length,\n            f;\n\n        if (!a.isXAxis) {\n          this.usePercentage = !1;\n\n          for (f = d; f--;) {\n            var c = b[e ? f : d - f - 1];\n            c.setStackedPoints();\n            c.setGroupedPoints();\n          }\n\n          for (f = 0; f < d; f++) b[f].modifyStacks();\n\n          N(a, \"afterBuildStacks\");\n        }\n      };\n\n      a.prototype.cleanStacks = function () {\n        if (!this.axis.isXAxis) {\n          if (this.oldStacks) var a = this.stacks = this.oldStacks;\n          w(a, function (a) {\n            w(a, function (a) {\n              a.cumulative = a.total;\n            });\n          });\n        }\n      };\n\n      a.prototype.resetStacks = function () {\n        var a = this,\n            b = a.stacks;\n        a.axis.isXAxis || w(b, function (b) {\n          w(b, function (e, g) {\n            q(e.touched) && e.touched < a.stacksTouched ? (e.destroy(), delete b[g]) : (e.total = null, e.cumulative = null);\n          });\n        });\n      };\n\n      a.prototype.renderStackTotals = function () {\n        var a = this.axis,\n            b = a.chart,\n            e = b.renderer,\n            d = this.stacks;\n        a = m(b, a.options.stackLabels && a.options.stackLabels.animation || !1);\n        var f = this.stackTotalGroup = this.stackTotalGroup || e.g(\"stack-labels\").attr({\n          zIndex: 6,\n          opacity: 0\n        }).add();\n        f.translate(b.plotLeft, b.plotTop);\n        w(d, function (a) {\n          w(a, function (a) {\n            a.render(f);\n          });\n        });\n        f.animate({\n          opacity: 1\n        }, a);\n      };\n\n      return a;\n    }(),\n        e;\n\n    (function (a) {\n      var e = [];\n\n      a.compose = function (a, f, c) {\n        -1 === e.indexOf(a) && (e.push(a), d(a, \"init\", y), d(a, \"destroy\", F));\n        -1 === e.indexOf(f) && (e.push(f), f.prototype.getStacks = D);\n        -1 === e.indexOf(c) && (e.push(c), a = c.prototype, a.getStackIndicator = p, a.modifyStacks = t, a.percentStacker = b, a.setGroupedPoints = k, a.setStackedPoints = n);\n      };\n    })(e || (e = {}));\n\n    return e;\n  });\n  O(h, \"Series/Line/LineSeries.js\", [h[\"Core/Series/Series.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var I = this && this.__extends || function () {\n      var c = function (h, p) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, b) {\n          c.__proto__ = b;\n        } || function (c, b) {\n          for (var k in b) b.hasOwnProperty(k) && (c[k] = b[k]);\n        };\n\n        return c(h, p);\n      };\n\n      return function (h, p) {\n        function t() {\n          this.constructor = h;\n        }\n\n        c(h, p);\n        h.prototype = null === p ? Object.create(p) : (t.prototype = p.prototype, new t());\n      };\n    }(),\n        A = B.defined,\n        D = B.merge;\n\n    B = function (h) {\n      function y() {\n        var c = null !== h && h.apply(this, arguments) || this;\n        c.data = void 0;\n        c.options = void 0;\n        c.points = void 0;\n        return c;\n      }\n\n      I(y, h);\n\n      y.prototype.drawGraph = function () {\n        var c = this,\n            h = this.options,\n            b = (this.gappedPath || this.getGraphPath).call(this),\n            k = this.chart.styledMode,\n            n = [[\"graph\", \"highcharts-graph\"]];\n        k || n[0].push(h.lineColor || this.color || \"#cccccc\", h.dashStyle);\n        n = c.getZonesGraphs(n);\n        n.forEach(function (m, f) {\n          var d = m[0],\n              n = c[d],\n              p = n ? \"animate\" : \"attr\";\n          n ? (n.endX = c.preventGraphAnimation ? null : b.xMap, n.animate({\n            d: b\n          })) : b.length && (c[d] = n = c.chart.renderer.path(b).addClass(m[1]).attr({\n            zIndex: 1\n          }).add(c.group));\n          n && !k && (d = {\n            stroke: m[2],\n            \"stroke-width\": h.lineWidth,\n            fill: c.fillGraph && c.color || \"none\"\n          }, m[3] ? d.dashstyle = m[3] : \"square\" !== h.linecap && (d[\"stroke-linecap\"] = d[\"stroke-linejoin\"] = \"round\"), n[p](d).shadow(2 > f && h.shadow));\n          n && (n.startX = b.xMap, n.isArea = b.isArea);\n        });\n      };\n\n      y.prototype.getGraphPath = function (c, h, b) {\n        var k = this,\n            n = k.options,\n            m = [],\n            f = [],\n            d,\n            p = n.step;\n        c = c || k.points;\n        var t = c.reversed;\n        t && c.reverse();\n        (p = {\n          right: 1,\n          center: 2\n        }[p] || p && 3) && t && (p = 4 - p);\n        c = this.getValidPoints(c, !1, !(n.connectNulls && !h && !b));\n        c.forEach(function (v, t) {\n          var H = v.plotX,\n              q = v.plotY,\n              w = c[t - 1];\n          (v.leftCliff || w && w.rightCliff) && !b && (d = !0);\n          v.isNull && !A(h) && 0 < t ? d = !n.connectNulls : v.isNull && !h ? d = !0 : (0 === t || d ? t = [[\"M\", v.plotX, v.plotY]] : k.getPointSpline ? t = [k.getPointSpline(c, v, t)] : p ? (t = 1 === p ? [[\"L\", w.plotX, q]] : 2 === p ? [[\"L\", (w.plotX + H) / 2, w.plotY], [\"L\", (w.plotX + H) / 2, q]] : [[\"L\", H, w.plotY]], t.push([\"L\", H, q])) : t = [[\"L\", H, q]], f.push(v.x), p && (f.push(v.x), 2 === p && f.push(v.x)), m.push.apply(m, t), d = !1);\n        });\n        m.xMap = f;\n        return k.graphPath = m;\n      };\n\n      y.prototype.getZonesGraphs = function (c) {\n        this.zones.forEach(function (h, b) {\n          b = [\"zone-graph-\" + b, \"highcharts-graph highcharts-zone-graph-\" + b + \" \" + (h.className || \"\")];\n          this.chart.styledMode || b.push(h.color || this.color, h.dashStyle || this.options.dashStyle);\n          c.push(b);\n        }, this);\n        return c;\n      };\n\n      y.defaultOptions = D(c.defaultOptions, {});\n      return y;\n    }(c);\n\n    h.registerSeriesType(\"line\", B);\n    \"\";\n    return B;\n  });\n  O(h, \"Series/Area/AreaSeries.js\", [h[\"Core/Color/Color.js\"], h[\"Core/Legend/LegendSymbol.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E) {\n    var A = this && this.__extends || function () {\n      var b = function (c, n) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, f) {\n          b.__proto__ = f;\n        } || function (b, f) {\n          for (var d in f) f.hasOwnProperty(d) && (b[d] = f[d]);\n        };\n\n        return b(c, n);\n      };\n\n      return function (c, n) {\n        function k() {\n          this.constructor = c;\n        }\n\n        b(c, n);\n        c.prototype = null === n ? Object.create(n) : (k.prototype = n.prototype, new k());\n      };\n    }(),\n        D = c.parse,\n        F = B.seriesTypes.line;\n\n    c = E.extend;\n    var y = E.merge,\n        p = E.objectEach,\n        t = E.pick;\n\n    E = function (b) {\n      function c() {\n        var c = null !== b && b.apply(this, arguments) || this;\n        c.data = void 0;\n        c.options = void 0;\n        c.points = void 0;\n        return c;\n      }\n\n      A(c, b);\n\n      c.prototype.drawGraph = function () {\n        this.areaPath = [];\n        b.prototype.drawGraph.apply(this);\n        var c = this,\n            k = this.areaPath,\n            f = this.options,\n            d = [[\"area\", \"highcharts-area\", this.color, f.fillColor]];\n        this.zones.forEach(function (b, k) {\n          d.push([\"zone-area-\" + k, \"highcharts-area highcharts-zone-area-\" + k + \" \" + b.className, b.color || c.color, b.fillColor || f.fillColor]);\n        });\n        d.forEach(function (b) {\n          var d = b[0],\n              m = {},\n              n = c[d],\n              h = n ? \"animate\" : \"attr\";\n          n ? (n.endX = c.preventGraphAnimation ? null : k.xMap, n.animate({\n            d: k\n          })) : (m.zIndex = 0, n = c[d] = c.chart.renderer.path(k).addClass(b[1]).add(c.group), n.isArea = !0);\n          c.chart.styledMode || (m.fill = t(b[3], D(b[2]).setOpacity(t(f.fillOpacity, .75)).get()));\n          n[h](m);\n          n.startX = k.xMap;\n          n.shiftUnit = f.step ? 2 : 1;\n        });\n      };\n\n      c.prototype.getGraphPath = function (b) {\n        var c = F.prototype.getGraphPath,\n            f = this.options,\n            d = f.stacking,\n            k = this.yAxis,\n            n = [],\n            h = [],\n            p = this.index,\n            H = k.stacking.stacks[this.stackKey],\n            q = f.threshold,\n            w = Math.round(k.getThreshold(f.threshold));\n        f = t(f.connectNulls, \"percent\" === d);\n\n        var a = function (a, e, g) {\n          var c = b[a];\n          a = d && H[c.x].points[p];\n          var f = c[g + \"Null\"] || 0;\n          g = c[g + \"Cliff\"] || 0;\n          c = !0;\n\n          if (g || f) {\n            var r = (f ? a[0] : a[1]) + g;\n            var m = a[0] + g;\n            c = !!f;\n          } else !d && b[e] && b[e].isNull && (r = m = q);\n\n          \"undefined\" !== typeof r && (h.push({\n            plotX: l,\n            plotY: null === r ? w : k.getThreshold(r),\n            isNull: c,\n            isCliff: !0\n          }), n.push({\n            plotX: l,\n            plotY: null === m ? w : k.getThreshold(m),\n            doCurve: !1\n          }));\n        };\n\n        b = b || this.points;\n        d && (b = this.getStackPoints(b));\n\n        for (var x = 0, e = b.length; x < e; ++x) {\n          d || (b[x].leftCliff = b[x].rightCliff = b[x].leftNull = b[x].rightNull = void 0);\n          var u = b[x].isNull;\n          var l = t(b[x].rectPlotX, b[x].plotX);\n          var g = d ? t(b[x].yBottom, w) : w;\n          if (!u || f) f || a(x, x - 1, \"left\"), u && !d && f || (h.push(b[x]), n.push({\n            x: x,\n            plotX: l,\n            plotY: g\n          })), f || a(x, x + 1, \"right\");\n        }\n\n        a = c.call(this, h, !0, !0);\n        n.reversed = !0;\n        u = c.call(this, n, !0, !0);\n        (g = u[0]) && \"M\" === g[0] && (u[0] = [\"L\", g[1], g[2]]);\n        u = a.concat(u);\n        u.length && u.push([\"Z\"]);\n        c = c.call(this, h, !1, f);\n        u.xMap = a.xMap;\n        this.areaPath = u;\n        return c;\n      };\n\n      c.prototype.getStackPoints = function (b) {\n        var c = this,\n            f = [],\n            d = [],\n            k = this.xAxis,\n            n = this.yAxis,\n            h = n.stacking.stacks[this.stackKey],\n            y = {},\n            H = n.series,\n            q = H.length,\n            w = n.options.reversedStacks ? 1 : -1,\n            a = H.indexOf(c);\n        b = b || this.points;\n\n        if (this.options.stacking) {\n          for (var x = 0; x < b.length; x++) b[x].leftNull = b[x].rightNull = void 0, y[b[x].x] = b[x];\n\n          p(h, function (a, b) {\n            null !== a.total && d.push(b);\n          });\n          d.sort(function (a, b) {\n            return a - b;\n          });\n          var e = H.map(function (a) {\n            return a.visible;\n          });\n          d.forEach(function (b, l) {\n            var g = 0,\n                m,\n                x;\n            if (y[b] && !y[b].isNull) f.push(y[b]), [-1, 1].forEach(function (g) {\n              var f = 1 === g ? \"rightNull\" : \"leftNull\",\n                  k = h[d[l + g]],\n                  r = 0;\n              if (k) for (var n = a; 0 <= n && n < q;) {\n                var u = H[n].index;\n                m = k.points[u];\n                m || (u === c.index ? y[b][f] = !0 : e[n] && (x = h[b].points[u]) && (r -= x[1] - x[0]));\n                n += w;\n              }\n              y[b][1 === g ? \"rightCliff\" : \"leftCliff\"] = r;\n            });else {\n              for (var r = a; 0 <= r && r < q;) {\n                if (m = h[b].points[H[r].index]) {\n                  g = m[1];\n                  break;\n                }\n\n                r += w;\n              }\n\n              g = t(g, 0);\n              g = n.translate(g, 0, 1, 0, 1);\n              f.push({\n                isNull: !0,\n                plotX: k.translate(b, 0, 0, 0, 1),\n                x: b,\n                plotY: g,\n                yBottom: g\n              });\n            }\n          });\n        }\n\n        return f;\n      };\n\n      c.defaultOptions = y(F.defaultOptions, {\n        threshold: 0\n      });\n      return c;\n    }(F);\n\n    c(E.prototype, {\n      singleStacks: !1,\n      drawLegendSymbol: h.drawRectangle\n    });\n    B.registerSeriesType(\"area\", E);\n    \"\";\n    return E;\n  });\n  O(h, \"Series/Spline/SplineSeries.js\", [h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    var I = this && this.__extends || function () {\n      var c = function (h, p) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, b) {\n          c.__proto__ = b;\n        } || function (c, b) {\n          for (var k in b) b.hasOwnProperty(k) && (c[k] = b[k]);\n        };\n\n        return c(h, p);\n      };\n\n      return function (h, p) {\n        function t() {\n          this.constructor = h;\n        }\n\n        c(h, p);\n        h.prototype = null === p ? Object.create(p) : (t.prototype = p.prototype, new t());\n      };\n    }(),\n        E = c.seriesTypes.line,\n        A = h.merge,\n        D = h.pick;\n\n    h = function (c) {\n      function h() {\n        var h = null !== c && c.apply(this, arguments) || this;\n        h.data = void 0;\n        h.options = void 0;\n        h.points = void 0;\n        return h;\n      }\n\n      I(h, c);\n\n      h.prototype.getPointSpline = function (c, h, b) {\n        var k = h.plotX || 0,\n            n = h.plotY || 0,\n            m = c[b - 1];\n        b = c[b + 1];\n\n        if (m && !m.isNull && !1 !== m.doCurve && !h.isCliff && b && !b.isNull && !1 !== b.doCurve && !h.isCliff) {\n          c = m.plotY || 0;\n          var f = b.plotX || 0;\n          b = b.plotY || 0;\n          var d = 0;\n          var p = (1.5 * k + (m.plotX || 0)) / 2.5;\n          var t = (1.5 * n + c) / 2.5;\n          f = (1.5 * k + f) / 2.5;\n          var y = (1.5 * n + b) / 2.5;\n          f !== p && (d = (y - t) * (f - k) / (f - p) + n - y);\n          t += d;\n          y += d;\n          t > c && t > n ? (t = Math.max(c, n), y = 2 * n - t) : t < c && t < n && (t = Math.min(c, n), y = 2 * n - t);\n          y > b && y > n ? (y = Math.max(b, n), t = 2 * n - y) : y < b && y < n && (y = Math.min(b, n), t = 2 * n - y);\n          h.rightContX = f;\n          h.rightContY = y;\n        }\n\n        h = [\"C\", D(m.rightContX, m.plotX, 0), D(m.rightContY, m.plotY, 0), D(p, k, 0), D(t, n, 0), k, n];\n        m.rightContX = m.rightContY = void 0;\n        return h;\n      };\n\n      h.defaultOptions = A(E.defaultOptions);\n      return h;\n    }(E);\n\n    c.registerSeriesType(\"spline\", h);\n    \"\";\n    return h;\n  });\n  O(h, \"Series/AreaSpline/AreaSplineSeries.js\", [h[\"Series/Spline/SplineSeries.js\"], h[\"Core/Legend/LegendSymbol.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E) {\n    var A = this && this.__extends || function () {\n      var c = function (b, k) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, c) {\n          b.__proto__ = c;\n        } || function (b, c) {\n          for (var f in c) c.hasOwnProperty(f) && (b[f] = c[f]);\n        };\n\n        return c(b, k);\n      };\n\n      return function (b, k) {\n        function n() {\n          this.constructor = b;\n        }\n\n        c(b, k);\n        b.prototype = null === k ? Object.create(k) : (n.prototype = k.prototype, new n());\n      };\n    }(),\n        D = B.seriesTypes,\n        F = D.area;\n\n    D = D.area.prototype;\n    var y = E.extend,\n        p = E.merge;\n\n    E = function (h) {\n      function b() {\n        var b = null !== h && h.apply(this, arguments) || this;\n        b.data = void 0;\n        b.points = void 0;\n        b.options = void 0;\n        return b;\n      }\n\n      A(b, h);\n      b.defaultOptions = p(c.defaultOptions, F.defaultOptions);\n      return b;\n    }(c);\n\n    y(E.prototype, {\n      getGraphPath: D.getGraphPath,\n      getStackPoints: D.getStackPoints,\n      drawGraph: D.drawGraph,\n      drawLegendSymbol: h.drawRectangle\n    });\n    B.registerSeriesType(\"areaspline\", E);\n    \"\";\n    return E;\n  });\n  O(h, \"Series/Column/ColumnSeries.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Legend/LegendSymbol.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A, D, F) {\n    var y = this && this.__extends || function () {\n      var b = function (d, a) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var e in b) b.hasOwnProperty(e) && (a[e] = b[e]);\n        };\n\n        return b(d, a);\n      };\n\n      return function (d, a) {\n        function c() {\n          this.constructor = d;\n        }\n\n        b(d, a);\n        d.prototype = null === a ? Object.create(a) : (c.prototype = a.prototype, new c());\n      };\n    }(),\n        p = c.animObject,\n        t = h.parse,\n        b = B.hasTouch;\n\n    c = B.noop;\n    var k = F.clamp,\n        n = F.css,\n        m = F.defined,\n        f = F.extend,\n        d = F.fireEvent,\n        v = F.isArray,\n        K = F.isNumber,\n        M = F.merge,\n        N = F.pick,\n        H = F.objectEach;\n\n    F = function (c) {\n      function q() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.borderWidth = void 0;\n        a.data = void 0;\n        a.group = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      y(q, c);\n\n      q.prototype.animate = function (a) {\n        var b = this,\n            e = this.yAxis,\n            d = b.options,\n            c = this.chart.inverted,\n            g = {},\n            m = c ? \"translateX\" : \"translateY\";\n        if (a) g.scaleY = .001, a = k(e.toPixels(d.threshold), e.pos, e.pos + e.len), c ? g.translateX = a - e.len : g.translateY = a, b.clipBox && b.setClip(), b.group.attr(g);else {\n          var q = Number(b.group.attr(m));\n          b.group.animate({\n            scaleY: 1\n          }, f(p(b.options.animation), {\n            step: function (a, d) {\n              b.group && (g[m] = q + d.pos * (e.pos - q), b.group.attr(g));\n            }\n          }));\n        }\n      };\n\n      q.prototype.init = function (a, b) {\n        c.prototype.init.apply(this, arguments);\n        var e = this;\n        a = e.chart;\n        a.hasRendered && a.series.forEach(function (a) {\n          a.type === e.type && (a.isDirty = !0);\n        });\n      };\n\n      q.prototype.getColumnMetrics = function () {\n        var a = this,\n            b = a.options,\n            e = a.xAxis,\n            d = a.yAxis,\n            c = e.options.reversedStacks;\n        c = e.reversed && !c || !e.reversed && c;\n        var g = {},\n            f,\n            k = 0;\n        !1 === b.grouping ? k = 1 : a.chart.series.forEach(function (b) {\n          var e = b.yAxis,\n              c = b.options;\n\n          if (b.type === a.type && (b.visible || !a.chart.options.chart.ignoreHiddenSeries) && d.len === e.len && d.pos === e.pos) {\n            if (c.stacking && \"group\" !== c.stacking) {\n              f = b.stackKey;\n              \"undefined\" === typeof g[f] && (g[f] = k++);\n              var l = g[f];\n            } else !1 !== c.grouping && (l = k++);\n\n            b.columnIndex = l;\n          }\n        });\n        var r = Math.min(Math.abs(e.transA) * (e.ordinal && e.ordinal.slope || b.pointRange || e.closestPointRange || e.tickInterval || 1), e.len),\n            m = r * b.groupPadding,\n            q = (r - 2 * m) / (k || 1);\n        b = Math.min(b.maxPointWidth || e.len, N(b.pointWidth, q * (1 - 2 * b.pointPadding)));\n        a.columnMetrics = {\n          width: b,\n          offset: (q - b) / 2 + (m + ((a.columnIndex || 0) + (c ? 1 : 0)) * q - r / 2) * (c ? -1 : 1),\n          paddedWidth: q,\n          columnCount: k\n        };\n        return a.columnMetrics;\n      };\n\n      q.prototype.crispCol = function (a, b, e, d) {\n        var c = this.chart,\n            g = this.borderWidth,\n            f = -(g % 2 ? .5 : 0);\n        g = g % 2 ? .5 : 1;\n        c.inverted && c.renderer.isVML && (g += 1);\n        this.options.crisp && (e = Math.round(a + e) + f, a = Math.round(a) + f, e -= a);\n        d = Math.round(b + d) + g;\n        f = .5 >= Math.abs(b) && .5 < d;\n        b = Math.round(b) + g;\n        d -= b;\n        f && d && (--b, d += 1);\n        return {\n          x: a,\n          y: b,\n          width: e,\n          height: d\n        };\n      };\n\n      q.prototype.adjustForMissingColumns = function (a, b, e, d) {\n        var c = this,\n            g = this.options.stacking;\n\n        if (!e.isNull && 1 < d.columnCount) {\n          var f = this.yAxis.options.reversedStacks,\n              k = 0,\n              r = f ? 0 : -d.columnCount;\n          H(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {\n            if (\"number\" === typeof e.x && (a = a[e.x.toString()])) {\n              var b = a.points[c.index],\n                  d = a.total;\n              g ? (b && (k = r), a.hasValidPoints && (f ? r++ : r--)) : v(b) && (k = b[1], r = d || 0);\n            }\n          });\n          a = (e.plotX || 0) + ((r - 1) * d.paddedWidth + b) / 2 - b - k * d.paddedWidth;\n        }\n\n        return a;\n      };\n\n      q.prototype.translate = function () {\n        var a = this,\n            b = a.chart,\n            e = a.options,\n            d = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        d = a.borderWidth = N(e.borderWidth, d ? 0 : 1);\n        var c = a.xAxis,\n            g = a.yAxis,\n            f = e.threshold,\n            q = a.translatedThreshold = g.getThreshold(f),\n            r = N(e.minPointLength, 5),\n            n = a.getColumnMetrics(),\n            h = n.width,\n            w = a.pointXOffset = n.offset,\n            p = a.dataMin,\n            v = a.dataMax,\n            t = a.barW = Math.max(h, 1 + 2 * d);\n        b.inverted && (q -= .5);\n        e.pointPadding && (t = Math.ceil(t));\n        A.prototype.translate.apply(a);\n        a.points.forEach(function (d) {\n          var l = N(d.yBottom, q),\n              z = 999 + Math.abs(l),\n              u = d.plotX || 0;\n          z = k(d.plotY, -z, g.len + z);\n          var x = Math.min(z, l),\n              C = Math.max(z, l) - x,\n              L = h,\n              G = u + w,\n              J = t;\n          r && Math.abs(C) < r && (C = r, u = !g.reversed && !d.negative || g.reversed && d.negative, K(f) && K(v) && d.y === f && v <= f && (g.min || 0) < f && (p !== v || (g.max || 0) <= f) && (u = !u), x = Math.abs(x - q) > r ? l - r : q - (u ? r : 0));\n          m(d.options.pointWidth) && (L = J = Math.ceil(d.options.pointWidth), G -= Math.round((L - h) / 2));\n          e.centerInCategory && (G = a.adjustForMissingColumns(G, L, d, n));\n          d.barX = G;\n          d.pointWidth = L;\n          d.tooltipPos = b.inverted ? [k(g.len + g.pos - b.plotLeft - z, g.pos - b.plotLeft, g.len + g.pos - b.plotLeft), c.len + c.pos - b.plotTop - G - J / 2, C] : [c.left - b.plotLeft + G + J / 2, k(z + g.pos - b.plotTop, g.pos - b.plotTop, g.len + g.pos - b.plotTop), C];\n          d.shapeType = a.pointClass.prototype.shapeType || \"rect\";\n          d.shapeArgs = a.crispCol.apply(a, d.isNull ? [G, q, J, 0] : [G, x, J, C]);\n        });\n      };\n\n      q.prototype.drawGraph = function () {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      };\n\n      q.prototype.pointAttribs = function (a, b) {\n        var e = this.options,\n            d = this.pointAttrToOptions || {},\n            c = d.stroke || \"borderColor\",\n            g = d[\"stroke-width\"] || \"borderWidth\",\n            f = a && a.color || this.color,\n            k = a && a[c] || e[c] || f;\n        d = a && a.options.dashStyle || e.dashStyle;\n        var r = a && a[g] || e[g] || this[g] || 0,\n            m = N(a && a.opacity, e.opacity, 1);\n\n        if (a && this.zones.length) {\n          var q = a.getZone();\n          f = a.options.color || q && (q.color || a.nonZonedColor) || this.color;\n          q && (k = q.borderColor || k, d = q.dashStyle || d, r = q.borderWidth || r);\n        }\n\n        b && a && (a = M(e.states[b], a.options.states && a.options.states[b] || {}), b = a.brightness, f = a.color || \"undefined\" !== typeof b && t(f).brighten(a.brightness).get() || f, k = a[c] || k, r = a[g] || r, d = a.dashStyle || d, m = N(a.opacity, m));\n        c = {\n          fill: f,\n          stroke: k,\n          \"stroke-width\": r,\n          opacity: m\n        };\n        d && (c.dashstyle = d);\n        return c;\n      };\n\n      q.prototype.drawPoints = function () {\n        var a = this,\n            b = this.chart,\n            e = a.options,\n            d = b.renderer,\n            c = e.animationLimit || 250,\n            g;\n        a.points.forEach(function (f) {\n          var k = f.graphic,\n              l = !!k,\n              m = k && b.pointCount < c ? \"animate\" : \"attr\";\n\n          if (K(f.plotY) && null !== f.y) {\n            g = f.shapeArgs;\n            k && f.hasNewShapeType() && (k = k.destroy());\n            a.enabledDataSorting && (f.startXPos = a.xAxis.reversed ? -(g ? g.width || 0 : 0) : a.xAxis.width);\n            k || (f.graphic = k = d[f.shapeType](g).add(f.group || a.group)) && a.enabledDataSorting && b.hasRendered && b.pointCount < c && (k.attr({\n              x: f.startXPos\n            }), l = !0, m = \"animate\");\n            if (k && l) k[m](M(g));\n            if (e.borderRadius) k[m]({\n              r: e.borderRadius\n            });\n            b.styledMode || k[m](a.pointAttribs(f, f.selected && \"select\")).shadow(!1 !== f.allowShadow && e.shadow, null, e.stacking && !e.borderRadius);\n            k && (k.addClass(f.getClassName(), !0), k.attr({\n              visibility: f.visible ? \"inherit\" : \"hidden\"\n            }));\n          } else k && (f.graphic = k.destroy());\n        });\n      };\n\n      q.prototype.drawTracker = function () {\n        var a = this,\n            c = a.chart,\n            e = c.pointer,\n            f = function (a) {\n          var b = e.getPointFromEvent(a);\n          \"undefined\" !== typeof b && (e.isDirectTouch = !0, b.onMouseOver(a));\n        },\n            k;\n\n        a.points.forEach(function (a) {\n          k = v(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          k.forEach(function (b) {\n            b.div ? b.div.point = a : b.element.point = a;\n          });\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (d) {\n          if (a[d]) {\n            a[d].addClass(\"highcharts-tracker\").on(\"mouseover\", f).on(\"mouseout\", function (a) {\n              e.onTrackerMouseOut(a);\n            });\n            if (b) a[d].on(\"touchstart\", f);\n            !c.styledMode && a.options.cursor && a[d].css(n).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        d(this, \"afterDrawTracker\");\n      };\n\n      q.prototype.remove = function () {\n        var a = this,\n            b = a.chart;\n        b.hasRendered && b.series.forEach(function (b) {\n          b.type === a.type && (b.isDirty = !0);\n        });\n        A.prototype.remove.apply(a, arguments);\n      };\n\n      q.defaultOptions = M(A.defaultOptions, {\n        borderRadius: 0,\n        centerInCategory: !1,\n        groupPadding: .2,\n        marker: null,\n        pointPadding: .1,\n        minPointLength: 0,\n        cropThreshold: 50,\n        pointRange: null,\n        states: {\n          hover: {\n            halo: !1,\n            brightness: .1\n          },\n          select: {\n            color: \"#cccccc\",\n            borderColor: \"#000000\"\n          }\n        },\n        dataLabels: {\n          align: void 0,\n          verticalAlign: void 0,\n          y: void 0\n        },\n        startFromThreshold: !0,\n        stickyTracking: !1,\n        tooltip: {\n          distance: 6\n        },\n        threshold: 0,\n        borderColor: \"#ffffff\"\n      });\n      return q;\n    }(A);\n\n    f(F.prototype, {\n      cropShoulder: 0,\n      directTouch: !0,\n      drawLegendSymbol: E.drawRectangle,\n      getSymbol: c,\n      negStacks: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    D.registerSeriesType(\"column\", F);\n    \"\";\n    \"\";\n    return F;\n  });\n  O(h, \"Core/Series/DataLabel.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var I = c.getDeferredAnimation,\n        A = h.format,\n        D = B.defined,\n        F = B.extend,\n        y = B.fireEvent,\n        p = B.isArray,\n        t = B.isString,\n        b = B.merge,\n        k = B.objectEach,\n        n = B.pick,\n        m = B.splat,\n        f;\n\n    (function (d) {\n      function c(a, b, e, d, c) {\n        var g = this,\n            f = this.chart,\n            k = this.isCartesian && f.inverted,\n            l = this.enabledDataSorting,\n            m = n(a.dlBox && a.dlBox.centerX, a.plotX),\n            q = a.plotY,\n            h = e.rotation,\n            w = e.align,\n            p = D(m) && D(q) && f.isInsidePlot(m, Math.round(q), {\n          inverted: k,\n          paneCoordinates: !0,\n          series: g\n        }),\n            u = function (e) {\n          l && g.xAxis && !x && g.setDataLabelStartPos(a, b, c, p, e);\n        },\n            x = \"justify\" === n(e.overflow, l ? \"none\" : \"justify\"),\n            v = this.visible && !1 !== a.visible && (a.series.forceDL || l && !x || p || n(e.inside, !!this.options.stacking) && d && f.isInsidePlot(m, k ? d.x + 1 : d.y + d.height - 1, {\n          inverted: k,\n          paneCoordinates: !0,\n          series: g\n        }));\n\n        if (v && D(m) && D(q)) {\n          h && b.attr({\n            align: w\n          });\n          w = b.getBBox(!0);\n          var t = [0, 0];\n          var H = f.renderer.fontMetrics(f.styledMode ? void 0 : e.style.fontSize, b).b;\n          d = F({\n            x: k ? this.yAxis.len - q : m,\n            y: Math.round(k ? this.xAxis.len - m : q),\n            width: 0,\n            height: 0\n          }, d);\n          F(e, {\n            width: w.width,\n            height: w.height\n          });\n          h ? (x = !1, t = f.renderer.rotCorr(H, h), m = {\n            x: d.x + (e.x || 0) + d.width / 2 + t.x,\n            y: d.y + (e.y || 0) + {\n              top: 0,\n              middle: .5,\n              bottom: 1\n            }[e.verticalAlign] * d.height\n          }, t = [w.x - Number(b.attr(\"x\")), w.y - Number(b.attr(\"y\"))], u(m), b[c ? \"attr\" : \"animate\"](m)) : (u(d), b.align(e, void 0, d), m = b.alignAttr);\n          x && 0 <= d.height ? this.justifyDataLabel(b, e, m, w, d, c) : n(e.crop, !0) && (d = m.x, u = m.y, d += t[0], u += t[1], v = f.isInsidePlot(d, u, {\n            paneCoordinates: !0,\n            series: g\n          }) && f.isInsidePlot(d + w.width, u + w.height, {\n            paneCoordinates: !0,\n            series: g\n          }));\n          if (e.shape && !h) b[c ? \"attr\" : \"animate\"]({\n            anchorX: k ? f.plotWidth - a.plotY : a.plotX,\n            anchorY: k ? f.plotHeight - a.plotX : a.plotY\n          });\n        }\n\n        c && l && (b.placed = !1);\n        v || l && !x ? b.show() : (b.hide(), b.placed = !1);\n      }\n\n      function f(a, b) {\n        var e = b.filter;\n        return e ? (b = e.operator, a = a[e.property], e = e.value, \">\" === b && a > e || \"<\" === b && a < e || \">=\" === b && a >= e || \"<=\" === b && a <= e || \"==\" === b && a == e || \"===\" === b && a === e ? !0 : !1) : !0;\n      }\n\n      function h() {\n        var a = this,\n            b = a.chart,\n            e = a.options,\n            d = a.points,\n            c = a.hasRendered || 0,\n            g = b.renderer,\n            q = b.options.chart,\n            h = q.backgroundColor;\n        q = q.plotBackgroundColor;\n        var r = g.getContrast(t(q) && q || t(h) && h || \"#000000\"),\n            w = e.dataLabels,\n            v;\n        h = w.animation;\n        h = w.defer ? I(b, h, a) : {\n          defer: 0,\n          duration: 0\n        };\n        w = H(H(b.options.plotOptions && b.options.plotOptions.series && b.options.plotOptions.series.dataLabels, b.options.plotOptions && b.options.plotOptions[a.type] && b.options.plotOptions[a.type].dataLabels), w);\n        y(this, \"drawDataLabels\");\n\n        if (p(w) || w.enabled || a._hasPointLabels) {\n          var K = a.plotGroup(\"dataLabelsGroup\", \"data-labels\", c ? \"inherit\" : \"hidden\", w.zIndex || 6);\n          K.attr({\n            opacity: +c\n          });\n          !c && (c = a.dataLabelsGroup) && (a.visible && K.show(), c[e.animation ? \"animate\" : \"attr\"]({\n            opacity: 1\n          }, h));\n          d.forEach(function (d) {\n            v = m(H(w, d.dlOptions || d.options && d.options.dataLabels));\n            v.forEach(function (c, l) {\n              var m = c.enabled && (!d.isNull || d.dataLabelOnNull) && f(d, c),\n                  q = d.connectors ? d.connectors[l] : d.connector,\n                  h = d.dataLabels ? d.dataLabels[l] : d.dataLabel,\n                  w = !h,\n                  u = n(c.distance, d.labelDistance);\n\n              if (m) {\n                var p = d.getLabelConfig();\n                var z = n(c[d.formatPrefix + \"Format\"], c.format);\n                p = D(z) ? A(z, p, b) : (c[d.formatPrefix + \"Formatter\"] || c.formatter).call(p, c);\n                z = c.style;\n                var v = c.rotation;\n                b.styledMode || (z.color = n(c.color, z.color, a.color, \"#000000\"), \"contrast\" === z.color ? (d.contrastColor = g.getContrast(d.color || a.color), z.color = !D(u) && c.inside || 0 > u || e.stacking ? d.contrastColor : r) : delete d.contrastColor, e.cursor && (z.cursor = e.cursor));\n                var x = {\n                  r: c.borderRadius || 0,\n                  rotation: v,\n                  padding: c.padding,\n                  zIndex: 1\n                };\n                b.styledMode || (x.fill = c.backgroundColor, x.stroke = c.borderColor, x[\"stroke-width\"] = c.borderWidth);\n                k(x, function (a, b) {\n                  \"undefined\" === typeof a && delete x[b];\n                });\n              }\n\n              !h || m && D(p) && !!h.div === !!c.useHTML && (h.rotation && c.rotation || h.rotation === c.rotation) || (w = !0, d.dataLabel = h = d.dataLabel && d.dataLabel.destroy(), d.dataLabels && (1 === d.dataLabels.length ? delete d.dataLabels : delete d.dataLabels[l]), l || delete d.dataLabel, q && (d.connector = d.connector.destroy(), d.connectors && (1 === d.connectors.length ? delete d.connectors : delete d.connectors[l])));\n              m && D(p) ? (h ? x.text = p : (d.dataLabels = d.dataLabels || [], h = d.dataLabels[l] = v ? g.text(p, 0, 0, c.useHTML).addClass(\"highcharts-data-label\") : g.label(p, 0, 0, c.shape, null, null, c.useHTML, null, \"data-label\"), l || (d.dataLabel = h), h.addClass(\" highcharts-data-label-color-\" + d.colorIndex + \" \" + (c.className || \"\") + (c.useHTML ? \" highcharts-tracker\" : \"\"))), h.options = c, h.attr(x), b.styledMode || h.css(z).shadow(c.shadow), c.textPath && !c.useHTML && (h.setTextPath(d.getDataLabelPath && d.getDataLabelPath(h) || d.graphic, c.textPath), d.dataLabelPath && !c.textPath.enabled && (d.dataLabelPath = d.dataLabelPath.destroy())), h.added || h.add(K), a.alignDataLabel(d, h, c, null, w)) : h && h.hide();\n            });\n          });\n        }\n\n        y(this, \"afterDrawDataLabels\");\n      }\n\n      function N(a, b, e, d, c, g) {\n        var f = this.chart,\n            k = b.align,\n            l = b.verticalAlign,\n            m = a.box ? 0 : a.padding || 0,\n            q = b.x;\n        q = void 0 === q ? 0 : q;\n        var h = b.y;\n        h = void 0 === h ? 0 : h;\n        var n = (e.x || 0) + m;\n\n        if (0 > n) {\n          \"right\" === k && 0 <= q ? (b.align = \"left\", b.inside = !0) : q -= n;\n          var w = !0;\n        }\n\n        n = (e.x || 0) + d.width - m;\n        n > f.plotWidth && (\"left\" === k && 0 >= q ? (b.align = \"right\", b.inside = !0) : q += f.plotWidth - n, w = !0);\n        n = e.y + m;\n        0 > n && (\"bottom\" === l && 0 <= h ? (b.verticalAlign = \"top\", b.inside = !0) : h -= n, w = !0);\n        n = (e.y || 0) + d.height - m;\n        n > f.plotHeight && (\"top\" === l && 0 >= h ? (b.verticalAlign = \"bottom\", b.inside = !0) : h += f.plotHeight - n, w = !0);\n        w && (b.x = q, b.y = h, a.placed = !g, a.align(b, void 0, c));\n        return w;\n      }\n\n      function H(a, d) {\n        var e = [],\n            c;\n        if (p(a) && !p(d)) e = a.map(function (a) {\n          return b(a, d);\n        });else if (p(d) && !p(a)) e = d.map(function (e) {\n          return b(a, e);\n        });else if (p(a) || p(d)) for (c = Math.max(a.length, d.length); c--;) e[c] = b(a[c], d[c]);else e = b(a, d);\n        return e;\n      }\n\n      function q(a, b, e, d, c) {\n        var g = this.chart,\n            f = g.inverted,\n            k = this.xAxis,\n            l = k.reversed,\n            m = f ? b.height / 2 : b.width / 2;\n        a = (a = a.pointWidth) ? a / 2 : 0;\n        b.startXPos = f ? c.x : l ? -m - a : k.width - m + a;\n        b.startYPos = f ? l ? this.yAxis.height - m + a : -m - a : c.y;\n        d ? \"hidden\" === b.visibility && (b.show(), b.attr({\n          opacity: 0\n        }).animate({\n          opacity: 1\n        })) : b.attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, void 0, b.hide);\n        g.hasRendered && (e && b.attr({\n          x: b.startXPos,\n          y: b.startYPos\n        }), b.placed = !0);\n      }\n\n      var w = [];\n\n      d.compose = function (a) {\n        if (-1 === w.indexOf(a)) {\n          var b = a.prototype;\n          w.push(a);\n          b.alignDataLabel = c;\n          b.drawDataLabels = h;\n          b.justifyDataLabel = N;\n          b.setDataLabelStartPos = q;\n        }\n      };\n    })(f || (f = {}));\n\n    \"\";\n    return f;\n  });\n  O(h, \"Series/Column/ColumnDataLabel.js\", [h[\"Core/Series/DataLabel.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var I = h.series,\n        A = B.merge,\n        D = B.pick,\n        F;\n\n    (function (h) {\n      function p(b, c, h, m, f) {\n        var d = this.chart.inverted,\n            k = b.series,\n            n = (k.xAxis ? k.xAxis.len : this.chart.plotSizeX) || 0;\n        k = (k.yAxis ? k.yAxis.len : this.chart.plotSizeY) || 0;\n        var p = b.dlBox || b.shapeArgs,\n            t = D(b.below, b.plotY > D(this.translatedThreshold, k)),\n            H = D(h.inside, !!this.options.stacking);\n        p && (m = A(p), 0 > m.y && (m.height += m.y, m.y = 0), p = m.y + m.height - k, 0 < p && p < m.height && (m.height -= p), d && (m = {\n          x: k - m.y - m.height,\n          y: n - m.x - m.width,\n          width: m.height,\n          height: m.width\n        }), H || (d ? (m.x += t ? 0 : m.width, m.width = 0) : (m.y += t ? m.height : 0, m.height = 0)));\n        h.align = D(h.align, !d || H ? \"center\" : t ? \"right\" : \"left\");\n        h.verticalAlign = D(h.verticalAlign, d || H ? \"middle\" : t ? \"top\" : \"bottom\");\n        I.prototype.alignDataLabel.call(this, b, c, h, m, f);\n        h.inside && b.contrastColor && c.css({\n          color: b.contrastColor\n        });\n      }\n\n      var t = [];\n\n      h.compose = function (b) {\n        c.compose(I);\n        -1 === t.indexOf(b) && (t.push(b), b.prototype.alignDataLabel = p);\n      };\n    })(F || (F = {}));\n\n    return F;\n  });\n  O(h, \"Series/Bar/BarSeries.js\", [h[\"Series/Column/ColumnSeries.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var I = this && this.__extends || function () {\n      var c = function (h, p) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, b) {\n          c.__proto__ = b;\n        } || function (c, b) {\n          for (var k in b) b.hasOwnProperty(k) && (c[k] = b[k]);\n        };\n\n        return c(h, p);\n      };\n\n      return function (h, p) {\n        function t() {\n          this.constructor = h;\n        }\n\n        c(h, p);\n        h.prototype = null === p ? Object.create(p) : (t.prototype = p.prototype, new t());\n      };\n    }(),\n        A = B.extend,\n        D = B.merge;\n\n    B = function (h) {\n      function y() {\n        var c = null !== h && h.apply(this, arguments) || this;\n        c.data = void 0;\n        c.options = void 0;\n        c.points = void 0;\n        return c;\n      }\n\n      I(y, h);\n      y.defaultOptions = D(c.defaultOptions, {});\n      return y;\n    }(c);\n\n    A(B.prototype, {\n      inverted: !0\n    });\n    h.registerSeriesType(\"bar\", B);\n    \"\";\n    return B;\n  });\n  O(h, \"Series/Scatter/ScatterSeries.js\", [h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    var B = this && this.__extends || function () {\n      var c = function (h, b) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, c) {\n          b.__proto__ = c;\n        } || function (b, c) {\n          for (var k in c) c.hasOwnProperty(k) && (b[k] = c[k]);\n        };\n\n        return c(h, b);\n      };\n\n      return function (h, b) {\n        function k() {\n          this.constructor = h;\n        }\n\n        c(h, b);\n        h.prototype = null === b ? Object.create(b) : (k.prototype = b.prototype, new k());\n      };\n    }(),\n        I = c.seriesTypes,\n        A = I.column,\n        D = I.line;\n\n    I = h.addEvent;\n    var F = h.extend,\n        y = h.merge;\n\n    h = function (c) {\n      function h() {\n        var b = null !== c && c.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      B(h, c);\n\n      h.prototype.applyJitter = function () {\n        var b = this,\n            c = this.options.jitter,\n            h = this.points.length;\n        c && this.points.forEach(function (k, f) {\n          [\"x\", \"y\"].forEach(function (d, m) {\n            var n = \"plot\" + d.toUpperCase();\n\n            if (c[d] && !k.isNull) {\n              var p = b[d + \"Axis\"];\n              var v = c[d] * p.transA;\n\n              if (p && !p.isLog) {\n                var t = Math.max(0, k[n] - v);\n                p = Math.min(p.len, k[n] + v);\n                m = 1E4 * Math.sin(f + m * h);\n                k[n] = t + (p - t) * (m - Math.floor(m));\n                \"x\" === d && (k.clientX = k.plotX);\n              }\n            }\n          });\n        });\n      };\n\n      h.prototype.drawGraph = function () {\n        this.options.lineWidth ? c.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());\n      };\n\n      h.defaultOptions = y(D.defaultOptions, {\n        lineWidth: 0,\n        findNearestPointBy: \"xy\",\n        jitter: {\n          x: 0,\n          y: 0\n        },\n        marker: {\n          enabled: !0\n        },\n        tooltip: {\n          headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>',\n          pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n        }\n      });\n      return h;\n    }(D);\n\n    F(h.prototype, {\n      drawTracker: A.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1\n    });\n    I(h, \"afterTranslate\", function () {\n      this.applyJitter();\n    });\n    c.registerSeriesType(\"scatter\", h);\n    \"\";\n    return h;\n  });\n  O(h, \"Series/CenteredUtilities.js\", [h[\"Core/Globals.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var I = c.deg2rad,\n        A = B.fireEvent,\n        D = B.isNumber,\n        F = B.pick,\n        y = B.relativeLength,\n        p;\n\n    (function (c) {\n      c.getCenter = function () {\n        var b = this.options,\n            c = this.chart,\n            n = 2 * (b.slicedOffset || 0),\n            m = c.plotWidth - 2 * n,\n            f = c.plotHeight - 2 * n,\n            d = b.center,\n            p = Math.min(m, f),\n            t = b.thickness,\n            I = b.size,\n            N = b.innerSize || 0;\n        \"string\" === typeof I && (I = parseFloat(I));\n        \"string\" === typeof N && (N = parseFloat(N));\n        b = [F(d[0], \"50%\"), F(d[1], \"50%\"), F(I && 0 > I ? void 0 : b.size, \"100%\"), F(N && 0 > N ? void 0 : b.innerSize || 0, \"0%\")];\n        !c.angular || this instanceof h || (b[3] = 0);\n\n        for (d = 0; 4 > d; ++d) I = b[d], c = 2 > d || 2 === d && /%$/.test(I), b[d] = y(I, [m, f, p, b[2]][d]) + (c ? n : 0);\n\n        b[3] > b[2] && (b[3] = b[2]);\n        D(t) && 2 * t < b[2] && 0 < t && (b[3] = b[2] - 2 * t);\n        A(this, \"afterGetCenter\", {\n          positions: b\n        });\n        return b;\n      };\n\n      c.getStartAndEndRadians = function (b, c) {\n        b = D(b) ? b : 0;\n        c = D(c) && c > b && 360 > c - b ? c : b + 360;\n        return {\n          start: I * (b + -90),\n          end: I * (c + -90)\n        };\n      };\n    })(p || (p = {}));\n\n    \"\";\n    return p;\n  });\n  O(h, \"Series/Pie/PiePoint.js\", [h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var I = this && this.__extends || function () {\n      var b = function (c, h) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, c) {\n          b.__proto__ = c;\n        } || function (b, c) {\n          for (var d in c) c.hasOwnProperty(d) && (b[d] = c[d]);\n        };\n\n        return b(c, h);\n      };\n\n      return function (c, h) {\n        function k() {\n          this.constructor = c;\n        }\n\n        b(c, h);\n        c.prototype = null === h ? Object.create(h) : (k.prototype = h.prototype, new k());\n      };\n    }(),\n        A = c.setAnimation,\n        D = B.addEvent,\n        F = B.defined;\n\n    c = B.extend;\n    var y = B.isNumber,\n        p = B.pick,\n        t = B.relativeLength;\n\n    h = function (b) {\n      function c() {\n        var c = null !== b && b.apply(this, arguments) || this;\n        c.labelDistance = void 0;\n        c.options = void 0;\n        c.series = void 0;\n        return c;\n      }\n\n      I(c, b);\n\n      c.prototype.getConnectorPath = function () {\n        var b = this.labelPosition,\n            c = this.series.options.dataLabels,\n            f = this.connectorShapes,\n            d = c.connectorShape;\n        f[d] && (d = f[d]);\n        return d.call(this, {\n          x: b.final.x,\n          y: b.final.y,\n          alignment: b.alignment\n        }, b.connectorPosition, c);\n      };\n\n      c.prototype.getTranslate = function () {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      };\n\n      c.prototype.haloPath = function (b) {\n        var c = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + b, c.r + b, {\n          innerR: c.r - 1,\n          start: c.start,\n          end: c.end\n        });\n      };\n\n      c.prototype.init = function () {\n        var c = this;\n        b.prototype.init.apply(this, arguments);\n        this.name = p(this.name, \"Slice\");\n\n        var k = function (b) {\n          c.slice(\"select\" === b.type);\n        };\n\n        D(this, \"select\", k);\n        D(this, \"unselect\", k);\n        return this;\n      };\n\n      c.prototype.isValid = function () {\n        return y(this.y) && 0 <= this.y;\n      };\n\n      c.prototype.setVisible = function (b, c) {\n        var f = this,\n            d = this.series,\n            k = d.chart,\n            m = d.options.ignoreHiddenPoint;\n        c = p(c, m);\n        b !== this.visible && (this.visible = this.options.visible = b = \"undefined\" === typeof b ? !this.visible : b, d.options.data[d.data.indexOf(this)] = this.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (d) {\n          if (f[d]) f[d][b ? \"show\" : \"hide\"](b);\n        }), this.legendItem && k.legend.colorizeItem(this, b), b || \"hover\" !== this.state || this.setState(\"\"), m && (d.isDirty = !0), c && k.redraw());\n      };\n\n      c.prototype.slice = function (b, c, f) {\n        var d = this.series;\n        A(f, d.chart);\n        p(c, !0);\n        this.sliced = this.options.sliced = F(b) ? b : !this.sliced;\n        d.options.data[d.data.indexOf(this)] = this.options;\n        this.graphic && this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      };\n\n      return c;\n    }(h);\n\n    c(h.prototype, {\n      connectorShapes: {\n        fixedOffset: function (b, c, h) {\n          var k = c.breakAt;\n          c = c.touchingSliceAt;\n          return [[\"M\", b.x, b.y], h.softConnector ? [\"C\", b.x + (\"left\" === b.alignment ? -5 : 5), b.y, 2 * k.x - c.x, 2 * k.y - c.y, k.x, k.y] : [\"L\", k.x, k.y], [\"L\", c.x, c.y]];\n        },\n        straight: function (b, c) {\n          c = c.touchingSliceAt;\n          return [[\"M\", b.x, b.y], [\"L\", c.x, c.y]];\n        },\n        crookedLine: function (b, c, h) {\n          c = c.touchingSliceAt;\n          var k = this.series,\n              f = k.center[0],\n              d = k.chart.plotWidth,\n              n = k.chart.plotLeft;\n          k = b.alignment;\n          var p = this.shapeArgs.r;\n          h = t(h.crookDistance, 1);\n          d = \"left\" === k ? f + p + (d + n - f - p) * (1 - h) : n + (f - p) * h;\n          h = [\"L\", d, b.y];\n          f = !0;\n          if (\"left\" === k ? d > b.x || d < c.x : d < b.x || d > c.x) f = !1;\n          b = [[\"M\", b.x, b.y]];\n          f && b.push(h);\n          b.push([\"L\", c.x, c.y]);\n          return b;\n        }\n      }\n    });\n    return h;\n  });\n  O(h, \"Series/Pie/PieSeries.js\", [h[\"Series/CenteredUtilities.js\"], h[\"Series/Column/ColumnSeries.js\"], h[\"Core/Globals.js\"], h[\"Core/Legend/LegendSymbol.js\"], h[\"Series/Pie/PiePoint.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Renderer/SVG/Symbols.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A, D, F, y, p) {\n    var t = this && this.__extends || function () {\n      var b = function (d, c) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var c in d) d.hasOwnProperty(c) && (b[c] = d[c]);\n        };\n\n        return b(d, c);\n      };\n\n      return function (d, c) {\n        function f() {\n          this.constructor = d;\n        }\n\n        b(d, c);\n        d.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }(),\n        b = c.getStartAndEndRadians;\n\n    B = B.noop;\n    var k = p.clamp,\n        n = p.extend,\n        m = p.fireEvent,\n        f = p.merge,\n        d = p.pick,\n        v = p.relativeLength;\n\n    p = function (c) {\n      function h() {\n        var b = null !== c && c.apply(this, arguments) || this;\n        b.center = void 0;\n        b.data = void 0;\n        b.maxLabelDistance = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      t(h, c);\n\n      h.prototype.animate = function (b) {\n        var c = this,\n            f = c.points,\n            k = c.startAngleRad;\n        b || f.forEach(function (a) {\n          var b = a.graphic,\n              e = a.shapeArgs;\n          b && e && (b.attr({\n            r: d(a.startR, c.center && c.center[3] / 2),\n            start: k,\n            end: k\n          }), b.animate({\n            r: e.r,\n            start: e.start,\n            end: e.end\n          }, c.options.animation));\n        });\n      };\n\n      h.prototype.drawEmpty = function () {\n        var b = this.startAngleRad,\n            d = this.endAngleRad,\n            c = this.options;\n\n        if (0 === this.total && this.center) {\n          var f = this.center[0];\n          var a = this.center[1];\n          this.graph || (this.graph = this.chart.renderer.arc(f, a, this.center[1] / 2, 0, b, d).addClass(\"highcharts-empty-series\").add(this.group));\n          this.graph.attr({\n            d: y.arc(f, a, this.center[2] / 2, 0, {\n              start: b,\n              end: d,\n              innerR: this.center[3] / 2\n            })\n          });\n          this.chart.styledMode || this.graph.attr({\n            \"stroke-width\": c.borderWidth,\n            fill: c.fillColor || \"none\",\n            stroke: c.color || \"#cccccc\"\n          });\n        } else this.graph && (this.graph = this.graph.destroy());\n      };\n\n      h.prototype.drawPoints = function () {\n        var b = this.chart.renderer;\n        this.points.forEach(function (d) {\n          d.graphic && d.hasNewShapeType() && (d.graphic = d.graphic.destroy());\n          d.graphic || (d.graphic = b[d.shapeType](d.shapeArgs).add(d.series.group), d.delayedRendering = !0);\n        });\n      };\n\n      h.prototype.generatePoints = function () {\n        c.prototype.generatePoints.call(this);\n        this.updateTotals();\n      };\n\n      h.prototype.getX = function (b, d, c) {\n        var f = this.center,\n            a = this.radii ? this.radii[c.index] || 0 : f[2] / 2;\n        b = Math.asin(k((b - f[1]) / (a + c.labelDistance), -1, 1));\n        return f[0] + (d ? -1 : 1) * Math.cos(b) * (a + c.labelDistance) + (0 < c.labelDistance ? (d ? -1 : 1) * this.options.dataLabels.padding : 0);\n      };\n\n      h.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n\n      h.prototype.redrawPoints = function () {\n        var b = this,\n            d = b.chart,\n            c = d.renderer,\n            k = b.options.shadow,\n            a,\n            h,\n            e,\n            m;\n        this.drawEmpty();\n        !k || b.shadowGroup || d.styledMode || (b.shadowGroup = c.g(\"shadow\").attr({\n          zIndex: -1\n        }).add(b.group));\n        b.points.forEach(function (l) {\n          var g = {};\n          h = l.graphic;\n\n          if (!l.isNull && h) {\n            var q = void 0;\n            m = l.shapeArgs;\n            a = l.getTranslate();\n            d.styledMode || (q = l.shadowGroup, k && !q && (q = l.shadowGroup = c.g(\"shadow\").add(b.shadowGroup)), q && q.attr(a), e = b.pointAttribs(l, l.selected && \"select\"));\n            l.delayedRendering ? (h.setRadialReference(b.center).attr(m).attr(a), d.styledMode || h.attr(e).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(k, q), l.delayedRendering = !1) : (h.setRadialReference(b.center), d.styledMode || f(!0, g, e), f(!0, g, m, a), h.animate(g));\n            h.attr({\n              visibility: l.visible ? \"inherit\" : \"hidden\"\n            });\n            h.addClass(l.getClassName(), !0);\n          } else h && (l.graphic = h.destroy());\n        });\n      };\n\n      h.prototype.sortByAngle = function (b, d) {\n        b.sort(function (b, c) {\n          return \"undefined\" !== typeof b.angle && (c.angle - b.angle) * d;\n        });\n      };\n\n      h.prototype.translate = function (c) {\n        m(this, \"translate\");\n        this.generatePoints();\n        var f = this.options,\n            k = f.slicedOffset,\n            h = k + (f.borderWidth || 0),\n            a = b(f.startAngle, f.endAngle),\n            n = this.startAngleRad = a.start;\n        a = (this.endAngleRad = a.end) - n;\n        var e = this.points,\n            p = f.dataLabels.distance;\n        f = f.ignoreHiddenPoint;\n        var l = e.length,\n            g,\n            t = 0;\n        c || (this.center = c = this.getCenter());\n\n        for (g = 0; g < l; g++) {\n          var z = e[g];\n          var r = n + t * a;\n          !z.isValid() || f && !z.visible || (t += z.percentage / 100);\n          var L = n + t * a;\n          var y = {\n            x: c[0],\n            y: c[1],\n            r: c[2] / 2,\n            innerR: c[3] / 2,\n            start: Math.round(1E3 * r) / 1E3,\n            end: Math.round(1E3 * L) / 1E3\n          };\n          z.shapeType = \"arc\";\n          z.shapeArgs = y;\n          z.labelDistance = d(z.options.dataLabels && z.options.dataLabels.distance, p);\n          z.labelDistance = v(z.labelDistance, y.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, z.labelDistance);\n          L = (L + r) / 2;\n          L > 1.5 * Math.PI ? L -= 2 * Math.PI : L < -Math.PI / 2 && (L += 2 * Math.PI);\n          z.slicedTranslation = {\n            translateX: Math.round(Math.cos(L) * k),\n            translateY: Math.round(Math.sin(L) * k)\n          };\n          y = Math.cos(L) * c[2] / 2;\n          var K = Math.sin(L) * c[2] / 2;\n          z.tooltipPos = [c[0] + .7 * y, c[1] + .7 * K];\n          z.half = L < -Math.PI / 2 || L > Math.PI / 2 ? 1 : 0;\n          z.angle = L;\n          r = Math.min(h, z.labelDistance / 5);\n          z.labelPosition = {\n            natural: {\n              x: c[0] + y + Math.cos(L) * z.labelDistance,\n              y: c[1] + K + Math.sin(L) * z.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > z.labelDistance ? \"center\" : z.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: c[0] + y + Math.cos(L) * r,\n                y: c[1] + K + Math.sin(L) * r\n              },\n              touchingSliceAt: {\n                x: c[0] + y,\n                y: c[1] + K\n              }\n            }\n          };\n        }\n\n        m(this, \"afterTranslate\");\n      };\n\n      h.prototype.updateTotals = function () {\n        var b = this.points,\n            d = b.length,\n            c = this.options.ignoreHiddenPoint,\n            f,\n            a = 0;\n\n        for (f = 0; f < d; f++) {\n          var k = b[f];\n          !k.isValid() || c && !k.visible || (a += k.y);\n        }\n\n        this.total = a;\n\n        for (f = 0; f < d; f++) k = b[f], k.percentage = 0 < a && (k.visible || !c) ? k.y / a * 100 : 0, k.total = a;\n      };\n\n      h.defaultOptions = f(D.defaultOptions, {\n        center: [null, null],\n        clip: !1,\n        colorByPoint: !0,\n        dataLabels: {\n          allowOverlap: !0,\n          connectorPadding: 5,\n          connectorShape: \"fixedOffset\",\n          crookDistance: \"70%\",\n          distance: 30,\n          enabled: !0,\n          formatter: function () {\n            return this.point.isNull ? void 0 : this.point.name;\n          },\n          softConnector: !0,\n          x: 0\n        },\n        fillColor: void 0,\n        ignoreHiddenPoint: !0,\n        inactiveOtherPoints: !0,\n        legendType: \"point\",\n        marker: null,\n        size: null,\n        showInLegend: !1,\n        slicedOffset: 10,\n        stickyTracking: !1,\n        tooltip: {\n          followPointer: !0\n        },\n        borderColor: \"#ffffff\",\n        borderWidth: 1,\n        lineWidth: void 0,\n        states: {\n          hover: {\n            brightness: .1\n          }\n        }\n      });\n      return h;\n    }(D);\n\n    n(p.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: void 0,\n      drawLegendSymbol: E.drawRectangle,\n      drawTracker: h.prototype.drawTracker,\n      getCenter: c.getCenter,\n      getSymbol: B,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: h.prototype.pointAttribs,\n      pointClass: A,\n      requireSorting: !1,\n      searchPoint: B,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    F.registerSeriesType(\"pie\", p);\n    \"\";\n    return p;\n  });\n  O(h, \"Series/Pie/PieDataLabel.js\", [h[\"Core/Series/DataLabel.js\"], h[\"Core/Globals.js\"], h[\"Core/Renderer/RendererUtilities.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A) {\n    var D = h.noop,\n        F = B.distribute,\n        y = E.series,\n        p = A.arrayMax,\n        t = A.clamp,\n        b = A.defined,\n        k = A.merge,\n        n = A.pick,\n        m = A.relativeLength,\n        f;\n\n    (function (d) {\n      function f() {\n        var d = this,\n            c = d.data,\n            a = d.chart,\n            f = d.options.dataLabels || {},\n            e = f.connectorPadding,\n            h = a.plotWidth,\n            l = a.plotHeight,\n            g = a.plotLeft,\n            m = Math.round(a.chartWidth / 3),\n            z = d.center,\n            r = z[2] / 2,\n            v = z[1],\n            t = [[], []],\n            H = [0, 0, 0, 0],\n            C = d.dataLabelPositioners,\n            J,\n            K,\n            A,\n            D,\n            I,\n            B,\n            E,\n            M,\n            N,\n            O,\n            X,\n            T;\n        d.visible && (f.enabled || d._hasPointLabels) && (c.forEach(function (a) {\n          a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n            width: \"auto\"\n          }).css({\n            width: \"auto\",\n            textOverflow: \"clip\"\n          }), a.dataLabel.shortened = !1);\n        }), y.prototype.drawDataLabels.apply(d), c.forEach(function (a) {\n          a.dataLabel && (a.visible ? (t[a.half].push(a), a.dataLabel._pos = null, !b(f.style.width) && !b(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > m && (a.dataLabel.css({\n            width: Math.round(.7 * m) + \"px\"\n          }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n        }), t.forEach(function (c, k) {\n          var m = c.length,\n              q = [],\n              p;\n\n          if (m) {\n            d.sortByAngle(c, k - .5);\n\n            if (0 < d.maxLabelDistance) {\n              var w = Math.max(0, v - r - d.maxLabelDistance);\n              var u = Math.min(v + r + d.maxLabelDistance, a.plotHeight);\n              c.forEach(function (b) {\n                0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, v - r - b.labelDistance), b.bottom = Math.min(v + r + b.labelDistance, a.plotHeight), p = b.dataLabel.getBBox().height || 21, b.distributeBox = {\n                  target: b.labelPosition.natural.y - b.top + p / 2,\n                  size: p,\n                  rank: b.y\n                }, q.push(b.distributeBox));\n              });\n              w = u + p - w;\n              F(q, w, w / 5);\n            }\n\n            for (X = 0; X < m; X++) {\n              J = c[X];\n              B = J.labelPosition;\n              D = J.dataLabel;\n              O = !1 === J.visible ? \"hidden\" : \"inherit\";\n              N = w = B.natural.y;\n              q && b(J.distributeBox) && (\"undefined\" === typeof J.distributeBox.pos ? O = \"hidden\" : (E = J.distributeBox.size, N = C.radialDistributionY(J)));\n              delete J.positionIndex;\n              if (f.justify) M = C.justify(J, r, z);else switch (f.alignTo) {\n                case \"connectors\":\n                  M = C.alignToConnectors(c, k, h, g);\n                  break;\n\n                case \"plotEdges\":\n                  M = C.alignToPlotEdges(D, k, h, g);\n                  break;\n\n                default:\n                  M = C.radialDistributionX(d, J, N, w);\n              }\n              D._attr = {\n                visibility: O,\n                align: B.alignment\n              };\n              T = J.options.dataLabels || {};\n              D._pos = {\n                x: M + n(T.x, f.x) + ({\n                  left: e,\n                  right: -e\n                }[B.alignment] || 0),\n                y: N + n(T.y, f.y) - 10\n              };\n              B.final.x = M;\n              B.final.y = N;\n              n(f.crop, !0) && (I = D.getBBox().width, w = null, M - I < e && 1 === k ? (w = Math.round(I - M + e), H[3] = Math.max(w, H[3])) : M + I > h - e && 0 === k && (w = Math.round(M + I - h + e), H[1] = Math.max(w, H[1])), 0 > N - E / 2 ? H[0] = Math.max(Math.round(-N + E / 2), H[0]) : N + E / 2 > l && (H[2] = Math.max(Math.round(N + E / 2 - l), H[2])), D.sideOverflow = w);\n            }\n          }\n        }), 0 === p(H) || this.verifyDataLabelOverflow(H)) && (this.placeDataLabels(), this.points.forEach(function (b) {\n          T = k(f, b.options.dataLabels);\n\n          if (K = n(T.connectorWidth, 1)) {\n            var e;\n            A = b.connector;\n\n            if ((D = b.dataLabel) && D._pos && b.visible && 0 < b.labelDistance) {\n              O = D._attr.visibility;\n              if (e = !A) b.connector = A = a.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + b.colorIndex + (b.className ? \" \" + b.className : \"\")).add(d.dataLabelsGroup), a.styledMode || A.attr({\n                \"stroke-width\": K,\n                stroke: T.connectorColor || b.color || \"#666666\"\n              });\n              A[e ? \"attr\" : \"animate\"]({\n                d: b.getConnectorPath()\n              });\n              A.attr(\"visibility\", O);\n            } else A && (b.connector = A.destroy());\n          }\n        }));\n      }\n\n      function h() {\n        this.points.forEach(function (b) {\n          var d = b.dataLabel,\n              a;\n          d && b.visible && ((a = d._pos) ? (d.sideOverflow && (d._attr.width = Math.max(d.getBBox().width - d.sideOverflow, 0), d.css({\n            width: d._attr.width + \"px\",\n            textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n          }), d.shortened = !0), d.attr(d._attr), d[d.moved ? \"animate\" : \"attr\"](a), d.moved = !0) : d && d.attr({\n            y: -9999\n          }));\n          delete b.distributeBox;\n        }, this);\n      }\n\n      function A(b) {\n        var d = this.center,\n            a = this.options,\n            c = a.center,\n            e = a.minSize || 80,\n            f = null !== a.size;\n\n        if (!f) {\n          if (null !== c[0]) var k = Math.max(d[2] - Math.max(b[1], b[3]), e);else k = Math.max(d[2] - b[1] - b[3], e), d[0] += (b[3] - b[1]) / 2;\n          null !== c[1] ? k = t(k, e, d[2] - Math.max(b[0], b[2])) : (k = t(k, e, d[2] - b[0] - b[2]), d[1] += (b[0] - b[2]) / 2);\n          k < d[2] ? (d[2] = k, d[3] = Math.min(a.thickness ? Math.max(0, k - 2 * a.thickness) : Math.max(0, m(a.innerSize || 0, k)), k), this.translate(d), this.drawDataLabels && this.drawDataLabels()) : f = !0;\n        }\n\n        return f;\n      }\n\n      var I = [],\n          H = {\n        radialDistributionY: function (b) {\n          return b.top + b.distributeBox.pos;\n        },\n        radialDistributionX: function (b, d, a, c) {\n          return b.getX(a < d.top + 2 || a > d.bottom - 2 ? c : a, d.half, d);\n        },\n        justify: function (b, d, a) {\n          return a[0] + (b.half ? -1 : 1) * (d + b.labelDistance);\n        },\n        alignToPlotEdges: function (b, d, a, c) {\n          b = b.getBBox().width;\n          return d ? b + c : a - b - c;\n        },\n        alignToConnectors: function (b, d, a, c) {\n          var e = 0,\n              f;\n          b.forEach(function (a) {\n            f = a.dataLabel.getBBox().width;\n            f > e && (e = f);\n          });\n          return d ? e + c : a - e - c;\n        }\n      };\n\n      d.compose = function (b) {\n        c.compose(y);\n        -1 === I.indexOf(b) && (I.push(b), b = b.prototype, b.dataLabelPositioners = H, b.alignDataLabel = D, b.drawDataLabels = f, b.placeDataLabels = h, b.verifyDataLabelOverflow = A);\n      };\n    })(f || (f = {}));\n\n    return f;\n  });\n  O(h, \"Extensions/OverlappingDataLabels.js\", [h[\"Core/Chart/Chart.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    function I(c, b) {\n      var k = !1;\n\n      if (c) {\n        var h = c.newOpacity;\n        c.oldOpacity !== h && (c.alignAttr && c.placed ? (c[h ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), k = !0, c.alignAttr.opacity = h, c[c.isOld ? \"animate\" : \"attr\"](c.alignAttr, null, function () {\n          b.styledMode || c.css({\n            pointerEvents: h ? \"auto\" : \"none\"\n          });\n        }), A(b, \"afterHideOverlappingLabel\")) : c.attr({\n          opacity: h\n        }));\n        c.isOld = !0;\n      }\n\n      return k;\n    }\n\n    var E = h.addEvent,\n        A = h.fireEvent,\n        D = h.isArray,\n        F = h.isNumber,\n        y = h.objectEach,\n        p = h.pick;\n    E(c, \"render\", function () {\n      var c = this,\n          b = [];\n      (this.labelCollectors || []).forEach(function (c) {\n        b = b.concat(c());\n      });\n      (this.yAxis || []).forEach(function (c) {\n        c.stacking && c.options.stackLabels && !c.options.stackLabels.allowOverlap && y(c.stacking.stacks, function (c) {\n          y(c, function (c) {\n            c.label && b.push(c.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (k) {\n        var h = k.options.dataLabels;\n        k.visible && (!1 !== h.enabled || k._hasPointLabels) && (h = function (k) {\n          return k.forEach(function (f) {\n            f.visible && (D(f.dataLabels) ? f.dataLabels : f.dataLabel ? [f.dataLabel] : []).forEach(function (d) {\n              var k = d.options;\n              d.labelrank = p(k.labelrank, f.labelrank, f.shapeArgs && f.shapeArgs.height);\n              k.allowOverlap ? (d.oldOpacity = d.opacity, d.newOpacity = 1, I(d, c)) : b.push(d);\n            });\n          });\n        }, h(k.nodes || []), h(k.points));\n      });\n      this.hideOverlappingLabels(b);\n    });\n\n    c.prototype.hideOverlappingLabels = function (c) {\n      var b = this,\n          k = c.length,\n          h = b.renderer,\n          m,\n          f,\n          d,\n          p = !1;\n\n      var t = function (b) {\n        var d,\n            c = b.box ? 0 : b.padding || 0,\n            a = d = 0,\n            f;\n\n        if (b && (!b.alignAttr || b.placed)) {\n          var e = b.alignAttr || {\n            x: b.attr(\"x\"),\n            y: b.attr(\"y\")\n          };\n          var k = b.parentGroup;\n          b.width || (d = b.getBBox(), b.width = d.width, b.height = d.height, d = h.fontMetrics(null, b.element).h);\n          var l = b.width - 2 * c;\n          (f = {\n            left: \"0\",\n            center: \"0.5\",\n            right: \"1\"\n          }[b.alignValue]) ? a = +f * l : F(b.x) && Math.round(b.x) !== b.translateX && (a = b.x - b.translateX);\n          return {\n            x: e.x + (k.translateX || 0) + c - (a || 0),\n            y: e.y + (k.translateY || 0) + c - d,\n            width: b.width - 2 * c,\n            height: b.height - 2 * c\n          };\n        }\n      };\n\n      for (f = 0; f < k; f++) if (m = c[f]) m.oldOpacity = m.opacity, m.newOpacity = 1, m.absoluteBox = t(m);\n\n      c.sort(function (b, d) {\n        return (d.labelrank || 0) - (b.labelrank || 0);\n      });\n\n      for (f = 0; f < k; f++) {\n        var y = (t = c[f]) && t.absoluteBox;\n\n        for (m = f + 1; m < k; ++m) {\n          var D = (d = c[m]) && d.absoluteBox;\n          !y || !D || t === d || 0 === t.newOpacity || 0 === d.newOpacity || \"hidden\" === t.visibility || \"hidden\" === d.visibility || D.x >= y.x + y.width || D.x + D.width <= y.x || D.y >= y.y + y.height || D.y + D.height <= y.y || ((t.labelrank < d.labelrank ? t : d).newOpacity = 0);\n        }\n      }\n\n      c.forEach(function (d) {\n        I(d, b) && (p = !0);\n      });\n      p && A(b, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  O(h, \"Core/Responsive.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    var h = c.extend,\n        B = c.find,\n        E = c.isArray,\n        A = c.isObject,\n        D = c.merge,\n        F = c.objectEach,\n        y = c.pick,\n        p = c.splat,\n        t = c.uniqueKey,\n        b;\n\n    (function (b) {\n      var c = [];\n\n      b.compose = function (b) {\n        -1 === c.indexOf(b) && (c.push(b), h(b.prototype, k.prototype));\n        return b;\n      };\n\n      var k = function () {\n        function b() {}\n\n        b.prototype.currentOptions = function (b) {\n          function d(b, f, k, h) {\n            var a;\n            F(b, function (b, e) {\n              if (!h && -1 < c.collectionsWithUpdate.indexOf(e) && f[e]) for (b = p(b), k[e] = [], a = 0; a < Math.max(b.length, f[e].length); a++) f[e][a] && (void 0 === b[a] ? k[e][a] = f[e][a] : (k[e][a] = {}, d(b[a], f[e][a], k[e][a], h + 1)));else A(b) ? (k[e] = E(b) ? [] : {}, d(b, f[e] || {}, k[e], h + 1)) : k[e] = \"undefined\" === typeof f[e] ? null : f[e];\n            });\n          }\n\n          var c = this,\n              f = {};\n          d(b, this.options, f, 0);\n          return f;\n        };\n\n        b.prototype.matchResponsiveRule = function (b, c) {\n          var d = b.condition;\n          (d.callback || function () {\n            return this.chartWidth <= y(d.maxWidth, Number.MAX_VALUE) && this.chartHeight <= y(d.maxHeight, Number.MAX_VALUE) && this.chartWidth >= y(d.minWidth, 0) && this.chartHeight >= y(d.minHeight, 0);\n          }).call(this) && c.push(b._id);\n        };\n\n        b.prototype.setResponsive = function (b, c) {\n          var d = this,\n              f = this.options.responsive,\n              k = this.currentResponsive,\n              h = [];\n          !c && f && f.rules && f.rules.forEach(function (b) {\n            \"undefined\" === typeof b._id && (b._id = t());\n            d.matchResponsiveRule(b, h);\n          }, this);\n          c = D.apply(void 0, h.map(function (b) {\n            return B((f || {}).rules || [], function (d) {\n              return d._id === b;\n            });\n          }).map(function (b) {\n            return b && b.chartOptions;\n          }));\n          c.isResponsiveOptions = !0;\n          h = h.toString() || void 0;\n          h !== (k && k.ruleIds) && (k && this.update(k.undoOptions, b, !0), h ? (k = this.currentOptions(c), k.isResponsiveOptions = !0, this.currentResponsive = {\n            ruleIds: h,\n            mergedOptions: c,\n            undoOptions: k\n          }, this.update(c, b, !0)) : this.currentResponsive = void 0);\n        };\n\n        return b;\n      }();\n    })(b || (b = {}));\n\n    \"\";\n    \"\";\n    return b;\n  });\n  O(h, \"masters/highcharts.src.js\", [h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Animation/Fx.js\"], h[\"Core/Animation/AnimationUtilities.js\"], h[\"Core/Renderer/HTML/AST.js\"], h[\"Core/FormatUtilities.js\"], h[\"Core/Renderer/RendererUtilities.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Renderer/SVG/SVGRenderer.js\"], h[\"Core/Renderer/HTML/HTMLElement.js\"], h[\"Core/Renderer/HTML/HTMLRenderer.js\"], h[\"Core/Axis/Axis.js\"], h[\"Core/Axis/DateTimeAxis.js\"], h[\"Core/Axis/LogarithmicAxis.js\"], h[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], h[\"Core/Axis/Tick.js\"], h[\"Core/Tooltip.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Pointer.js\"], h[\"Core/MSPointer.js\"], h[\"Core/Legend/Legend.js\"], h[\"Core/Chart/Chart.js\"], h[\"Core/Axis/Stacking/StackingAxis.js\"], h[\"Core/Axis/Stacking/StackItem.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Series/Column/ColumnSeries.js\"], h[\"Series/Column/ColumnDataLabel.js\"], h[\"Series/Pie/PieSeries.js\"], h[\"Series/Pie/PieDataLabel.js\"], h[\"Core/Series/DataLabel.js\"], h[\"Core/Responsive.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Time.js\"]], function (c, h, B, E, A, D, F, y, p, t, b, k, n, m, f, d, v, K, M, N, H, q, w, a, x, e, u, l, g, G, z, r, L, Q, S) {\n    c.animate = A.animate;\n    c.animObject = A.animObject;\n    c.getDeferredAnimation = A.getDeferredAnimation;\n    c.setAnimation = A.setAnimation;\n    c.stop = A.stop;\n    c.timers = E.timers;\n    c.AST = D;\n    c.Axis = n;\n    c.Chart = w;\n    c.chart = w.chart;\n    c.Fx = E;\n    c.Legend = q;\n    c.PlotLineOrBand = d;\n    c.Point = M;\n    c.Pointer = H.isRequired() ? H : N;\n    c.Series = e;\n    c.StackItem = x;\n    c.SVGElement = p;\n    c.SVGRenderer = t;\n    c.Tick = v;\n    c.Time = S;\n    c.Tooltip = K;\n    c.Color = Q;\n    c.color = Q.parse;\n    k.compose(t);\n    b.compose(p);\n    c.defaultOptions = B.defaultOptions;\n    c.getOptions = B.getOptions;\n    c.time = B.defaultTime;\n    c.setOptions = B.setOptions;\n    c.dateFormat = F.dateFormat;\n    c.format = F.format;\n    c.numberFormat = F.numberFormat;\n    c.addEvent = h.addEvent;\n    c.arrayMax = h.arrayMax;\n    c.arrayMin = h.arrayMin;\n    c.attr = h.attr;\n    c.clearTimeout = h.clearTimeout;\n    c.correctFloat = h.correctFloat;\n    c.createElement = h.createElement;\n    c.css = h.css;\n    c.defined = h.defined;\n    c.destroyObjectProperties = h.destroyObjectProperties;\n    c.discardElement = h.discardElement;\n    c.distribute = y.distribute;\n    c.erase = h.erase;\n    c.error = h.error;\n    c.extend = h.extend;\n    c.extendClass = h.extendClass;\n    c.find = h.find;\n    c.fireEvent = h.fireEvent;\n    c.getMagnitude = h.getMagnitude;\n    c.getStyle = h.getStyle;\n    c.inArray = h.inArray;\n    c.isArray = h.isArray;\n    c.isClass = h.isClass;\n    c.isDOMElement = h.isDOMElement;\n    c.isFunction = h.isFunction;\n    c.isNumber = h.isNumber;\n    c.isObject = h.isObject;\n    c.isString = h.isString;\n    c.keys = h.keys;\n    c.merge = h.merge;\n    c.normalizeTickInterval = h.normalizeTickInterval;\n    c.objectEach = h.objectEach;\n    c.offset = h.offset;\n    c.pad = h.pad;\n    c.pick = h.pick;\n    c.pInt = h.pInt;\n    c.relativeLength = h.relativeLength;\n    c.removeEvent = h.removeEvent;\n    c.seriesType = u.seriesType;\n    c.splat = h.splat;\n    c.stableSort = h.stableSort;\n    c.syncTimeout = h.syncTimeout;\n    c.timeUnits = h.timeUnits;\n    c.uniqueKey = h.uniqueKey;\n    c.useSerialIds = h.useSerialIds;\n    c.wrap = h.wrap;\n    g.compose(l);\n    r.compose(e);\n    m.compose(n);\n    f.compose(n);\n    z.compose(G);\n    d.compose(n);\n    L.compose(w);\n    a.compose(n, w, e);\n    return c;\n  });\n  O(h, \"Series/XRange/XRangeSeriesDefaults.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    var h = c.correctFloat,\n        B = c.isNumber,\n        E = c.isObject;\n    \"\";\n    return {\n      colorByPoint: !0,\n      dataLabels: {\n        formatter: function () {\n          var c = this.point.partialFill;\n          E(c) && (c = c.amount);\n          if (B(c) && 0 < c) return h(100 * c) + \"%\";\n        },\n        inside: !0,\n        verticalAlign: \"middle\"\n      },\n      tooltip: {\n        headerFormat: '<span style=\"font-size: 10px\">{point.x} - {point.x2}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.yCategory}</b><br/>'\n      },\n      borderRadius: 3,\n      pointRange: 0\n    };\n  });\n  O(h, \"Series/XRange/XRangePoint.js\", [h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    var B = this && this.__extends || function () {\n      var c = function (h, A) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, h) {\n          c.__proto__ = h;\n        } || function (c, h) {\n          for (var p in h) h.hasOwnProperty(p) && (c[p] = h[p]);\n        };\n\n        return c(h, A);\n      };\n\n      return function (h, A) {\n        function y() {\n          this.constructor = h;\n        }\n\n        c(h, A);\n        h.prototype = null === A ? Object.create(A) : (y.prototype = A.prototype, new y());\n      };\n    }(),\n        E = c.series.prototype.pointClass.prototype;\n\n    h = h.extend;\n\n    c = function (c) {\n      function h() {\n        var h = null !== c && c.apply(this, arguments) || this;\n        h.options = void 0;\n        h.series = void 0;\n        return h;\n      }\n\n      B(h, c);\n\n      h.getColorByCategory = function (c, h) {\n        var p = c.options.colors || c.chart.options.colors;\n        c = h.y % (p ? p.length : c.chart.options.chart.colorCount);\n        return {\n          colorIndex: c,\n          color: p && p[c]\n        };\n      };\n\n      h.prototype.resolveColor = function () {\n        var c = this.series;\n\n        if (c.options.colorByPoint && !this.options.color) {\n          var y = h.getColorByCategory(c, this);\n          c.chart.styledMode || (this.color = y.color);\n          this.options.colorIndex || (this.colorIndex = y.colorIndex);\n        } else this.color || (this.color = c.color);\n      };\n\n      h.prototype.init = function () {\n        E.init.apply(this, arguments);\n        this.y || (this.y = 0);\n        return this;\n      };\n\n      h.prototype.setState = function () {\n        E.setState.apply(this, arguments);\n        this.series.drawPoint(this, this.series.getAnimationVerb());\n      };\n\n      h.prototype.getLabelConfig = function () {\n        var c = E.getLabelConfig.call(this),\n            h = this.series.yAxis.categories;\n        c.x2 = this.x2;\n        c.yCategory = this.yCategory = h && h[this.y];\n        return c;\n      };\n\n      h.prototype.isValid = function () {\n        return \"number\" === typeof this.x && \"number\" === typeof this.x2;\n      };\n\n      return h;\n    }(c.seriesTypes.column.prototype.pointClass);\n\n    h(c.prototype, {\n      ttBelow: !1,\n      tooltipDateKeys: [\"x\", \"x2\"]\n    });\n    \"\";\n    return c;\n  });\n  O(h, \"Series/XRange/XRangeSeries.js\", [h[\"Core/Globals.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"], h[\"Series/XRange/XRangeSeriesDefaults.js\"], h[\"Series/XRange/XRangePoint.js\"]], function (c, h, B, E, A, D) {\n    function F() {\n      if (this.isXAxis) {\n        var b = M(this.dataMax, -Number.MAX_VALUE);\n\n        for (var d = 0, c = this.series; d < c.length; d++) {\n          var a = c[d];\n\n          if (a.x2Data) {\n            var f = 0;\n\n            for (a = a.x2Data; f < a.length; f++) {\n              var e = a[f];\n\n              if (e && e > b) {\n                b = e;\n                var k = !0;\n              }\n            }\n          }\n        }\n\n        k && (this.dataMax = b);\n      }\n    }\n\n    var y = this && this.__extends || function () {\n      var b = function (d, c) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var e in b) b.hasOwnProperty(e) && (a[e] = b[e]);\n        };\n\n        return b(d, c);\n      };\n\n      return function (d, c) {\n        function a() {\n          this.constructor = d;\n        }\n\n        b(d, c);\n        d.prototype = null === c ? Object.create(c) : (a.prototype = c.prototype, new a());\n      };\n    }();\n\n    c = c.noop;\n    var p = h.parse,\n        t = B.series.prototype,\n        b = B.seriesTypes.column,\n        k = E.addEvent,\n        n = E.clamp,\n        m = E.defined;\n    h = E.extend;\n    var f = E.find,\n        d = E.isNumber,\n        v = E.isObject,\n        K = E.merge,\n        M = E.pick,\n        I = [];\n\n    E = function (c) {\n      function h() {\n        var b = null !== c && c.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      y(h, c);\n\n      h.compose = function (b) {\n        -1 === I.indexOf(b) && (I.push(b), k(b, \"afterGetSeriesExtremes\", F));\n      };\n\n      h.prototype.init = function () {\n        c.prototype.init.apply(this, arguments);\n        this.options.stacking = void 0;\n      };\n\n      h.prototype.getColumnMetrics = function () {\n        var b = this,\n            a = function () {\n          for (var a = 0, d = b.chart.series; a < d.length; a++) {\n            var c = d[a],\n                g = c.xAxis;\n            c.xAxis = c.yAxis;\n            c.yAxis = g;\n          }\n        };\n\n        a();\n        var d = c.prototype.getColumnMetrics.call(this);\n        a();\n        return d;\n      };\n\n      h.prototype.cropData = function (b, a, d, e) {\n        a = t.cropData.call(this, this.x2Data, a, d, e);\n        a.xData = b.slice(a.start, a.end);\n        return a;\n      };\n\n      h.prototype.findPointIndex = function (b) {\n        var a = this.cropStart,\n            c = this.points,\n            e = b.id;\n        if (e) var k = (k = f(c, function (a) {\n          return a.id === e;\n        })) ? k.index : void 0;\n        \"undefined\" === typeof k && (k = (k = f(c, function (a) {\n          return a.x === b.x && a.x2 === b.x2 && !a.touched;\n        })) ? k.index : void 0);\n        this.cropped && d(k) && d(a) && k >= a && (k -= a);\n        return k;\n      };\n\n      h.prototype.translatePoint = function (b) {\n        var a = this.xAxis,\n            c = this.yAxis,\n            e = this.columnMetrics,\n            f = this.options,\n            k = f.minPointLength || 0,\n            g = (b.shapeArgs && b.shapeArgs.width || 0) / 2,\n            h = this.pointXOffset = e.offset,\n            q = M(b.x2, b.x + (b.len || 0)),\n            r = b.plotX,\n            p = a.translate(q, 0, 0, 0, 1);\n        q = Math.abs(p - r);\n        var t = this.chart.inverted,\n            w = M(f.borderWidth, 1) % 2 / 2,\n            C = e.offset,\n            J = Math.round(e.width);\n        k && (k -= q, 0 > k && (k = 0), r -= k / 2, p += k / 2);\n        r = Math.max(r, -10);\n        p = n(p, -10, a.len + 10);\n        m(b.options.pointWidth) && (C -= (Math.ceil(b.options.pointWidth) - J) / 2, J = Math.ceil(b.options.pointWidth));\n        f.pointPlacement && d(b.plotY) && c.categories && (b.plotY = c.translate(b.y, 0, 1, 0, 1, f.pointPlacement));\n        f = Math.floor(Math.min(r, p)) + w;\n        f = {\n          x: f,\n          y: Math.floor(b.plotY + C) + w,\n          width: Math.floor(Math.max(r, p)) + w - f,\n          height: J,\n          r: this.options.borderRadius\n        };\n        b.shapeArgs = f;\n        t ? b.tooltipPos[1] += h + g : b.tooltipPos[0] -= g + h - f.width / 2;\n        g = f.x;\n        h = g + f.width;\n        0 > g || h > a.len ? (g = n(g, 0, a.len), h = n(h, 0, a.len), p = h - g, b.dlBox = K(f, {\n          x: g,\n          width: h - g,\n          centerX: p ? p / 2 : null\n        })) : b.dlBox = null;\n        g = b.tooltipPos;\n        h = t ? 1 : 0;\n        p = t ? 0 : 1;\n        e = this.columnMetrics ? this.columnMetrics.offset : -e.width / 2;\n        g[h] = t ? g[h] + f.width / 2 : g[h] + (a.reversed ? -1 : 0) * f.width;\n        g[p] = n(g[p] + (t ? -1 : 1) * e, 0, c.len - 1);\n        if (c = b.partialFill) v(c) && (c = c.amount), d(c) || (c = 0), b.partShapeArgs = K(f, {\n          r: this.options.borderRadius\n        }), r = Math.max(Math.round(q * c + b.plotX - r), 0), b.clipRectArgs = {\n          x: a.reversed ? f.x + q - r : f.x,\n          y: f.y,\n          width: r,\n          height: f.height\n        };\n      };\n\n      h.prototype.translate = function () {\n        c.prototype.translate.apply(this, arguments);\n\n        for (var b = 0, a = this.points; b < a.length; b++) this.translatePoint(a[b]);\n      };\n\n      h.prototype.drawPoint = function (b, a) {\n        var d = this.options,\n            e = this.chart.renderer,\n            c = b.shapeType,\n            f = b.shapeArgs,\n            g = b.partShapeArgs,\n            k = b.clipRectArgs,\n            h = d.stacking && !d.borderRadius,\n            r = b.state,\n            m = d.states[r || \"normal\"] || {},\n            n = \"undefined\" === typeof r ? \"attr\" : a;\n        r = this.pointAttribs(b, r);\n        m = M(this.chart.options.chart.animation, m.animation);\n        var q = b.graphic,\n            t = b.partialFill;\n        if (b.isNull || !1 === b.visible) q && (b.graphic = q.destroy());else {\n          if (q) q.rect[a](f);else b.graphic = q = e.g(\"point\").addClass(b.getClassName()).add(b.group || this.group), q.rect = e[c](K(f)).addClass(b.getClassName()).addClass(\"highcharts-partfill-original\").add(q);\n          g && (q.partRect ? (q.partRect[a](K(g)), q.partialClipRect[a](K(k))) : (q.partialClipRect = e.clipRect(k.x, k.y, k.width, k.height), q.partRect = e[c](g).addClass(\"highcharts-partfill-overlay\").add(q).clip(q.partialClipRect)));\n          this.chart.styledMode || (q.rect[a](r, m).shadow(d.shadow, null, h), g && (v(t) || (t = {}), v(d.partialFill) && (t = K(d.partialFill, t)), b = t.fill || p(r.fill).brighten(-.3).get() || p(b.color || this.color).brighten(-.3).get(), r.fill = b, q.partRect[n](r, m).shadow(d.shadow, null, h)));\n        }\n      };\n\n      h.prototype.drawPoints = function () {\n        for (var b = this.getAnimationVerb(), a = 0, d = this.points; a < d.length; a++) this.drawPoint(d[a], b);\n      };\n\n      h.prototype.getAnimationVerb = function () {\n        return this.chart.pointCount < (this.options.animationLimit || 250) ? \"animate\" : \"attr\";\n      };\n\n      h.prototype.isPointInside = function (b) {\n        var a = b.shapeArgs,\n            d = b.plotX,\n            e = b.plotY;\n        return a ? \"undefined\" !== typeof d && \"undefined\" !== typeof e && 0 <= e && e <= this.yAxis.len && 0 <= (a.x || 0) + (a.width || 0) && d <= this.xAxis.len : c.prototype.isPointInside.apply(this, arguments);\n      };\n\n      h.defaultOptions = K(b.defaultOptions, A);\n      return h;\n    }(b);\n\n    h(E.prototype, {\n      pointClass: D,\n      cropShoulder: 1,\n      getExtremesFromAll: !0,\n      parallelArrays: [\"x\", \"x2\", \"y\"],\n      requireSorting: !1,\n      type: \"xrange\",\n      animate: t.animate,\n      autoIncrement: c,\n      buildKDTree: c\n    });\n    B.registerSeriesType(\"xrange\", E);\n    return E;\n  });\n  O(h, \"Series/Gantt/GanttPoint.js\", [h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    var B = this && this.__extends || function () {\n      var c = function (h, A) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, h) {\n          c.__proto__ = h;\n        } || function (c, h) {\n          for (var p in h) h.hasOwnProperty(p) && (c[p] = h[p]);\n        };\n\n        return c(h, A);\n      };\n\n      return function (h, A) {\n        function y() {\n          this.constructor = h;\n        }\n\n        c(h, A);\n        h.prototype = null === A ? Object.create(A) : (y.prototype = A.prototype, new y());\n      };\n    }(),\n        E = h.pick;\n\n    return function (c) {\n      function h() {\n        var h = null !== c && c.apply(this, arguments) || this;\n        h.options = void 0;\n        h.series = void 0;\n        return h;\n      }\n\n      B(h, c);\n\n      h.setGanttPointAliases = function (c) {\n        function h(h, t) {\n          \"undefined\" !== typeof t && (c[h] = t);\n        }\n\n        h(\"x\", E(c.start, c.x));\n        h(\"x2\", E(c.end, c.x2));\n        h(\"partialFill\", E(c.completed, c.partialFill));\n      };\n\n      h.prototype.applyOptions = function (A, y) {\n        A = c.prototype.applyOptions.call(this, A, y);\n        h.setGanttPointAliases(A);\n        return A;\n      };\n\n      h.prototype.isValid = function () {\n        return (\"number\" === typeof this.start || \"number\" === typeof this.x) && (\"number\" === typeof this.end || \"number\" === typeof this.x2 || this.milestone);\n      };\n\n      return h;\n    }(c.seriesTypes.xrange.prototype.pointClass);\n  });\n  O(h, \"Core/Axis/BrokenAxis.js\", [h[\"Core/Axis/Stacking/StackItem.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    var B = h.addEvent,\n        E = h.find,\n        A = h.fireEvent,\n        D = h.isArray,\n        F = h.isNumber,\n        y = h.pick,\n        p;\n\n    (function (h) {\n      function b() {\n        \"undefined\" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);\n      }\n\n      function k() {\n        this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);\n      }\n\n      function n() {\n        var b = this.brokenAxis;\n\n        if (b && b.hasBreaks) {\n          for (var d = this.tickPositions, c = this.tickPositions.info, a = [], f = 0; f < d.length; f++) b.isInAnyBreak(d[f]) || a.push(d[f]);\n\n          this.tickPositions = a;\n          this.tickPositions.info = c;\n        }\n      }\n\n      function m() {\n        this.brokenAxis || (this.brokenAxis = new I(this));\n      }\n\n      function f() {\n        var b = this.options.connectNulls,\n            d = this.points,\n            c = this.xAxis,\n            a = this.yAxis;\n        if (this.isDirty) for (var f = d.length; f--;) {\n          var e = d[f],\n              k = !(null === e.y && !1 === b) && (c && c.brokenAxis && c.brokenAxis.isInAnyBreak(e.x, !0) || a && a.brokenAxis && a.brokenAxis.isInAnyBreak(e.y, !0));\n          e.visible = k ? !1 : !1 !== e.options.visible;\n        }\n      }\n\n      function d() {\n        this.drawBreaks(this.xAxis, [\"x\"]);\n        this.drawBreaks(this.yAxis, y(this.pointArrayMap, [\"y\"]));\n      }\n\n      function p(b, d) {\n        var c = this,\n            a = c.points,\n            f,\n            e,\n            k,\n            h;\n\n        if (b && b.brokenAxis && b.brokenAxis.hasBreaks) {\n          var g = b.brokenAxis;\n          d.forEach(function (d) {\n            f = g && g.breakArray || [];\n            e = b.isXAxis ? b.min : y(c.options.threshold, b.min);\n            a.forEach(function (a) {\n              h = y(a[\"stack\" + d.toUpperCase()], a[d]);\n              f.forEach(function (d) {\n                if (F(e) && F(h)) {\n                  k = !1;\n                  if (e < d.from && h > d.to || e > d.from && h < d.from) k = \"pointBreak\";else if (e < d.from && h > d.from && h < d.to || e > d.from && h > d.to && h < d.from) k = \"pointInBreak\";\n                  k && A(b, k, {\n                    point: a,\n                    brk: d\n                  });\n                }\n              });\n            });\n          });\n        }\n      }\n\n      function t() {\n        var b = this.currentDataGrouping,\n            d = b && b.gapSize;\n        b = this.points.slice();\n        var f = this.yAxis,\n            a = this.options.gapSize,\n            k = b.length - 1,\n            e;\n        if (a && 0 < k) for (\"value\" !== this.options.gapUnit && (a *= this.basePointRange), d && d > a && d >= this.basePointRange && (a = d), e = void 0; k--;) e && !1 !== e.visible || (e = b[k + 1]), d = b[k], !1 !== e.visible && !1 !== d.visible && (e.x - d.x > a && (e = (d.x + e.x) / 2, b.splice(k + 1, 0, {\n          isNull: !0,\n          x: e\n        }), f.stacking && this.options.stacking && (e = f.stacking.stacks[this.stackKey][e] = new c(f, f.options.stackLabels, !1, e, this.stack), e.total = 0)), e = d);\n        return this.getGraphPath(b);\n      }\n\n      var M = [];\n\n      h.compose = function (c, h) {\n        -1 === M.indexOf(c) && (M.push(c), c.keepProps.push(\"brokenAxis\"), B(c, \"init\", m), B(c, \"afterInit\", b), B(c, \"afterSetTickPositions\", n), B(c, \"afterSetOptions\", k));\n\n        if (-1 === M.indexOf(h)) {\n          M.push(h);\n          var q = h.prototype;\n          q.drawBreaks = p;\n          q.gappedPath = t;\n          B(h, \"afterGeneratePoints\", f);\n          B(h, \"afterRender\", d);\n        }\n\n        return c;\n      };\n\n      var I = function () {\n        function b(b) {\n          this.hasBreaks = !1;\n          this.axis = b;\n        }\n\n        b.isInBreak = function (b, d) {\n          var a = b.repeat || Infinity,\n              c = b.from,\n              e = b.to - b.from;\n          d = d >= c ? (d - c) % a : a - (c - d) % a;\n          return b.inclusive ? d <= e : d < e && 0 !== d;\n        };\n\n        b.lin2Val = function (d) {\n          var c = this.brokenAxis;\n          c = c && c.breakArray;\n          if (!c || !F(d)) return d;\n          var a;\n\n          for (a = 0; a < c.length; a++) {\n            var f = c[a];\n            if (f.from >= d) break;else f.to < d ? d += f.len : b.isInBreak(f, d) && (d += f.len);\n          }\n\n          return d;\n        };\n\n        b.val2Lin = function (d) {\n          var c = this.brokenAxis;\n          c = c && c.breakArray;\n          if (!c || !F(d)) return d;\n          var a = d,\n              f;\n\n          for (f = 0; f < c.length; f++) {\n            var e = c[f];\n            if (e.to <= d) a -= e.len;else if (e.from >= d) break;else if (b.isInBreak(e, d)) {\n              a -= d - e.from;\n              break;\n            }\n          }\n\n          return a;\n        };\n\n        b.prototype.findBreakAt = function (b, d) {\n          return E(d, function (a) {\n            return a.from < b && b < a.to;\n          });\n        };\n\n        b.prototype.isInAnyBreak = function (d, c) {\n          var a = this.axis,\n              f = a.options.breaks || [],\n              e = f.length,\n              k;\n\n          if (e && F(d)) {\n            for (; e--;) if (b.isInBreak(f[e], d)) {\n              var h = !0;\n              k || (k = y(f[e].showPoints, !a.isXAxis));\n            }\n\n            var g = h && c ? h && !k : h;\n          }\n\n          return g;\n        };\n\n        b.prototype.setBreaks = function (d, c) {\n          var a = this,\n              f = a.axis,\n              e = D(d) && !!d.length;\n          f.isDirty = a.hasBreaks !== e;\n          a.hasBreaks = e;\n          f.options.breaks = f.userOptions.breaks = d;\n          f.forceRedraw = !0;\n          f.series.forEach(function (a) {\n            a.isDirty = !0;\n          });\n          e || f.val2lin !== b.val2Lin || (delete f.val2lin, delete f.lin2val);\n          e && (f.userOptions.ordinal = !1, f.lin2val = b.lin2Val, f.val2lin = b.val2Lin, f.setExtremes = function (b, d, e, c, k) {\n            if (a.hasBreaks) {\n              for (var g = this.options.breaks || [], h; h = a.findBreakAt(b, g);) b = h.to;\n\n              for (; h = a.findBreakAt(d, g);) d = h.from;\n\n              d < b && (d = b);\n            }\n\n            f.constructor.prototype.setExtremes.call(this, b, d, e, c, k);\n          }, f.setAxisTranslation = function () {\n            f.constructor.prototype.setAxisTranslation.call(this);\n            a.unitLength = void 0;\n\n            if (a.hasBreaks) {\n              var d = f.options.breaks || [],\n                  e = [],\n                  c = [],\n                  k = y(f.pointRangePadding, 0),\n                  h = 0,\n                  r,\n                  m = f.userMin || f.min,\n                  n = f.userMax || f.max,\n                  p;\n              d.forEach(function (a) {\n                r = a.repeat || Infinity;\n                F(m) && F(n) && (b.isInBreak(a, m) && (m += a.to % r - m % r), b.isInBreak(a, n) && (n -= n % r - a.from % r));\n              });\n              d.forEach(function (a) {\n                v = a.from;\n                r = a.repeat || Infinity;\n\n                if (F(m) && F(n)) {\n                  for (; v - r > m;) v -= r;\n\n                  for (; v < m;) v += r;\n\n                  for (p = v; p < n; p += r) e.push({\n                    value: p,\n                    move: \"in\"\n                  }), e.push({\n                    value: p + a.to - a.from,\n                    move: \"out\",\n                    size: a.breakSize\n                  });\n                }\n              });\n              e.sort(function (a, b) {\n                return a.value === b.value ? (\"in\" === a.move ? 0 : 1) - (\"in\" === b.move ? 0 : 1) : a.value - b.value;\n              });\n              var q = 0;\n              var v = m;\n              e.forEach(function (a) {\n                q += \"in\" === a.move ? 1 : -1;\n                1 === q && \"in\" === a.move && (v = a.value);\n                0 === q && F(v) && (c.push({\n                  from: v,\n                  to: a.value,\n                  len: a.value - v - (a.size || 0)\n                }), h += a.value - v - (a.size || 0));\n              });\n              a.breakArray = c;\n              F(m) && F(n) && F(f.min) && (a.unitLength = n - m - h + k, A(f, \"afterBreaks\"), f.staticScale ? f.transA = f.staticScale : a.unitLength && (f.transA *= (n - f.min + k) / a.unitLength), k && (f.minPixelPadding = f.transA * (f.minPointOffset || 0)), f.min = m, f.max = n);\n            }\n          });\n          y(c, !0) && f.chart.redraw();\n        };\n\n        return b;\n      }();\n\n      h.Additions = I;\n    })(p || (p = {}));\n\n    return p;\n  });\n  O(h, \"Core/Axis/GridAxis.js\", [h[\"Core/Axis/Axis.js\"], h[\"Core/Axis/AxisDefaults.js\"], h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E) {\n    function A(a, b) {\n      var d = {\n        width: 0,\n        height: 0\n      };\n      b.forEach(function (b) {\n        b = a[b];\n\n        if (E.isObject(b, !0)) {\n          var e = E.isObject(b.label, !0) ? b.label : {};\n          b = e.getBBox ? e.getBBox().height : 0;\n          e.textStr && !l(e.textPxLength) && (e.textPxLength = e.getBBox().width);\n          var c = l(e.textPxLength) ? Math.round(e.textPxLength) : 0;\n          e.textStr && (c = Math.round(e.getBBox().width));\n          d.height = Math.max(b, d.height);\n          d.width = Math.max(c, d.width);\n        }\n      });\n      \"treegrid\" === this.options.type && this.treeGrid && this.treeGrid.mapOfPosToGridNode && (d.width += this.options.labels.indentation * ((this.treeGrid.mapOfPosToGridNode[-1].height || 0) - 1));\n      return d;\n    }\n\n    function D() {\n      var a = this.grid;\n      (a && a.columns || []).forEach(function (a) {\n        a.getOffset();\n      });\n    }\n\n    function F(a) {\n      if (!0 === (this.options.grid || {}).enabled) {\n        var b = this.axisTitle,\n            d = this.height,\n            e = this.horiz,\n            c = this.left,\n            g = this.offset,\n            f = this.opposite,\n            k = this.options,\n            h = this.top,\n            l = this.width,\n            r = this.tickSize(),\n            m = b && b.getBBox().width,\n            n = k.title.x,\n            p = k.title.y,\n            q = G(k.title.margin, e ? 5 : 10);\n        b = this.chart.renderer.fontMetrics(k.title.style.fontSize, b).f;\n        r = (e ? h + d : c) + (e ? 1 : -1) * (f ? -1 : 1) * (r ? r[0] / 2 : 0) + (this.side === L.bottom ? b : 0);\n        a.titlePosition.x = e ? c - (m || 0) / 2 - q + n : r + (f ? l : 0) + g + n;\n        a.titlePosition.y = e ? r - (f ? d : 0) + (f ? b : -b) / 2 + g + p : h - q + p;\n      }\n    }\n\n    function y() {\n      var a = this.chart,\n          b = this.options.grid;\n      b = void 0 === b ? {} : b;\n      var d = this.userOptions;\n\n      if (b.enabled) {\n        var e = this.options;\n        e.labels.align = G(e.labels.align, \"center\");\n        this.categories || (e.showLastLabel = !1);\n        this.labelRotation = 0;\n        e.labels.rotation = 0;\n      }\n\n      if (b.columns) {\n        e = this.grid.columns = [];\n\n        for (var f = this.grid.columnIndex = 0; ++f < b.columns.length;) {\n          var k = g(d, b.columns[b.columns.length - f - 1], {\n            linkedTo: 0,\n            type: \"category\",\n            scrollbar: {\n              enabled: !1\n            }\n          });\n          delete k.grid.columns;\n          k = new c(this.chart, k);\n          k.grid.isColumn = !0;\n          k.grid.columnIndex = f;\n          x(a.axes, k);\n          x(a[this.coll], k);\n          e.push(k);\n        }\n      }\n    }\n\n    function p() {\n      var a = this.grid,\n          b = this.options;\n\n      if (!0 === (b.grid || {}).enabled) {\n        var d = this.min || 0,\n            e = this.max || 0;\n        this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions);\n        this.rightWall && this.rightWall.destroy();\n\n        if (this.grid && this.grid.isOuterAxis() && this.axisLine) {\n          var c = b.lineWidth;\n\n          if (c) {\n            c = this.getLinePath(c);\n            var g = c[0],\n                f = c[1],\n                k = ((this.tickSize(\"tick\") || [1])[0] - 1) * (this.side === L.top || this.side === L.left ? -1 : 1);\n            \"M\" === g[0] && \"L\" === f[0] && (this.horiz ? (g[2] += k, f[2] += k) : (g[1] += k, f[1] += k));\n            !this.horiz && this.chart.marginRight && (g = [g, [\"L\", this.left, g[2] || 0]], k = [\"L\", this.chart.chartWidth - this.chart.marginRight, this.toPixels(e + this.tickmarkOffset)], f = [[\"M\", f[1] || 0, this.toPixels(e + this.tickmarkOffset)], k], this.grid.upperBorder || 0 === d % 1 || (this.grid.upperBorder = this.grid.renderBorder(g)), this.grid.upperBorder && (this.grid.upperBorder.attr({\n              stroke: b.lineColor,\n              \"stroke-width\": b.lineWidth\n            }), this.grid.upperBorder.animate({\n              d: g\n            })), this.grid.lowerBorder || 0 === e % 1 || (this.grid.lowerBorder = this.grid.renderBorder(f)), this.grid.lowerBorder && (this.grid.lowerBorder.attr({\n              stroke: b.lineColor,\n              \"stroke-width\": b.lineWidth\n            }), this.grid.lowerBorder.animate({\n              d: f\n            })));\n            this.grid.axisLineExtra ? (this.grid.axisLineExtra.attr({\n              stroke: b.lineColor,\n              \"stroke-width\": b.lineWidth\n            }), this.grid.axisLineExtra.animate({\n              d: c\n            })) : this.grid.axisLineExtra = this.grid.renderBorder(c);\n            this.axisLine[this.showAxis ? \"show\" : \"hide\"]();\n          }\n        }\n\n        (a && a.columns || []).forEach(function (a) {\n          return a.render();\n        });\n\n        if (!this.horiz && this.chart.hasRendered && (this.scrollbar || this.linkedParent && this.linkedParent.scrollbar)) {\n          a = this.tickmarkOffset;\n          b = this.tickPositions[this.tickPositions.length - 1];\n          c = this.tickPositions[0];\n\n          for (g = f = void 0; (f = this.hiddenLabels.pop()) && f.element;) f.show();\n\n          for (; (g = this.hiddenMarks.pop()) && g.element;) g.show();\n\n          (f = this.ticks[c].label) && (d - c > a ? this.hiddenLabels.push(f.hide()) : f.show());\n          (f = this.ticks[b].label) && (b - e > a ? this.hiddenLabels.push(f.hide()) : f.show());\n          (d = this.ticks[b].mark) && b - e < a && 0 < b - e && this.ticks[b].isLast && this.hiddenMarks.push(d.hide());\n        }\n      }\n    }\n\n    function t() {\n      var b = this.tickPositions && this.tickPositions.info,\n          d = this.options,\n          e = this.userOptions.labels || {};\n      (d.grid || {}).enabled && (this.horiz ? (this.series.forEach(function (a) {\n        a.options.pointRange = 0;\n      }), b && d.dateTimeLabelFormats && d.labels && !a(e.align) && (!1 === d.dateTimeLabelFormats[b.unitName].range || 1 < b.count) && (d.labels.align = \"left\", a(e.x) || (d.labels.x = 3))) : \"treegrid\" !== this.options.type && this.grid && this.grid.columns && (this.minPointOffset = this.tickInterval));\n    }\n\n    function b(b) {\n      var d = this.options;\n      b = b.userOptions;\n      var e = d && E.isObject(d.grid, !0) ? d.grid : {};\n\n      if (!0 === e.enabled) {\n        var c = g(!0, {\n          className: \"highcharts-grid-axis \" + (b.className || \"\"),\n          dateTimeLabelFormats: {\n            hour: {\n              list: [\"%H:%M\", \"%H\"]\n            },\n            day: {\n              list: [\"%A, %e. %B\", \"%a, %e. %b\", \"%E\"]\n            },\n            week: {\n              list: [\"Week %W\", \"W%W\"]\n            },\n            month: {\n              list: [\"%B\", \"%b\", \"%o\"]\n            }\n          },\n          grid: {\n            borderWidth: 1\n          },\n          labels: {\n            padding: 2,\n            style: {\n              fontSize: \"13px\"\n            }\n          },\n          margin: 0,\n          title: {\n            text: null,\n            reserveSpace: !1,\n            rotation: 0\n          },\n          units: [[\"millisecond\", [1, 10, 100]], [\"second\", [1, 10]], [\"minute\", [1, 5, 15]], [\"hour\", [1, 6]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1]], [\"year\", null]]\n        }, b);\n        \"xAxis\" === this.coll && (a(b.linkedTo) && !a(b.tickPixelInterval) && (c.tickPixelInterval = 350), a(b.tickPixelInterval) || !a(b.linkedTo) || a(b.tickPositioner) || a(b.tickInterval) || (c.tickPositioner = function (a, b) {\n          var d = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;\n\n          if (d) {\n            for (var e = c.units || [], g = void 0, f = 1, k = \"year\", h = 0; h < e.length; h++) {\n              var r = e[h];\n\n              if (r && r[0] === d.unitName) {\n                g = h;\n                break;\n              }\n            }\n\n            (e = l(g) && e[g + 1]) ? (k = e[0] || \"year\", f = (f = e[1]) && f[0] || 1) : \"year\" === d.unitName && (f = 10 * d.count);\n            d = z[k];\n            this.tickInterval = d * f;\n            return this.chart.time.getTimeTicks({\n              unitRange: d,\n              count: f,\n              unitName: k\n            }, a, b, this.options.startOfWeek);\n          }\n        }));\n        g(!0, this.options, c);\n        this.horiz && (d.minPadding = G(b.minPadding, 0), d.maxPadding = G(b.maxPadding, 0));\n        l(d.grid.borderWidth) && (d.tickWidth = d.lineWidth = e.borderWidth);\n      }\n    }\n\n    function k(a) {\n      a = (a = a.userOptions) && a.grid || {};\n      var b = a.columns;\n      a.enabled && b && g(!0, this.options, b[b.length - 1]);\n    }\n\n    function n() {\n      (this.grid.columns || []).forEach(function (a) {\n        return a.setScale();\n      });\n    }\n\n    function m(a) {\n      var b = h.defaultLeftAxisOptions,\n          d = this.horiz,\n          e = this.maxLabelDimensions,\n          c = this.options.grid;\n      c = void 0 === c ? {} : c;\n      c.enabled && e && (b = 2 * Math.abs(b.labels.x), d = d ? c.cellHeight || b + e.height : b + e.width, u(a.tickSize) ? a.tickSize[0] = d : a.tickSize = [d, 0]);\n    }\n\n    function f() {\n      this.axes.forEach(function (a) {\n        (a.grid && a.grid.columns || []).forEach(function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n      });\n    }\n\n    function d(a) {\n      var b = this.grid;\n      (b.columns || []).forEach(function (b) {\n        return b.destroy(a.keepEvents);\n      });\n      b.columns = void 0;\n    }\n\n    function v(b) {\n      b = b.userOptions || {};\n      var d = b.grid || {};\n      d.enabled && a(d.borderColor) && (b.tickColor = b.lineColor = d.borderColor);\n      this.grid || (this.grid = new S(this));\n      this.hiddenLabels = [];\n      this.hiddenMarks = [];\n    }\n\n    function K(a) {\n      var b = this.label,\n          d = this.axis,\n          e = d.reversed,\n          c = d.chart,\n          g = d.options.grid || {},\n          f = d.options.labels,\n          k = f.align,\n          h = L[d.side],\n          r = a.tickmarkOffset,\n          m = d.tickPositions,\n          n = this.pos - r;\n      m = l(m[a.index + 1]) ? m[a.index + 1] - r : (d.max || 0) + r;\n      var p = d.tickSize(\"tick\");\n      r = p ? p[0] : 0;\n      p = p ? p[1] / 2 : 0;\n\n      if (!0 === g.enabled) {\n        if (\"top\" === h) {\n          g = d.top + d.offset;\n          var q = g - r;\n        } else \"bottom\" === h ? (q = c.chartHeight - d.bottom + d.offset, g = q + r) : (g = d.top + d.len - (d.translate(e ? m : n) || 0), q = d.top + d.len - (d.translate(e ? n : m) || 0));\n\n        \"right\" === h ? (h = c.chartWidth - d.right + d.offset, e = h + r) : \"left\" === h ? (e = d.left + d.offset, h = e - r) : (h = Math.round(d.left + (d.translate(e ? m : n) || 0)) - p, e = Math.min(Math.round(d.left + (d.translate(e ? n : m) || 0)) - p, d.left + d.len));\n        this.slotWidth = e - h;\n        a.pos.x = \"left\" === k ? h : \"right\" === k ? e : h + (e - h) / 2;\n        a.pos.y = q + (g - q) / 2;\n        c = c.renderer.fontMetrics(f.style.fontSize, b && b.element);\n        b = b ? b.getBBox().height : 0;\n        f.useHTML ? a.pos.y += c.b + -(b / 2) : (b = Math.round(b / c.h), a.pos.y += (c.b - (c.h - c.f)) / 2 + -((b - 1) * c.h / 2));\n        a.pos.x += d.horiz && f.x || 0;\n      }\n    }\n\n    function M(a) {\n      var b = a.axis,\n          d = a.value;\n\n      if (b.options.grid && b.options.grid.enabled) {\n        var c = b.tickPositions,\n            f = (b.linkedParent || b).series[0],\n            k = d === c[0];\n        c = d === c[c.length - 1];\n        var h = f && e(f.options.data, function (a) {\n          return a[b.isXAxis ? \"x\" : \"y\"] === d;\n        }),\n            l = void 0;\n        h && f.is(\"gantt\") && (l = g(h), B.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(l));\n        a.isFirst = k;\n        a.isLast = c;\n        a.point = l;\n      }\n    }\n\n    function I() {\n      var a = this.options,\n          b = this.categories,\n          d = this.tickPositions,\n          e = d[0],\n          c = d[d.length - 1],\n          g = this.linkedParent && this.linkedParent.min || this.min,\n          f = this.linkedParent && this.linkedParent.max || this.max,\n          k = this.tickInterval;\n      !0 !== (a.grid || {}).enabled || b || !this.horiz && !this.isLinked || (e < g && e + k > g && !a.startOnTick && (d[0] = g), c > f && c - k < f && !a.endOnTick && (d[d.length - 1] = f));\n    }\n\n    function H(a) {\n      var b = this.options.grid;\n      return !0 === (void 0 === b ? {} : b).enabled && this.categories ? this.tickInterval : a.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n\n    var q = B.dateFormats,\n        w = E.addEvent,\n        a = E.defined,\n        x = E.erase,\n        e = E.find,\n        u = E.isArray,\n        l = E.isNumber,\n        g = E.merge,\n        G = E.pick,\n        z = E.timeUnits,\n        r = E.wrap,\n        L;\n\n    (function (a) {\n      a[a.top = 0] = \"top\";\n      a[a.right = 1] = \"right\";\n      a[a.bottom = 2] = \"bottom\";\n      a[a.left = 3] = \"left\";\n    })(L || (L = {}));\n\n    var Q = [],\n        S = function () {\n      function a(a) {\n        this.axis = a;\n      }\n\n      a.prototype.isOuterAxis = function () {\n        var a = this.axis,\n            b = a.grid.columnIndex,\n            d = a.linkedParent && a.linkedParent.grid.columns || a.grid.columns,\n            e = b ? a.linkedParent : a,\n            c = -1,\n            g = 0;\n        (a.chart[a.coll] || []).forEach(function (b, d) {\n          b.side !== a.side || b.options.isInternal || (g = d, b === e && (c = d));\n        });\n        return g === c && (l(b) ? d.length === b : !0);\n      };\n\n      a.prototype.renderBorder = function (a) {\n        var b = this.axis,\n            d = b.chart.renderer,\n            e = b.options;\n        a = d.path(a).addClass(\"highcharts-axis-line\").add(b.axisBorder);\n        d.styledMode || a.attr({\n          stroke: e.lineColor,\n          \"stroke-width\": e.lineWidth,\n          zIndex: 7\n        });\n        return a;\n      };\n\n      return a;\n    }();\n\n    q.E = function (a) {\n      return this.dateFormat(\"%a\", a, !0).charAt(0);\n    };\n\n    q.W = function (a) {\n      var b = this,\n          d = new this.Date(a);\n      [\"Hours\", \"Milliseconds\", \"Minutes\", \"Seconds\"].forEach(function (a) {\n        b.set(a, d, 0);\n      });\n      var e = (this.get(\"Day\", d) + 6) % 7;\n      a = new this.Date(d.valueOf());\n      this.set(\"Date\", a, this.get(\"Date\", d) - e + 3);\n      e = new this.Date(this.get(\"FullYear\", a), 0, 1);\n      4 !== this.get(\"Day\", e) && (this.set(\"Month\", d, 0), this.set(\"Date\", d, 1 + (11 - this.get(\"Day\", e)) % 7));\n      return (1 + Math.floor((a.valueOf() - e.valueOf()) / 6048E5)).toString();\n    };\n\n    \"\";\n    return {\n      compose: function (a, e, c) {\n        -1 === Q.indexOf(a) && (Q.push(a), a.keepProps.push(\"grid\"), a.prototype.getMaxLabelDimensions = A, r(a.prototype, \"unsquish\", H), w(a, \"init\", v), w(a, \"afterGetOffset\", D), w(a, \"afterGetTitlePosition\", F), w(a, \"afterInit\", y), w(a, \"afterRender\", p), w(a, \"afterSetAxisTranslation\", t), w(a, \"afterSetOptions\", b), w(a, \"afterSetOptions\", k), w(a, \"afterSetScale\", n), w(a, \"afterTickSize\", m), w(a, \"trimTicks\", I), w(a, \"destroy\", d));\n        -1 === Q.indexOf(e) && w(e, \"afterSetChartSize\", f);\n        -1 === Q.indexOf(c) && (w(c, \"afterGetLabelPosition\", K), w(c, \"labelFormat\", M));\n        return a;\n      }\n    };\n  });\n  O(h, \"Gantt/Tree.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    var h = c.extend,\n        B = c.isNumber,\n        E = c.pick,\n        A = function (c, h) {\n      var p = c.reduce(function (c, b) {\n        var k = E(b.parent, \"\");\n        \"undefined\" === typeof c[k] && (c[k] = []);\n        c[k].push(b);\n        return c;\n      }, {});\n      Object.keys(p).forEach(function (c, b) {\n        var k = p[c];\n        \"\" !== c && -1 === h.indexOf(c) && (k.forEach(function (c) {\n          b[\"\"].push(c);\n        }), delete b[c]);\n      });\n      return p;\n    },\n        D = function (c, y, p, t, b, k) {\n      var n = 0,\n          m = 0,\n          f = k && k.after,\n          d = k && k.before;\n      y = {\n        data: t,\n        depth: p - 1,\n        id: c,\n        level: p,\n        parent: y\n      };\n      var v, A;\n      \"function\" === typeof d && d(y, k);\n      d = (b[c] || []).map(function (d) {\n        var f = D(d.id, c, p + 1, d, b, k),\n            h = d.start;\n        d = !0 === d.milestone ? h : d.end;\n        v = !B(v) || h < v ? h : v;\n        A = !B(A) || d > A ? d : A;\n        n = n + 1 + f.descendants;\n        m = Math.max(f.height + 1, m);\n        return f;\n      });\n      t && (t.start = E(t.start, v), t.end = E(t.end, A));\n      h(y, {\n        children: d,\n        descendants: n,\n        height: m\n      });\n      \"function\" === typeof f && f(y, k);\n      return y;\n    };\n\n    return {\n      getListOfParents: A,\n      getNode: D,\n      getTree: function (c, h) {\n        var p = c.map(function (c) {\n          return c.id;\n        });\n        c = A(c, p);\n        return D(\"\", null, 1, null, c, h);\n      }\n    };\n  });\n  O(h, \"Core/Axis/TreeGrid/TreeGridTick.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    function h() {\n      this.treeGrid || (this.treeGrid = new k(this));\n    }\n\n    function B(b, c) {\n      b = b.treeGrid;\n      var f = !b.labelIcon,\n          d = c.renderer,\n          k = c.xy,\n          h = c.options,\n          m = h.width || 0,\n          n = h.height || 0,\n          t = k.x - m / 2 - (h.padding || 0);\n      k = k.y - n / 2;\n      var q = c.collapsed ? 90 : 180,\n          w = c.show && y(k),\n          a = b.labelIcon;\n      a || (b.labelIcon = a = d.path(d.symbols[h.type](h.x || 0, h.y || 0, m, n)).addClass(\"highcharts-label-icon\").add(c.group));\n      a[w ? \"show\" : \"hide\"]();\n      d.styledMode || a.attr({\n        cursor: \"pointer\",\n        fill: p(c.color, \"#666666\"),\n        \"stroke-width\": 1,\n        stroke: h.lineColor,\n        strokeWidth: h.lineWidth || 0\n      });\n      a[f ? \"attr\" : \"animate\"]({\n        translateX: t,\n        translateY: k,\n        rotation: q\n      });\n    }\n\n    function E(b, c, f, d, k, h, t, A, H) {\n      var m = p(this.options && this.options.labels, h);\n      h = this.pos;\n      var n = this.axis,\n          a = \"treegrid\" === n.options.type;\n      b = b.apply(this, [c, f, d, k, m, t, A, H]);\n      a && (c = m && F(m.symbol, !0) ? m.symbol : {}, m = m && y(m.indentation) ? m.indentation : 0, h = (h = (n = n.treeGrid.mapOfPosToGridNode) && n[h]) && h.depth || 1, b.x += (c.width || 0) + 2 * (c.padding || 0) + (h - 1) * m);\n      return b;\n    }\n\n    function A(b) {\n      var c = this,\n          f = c.pos,\n          d = c.axis,\n          k = c.label,\n          h = d.treeGrid.mapOfPosToGridNode,\n          n = d.options,\n          t = p(c.options && c.options.labels, n && n.labels),\n          y = t && F(t.symbol, !0) ? t.symbol : {},\n          q = (h = h && h[f]) && h.depth;\n      n = \"treegrid\" === n.type;\n      var w = -1 < d.tickPositions.indexOf(f);\n      f = d.chart.styledMode;\n      n && h && k && k.element && k.addClass(\"highcharts-treegrid-node-level-\" + q);\n      b.apply(c, Array.prototype.slice.call(arguments, 1));\n      n && k && k.element && h && h.descendants && 0 < h.descendants && (d = d.treeGrid.isCollapsed(h), B(c, {\n        color: !f && k.styles && k.styles.color || \"\",\n        collapsed: d,\n        group: k.parentGroup,\n        options: y,\n        renderer: k.renderer,\n        show: w,\n        xy: k.xy\n      }), y = \"highcharts-treegrid-node-\" + (d ? \"expanded\" : \"collapsed\"), k.addClass(\"highcharts-treegrid-node-\" + (d ? \"collapsed\" : \"expanded\")).removeClass(y), f || k.css({\n        cursor: \"pointer\"\n      }), [k, c.treeGrid.labelIcon].forEach(function (a) {\n        a && !a.attachedTreeGridEvents && (D(a.element, \"mouseover\", function () {\n          k.addClass(\"highcharts-treegrid-node-active\");\n          k.renderer.styledMode || k.css({\n            textDecoration: \"underline\"\n          });\n        }), D(a.element, \"mouseout\", function () {\n          var a = F(t.style) ? t.style : {};\n          k.removeClass(\"highcharts-treegrid-node-active\");\n          k.renderer.styledMode || k.css({\n            textDecoration: a.textDecoration\n          });\n        }), D(a.element, \"click\", function () {\n          c.treeGrid.toggleCollapse();\n        }), a.attachedTreeGridEvents = !0);\n      }));\n    }\n\n    var D = c.addEvent,\n        F = c.isObject,\n        y = c.isNumber,\n        p = c.pick,\n        t = c.wrap,\n        b = [],\n        k = function () {\n      function c(b) {\n        this.tick = b;\n      }\n\n      c.compose = function (c) {\n        -1 === b.indexOf(c) && (b.push(c), D(c, \"init\", h), t(c.prototype, \"getLabelPosition\", E), t(c.prototype, \"renderLabel\", A), c.prototype.collapse = function (b) {\n          this.treeGrid.collapse(b);\n        }, c.prototype.expand = function (b) {\n          this.treeGrid.expand(b);\n        }, c.prototype.toggleCollapse = function (b) {\n          this.treeGrid.toggleCollapse(b);\n        });\n      };\n\n      c.prototype.collapse = function (b) {\n        var c = this.tick,\n            d = c.axis,\n            k = d.brokenAxis;\n        k && d.treeGrid.mapOfPosToGridNode && (c = d.treeGrid.collapse(d.treeGrid.mapOfPosToGridNode[c.pos]), k.setBreaks(c, p(b, !0)));\n      };\n\n      c.prototype.destroy = function () {\n        this.labelIcon && this.labelIcon.destroy();\n      };\n\n      c.prototype.expand = function (b) {\n        var c = this.tick,\n            d = c.axis,\n            k = d.brokenAxis;\n        k && d.treeGrid.mapOfPosToGridNode && (c = d.treeGrid.expand(d.treeGrid.mapOfPosToGridNode[c.pos]), k.setBreaks(c, p(b, !0)));\n      };\n\n      c.prototype.toggleCollapse = function (b) {\n        var c = this.tick,\n            d = c.axis,\n            k = d.brokenAxis;\n        k && d.treeGrid.mapOfPosToGridNode && (c = d.treeGrid.toggleCollapse(d.treeGrid.mapOfPosToGridNode[c.pos]), k.setBreaks(c, p(b, !0)));\n      };\n\n      return c;\n    }();\n\n    return k;\n  });\n  O(h, \"Series/TreeUtilities.js\", [h[\"Core/Color/Color.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    function B(c, b) {\n      var k = b.before,\n          h = b.idRoot,\n          m = b.mapIdToNode[h],\n          f = b.points[c.i],\n          d = f && f.options || {},\n          v = [],\n          t = 0;\n      c.levelDynamic = c.level - (!1 !== b.levelIsConstant ? 0 : m.level);\n      c.name = p(f && f.name, \"\");\n      c.visible = h === c.id || !0 === b.visible;\n      \"function\" === typeof k && (c = k(c, b));\n      c.children.forEach(function (d, f) {\n        var k = E({}, b);\n        E(k, {\n          index: f,\n          siblings: c.children.length,\n          visible: c.visible\n        });\n        d = B(d, k);\n        v.push(d);\n        d.visible && (t += d.val);\n      });\n      k = p(d.value, t);\n      c.visible = 0 <= k && (0 < t || c.visible);\n      c.children = v;\n      c.childrenTotal = t;\n      c.isLeaf = c.visible && !t;\n      c.val = k;\n      return c;\n    }\n\n    var E = h.extend,\n        A = h.isArray,\n        D = h.isNumber,\n        F = h.isObject,\n        y = h.merge,\n        p = h.pick;\n    return {\n      getColor: function (h, b) {\n        var k = b.index,\n            n = b.mapOptionsToLevel,\n            m = b.parentColor,\n            f = b.parentColorIndex,\n            d = b.series,\n            v = b.colors,\n            t = b.siblings,\n            y = d.points,\n            A = d.chart.options.chart,\n            H;\n\n        if (h) {\n          y = y[h.i];\n          h = n[h.level] || {};\n\n          if (n = y && h.colorByPoint) {\n            var q = y.index % (v ? v.length : A.colorCount);\n            var w = v && v[q];\n          }\n\n          if (!d.chart.styledMode) {\n            v = y && y.options.color;\n            A = h && h.color;\n            if (H = m) H = (H = h && h.colorVariation) && \"brightness\" === H.key && k && t ? c.parse(m).brighten(k / t * H.to).get() : m;\n            H = p(v, A, w, H, d.color);\n          }\n\n          var a = p(y && y.options.colorIndex, h && h.colorIndex, q, f, b.colorIndex);\n        }\n\n        return {\n          color: H,\n          colorIndex: a\n        };\n      },\n      getLevelOptions: function (c) {\n        var b = null;\n\n        if (F(c)) {\n          b = {};\n          var k = D(c.from) ? c.from : 1;\n          var h = c.levels;\n          var m = {};\n          var f = F(c.defaults) ? c.defaults : {};\n          A(h) && (m = h.reduce(function (b, c) {\n            if (F(c) && D(c.level)) {\n              var d = y({}, c);\n              var h = p(d.levelIsConstant, f.levelIsConstant);\n              delete d.levelIsConstant;\n              delete d.level;\n              c = c.level + (h ? 0 : k - 1);\n              F(b[c]) ? y(!0, b[c], d) : b[c] = d;\n            }\n\n            return b;\n          }, {}));\n          h = D(c.to) ? c.to : 1;\n\n          for (c = 0; c <= h; c++) b[c] = y({}, f, F(m[c]) ? m[c] : {});\n        }\n\n        return b;\n      },\n      setTreeValues: B,\n      updateRootId: function (c) {\n        if (F(c)) {\n          var b = F(c.options) ? c.options : {};\n          b = p(c.rootNode, b.rootId, \"\");\n          F(c.userOptions) && (c.userOptions.rootId = b);\n          c.rootNode = b;\n        }\n\n        return b;\n      }\n    };\n  });\n  O(h, \"Core/Axis/TreeGrid/TreeGridAxis.js\", [h[\"Core/Axis/BrokenAxis.js\"], h[\"Core/Axis/GridAxis.js\"], h[\"Gantt/Tree.js\"], h[\"Core/Axis/TreeGrid/TreeGridTick.js\"], h[\"Series/TreeUtilities.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A, D) {\n    function F(a, b) {\n      var d = a.collapseEnd || 0;\n      a = a.collapseStart || 0;\n      d >= b && (a -= .5);\n      return {\n        from: a,\n        to: d,\n        showPoints: !1\n      };\n    }\n\n    function y(a, b, d) {\n      var c = [],\n          e = [],\n          k = {},\n          h = \"boolean\" === typeof b ? b : !1,\n          l = {},\n          m = -1;\n      a = B.getTree(a, {\n        after: function (a) {\n          a = l[a.pos];\n          var b = 0,\n              d = 0;\n          a.children.forEach(function (a) {\n            d += (a.descendants || 0) + 1;\n            b = Math.max((a.height || 0) + 1, b);\n          });\n          a.descendants = d;\n          a.height = b;\n          a.collapsed && e.push(a);\n        },\n        before: function (a) {\n          var b = K(a.data, !0) ? a.data : {},\n              d = I(b.name) ? b.name : \"\",\n              e = k[a.parent];\n          e = K(e, !0) ? l[e.pos] : null;\n\n          var g = function (a) {\n            return a.name === d;\n          },\n              r;\n\n          h && K(e, !0) && (r = f(e.children, g)) ? (g = r.pos, r.nodes.push(a)) : g = m++;\n          l[g] || (l[g] = r = {\n            depth: e ? e.depth + 1 : 0,\n            name: d,\n            id: b.id,\n            nodes: [a],\n            children: [],\n            pos: g\n          }, -1 !== g && c.push(d), K(e, !0) && e.children.push(r));\n          I(a.id) && (k[a.id] = a);\n          r && !0 === b.collapsed && (r.collapsed = !0);\n          a.pos = g;\n        }\n      });\n\n      l = function (a, b) {\n        var d = function (a, c, e) {\n          var g = c + (-1 === c ? 0 : b - 1),\n              f = (g - c) / 2,\n              k = c + f;\n          a.nodes.forEach(function (a) {\n            var b = a.data;\n            K(b, !0) && (b.y = c + (b.seriesIndex || 0), delete b.seriesIndex);\n            a.pos = k;\n          });\n          e[k] = a;\n          a.pos = k;\n          a.tickmarkOffset = f + .5;\n          a.collapseStart = g + .5;\n          a.children.forEach(function (a) {\n            d(a, g + 1, e);\n            g = (a.collapseEnd || 0) - .5;\n          });\n          a.collapseEnd = g + .5;\n          return e;\n        };\n\n        return d(a[\"-1\"], -1, {});\n      }(l, d);\n\n      return {\n        categories: c,\n        mapOfIdToNode: k,\n        mapOfPosToGridNode: l,\n        collapsedNodes: e,\n        tree: a\n      };\n    }\n\n    function p(a) {\n      a.target.axes.filter(function (a) {\n        return \"treegrid\" === a.options.type;\n      }).forEach(function (b) {\n        var d = b.options || {},\n            c = d.labels,\n            e = d.uniqueNames;\n        d = d.max;\n        var f = 0;\n\n        if (!b.treeGrid.mapOfPosToGridNode || b.series.some(function (a) {\n          return !a.hasRendered || a.isDirtyData || a.isDirty;\n        })) {\n          var k = b.series.reduce(function (a, b) {\n            b.visible && ((b.options.data || []).forEach(function (d) {\n              b.options.keys && b.options.keys.length && (d = b.pointClass.prototype.optionsToObject.call({\n                series: b\n              }, d), b.pointClass.setGanttPointAliases(d));\n              K(d, !0) && (d.seriesIndex = f, a.push(d));\n            }), !0 === e && f++);\n            return a;\n          }, []);\n          if (d && k.length < d) for (var h = k.length; h <= d; h++) k.push({\n            name: h + \"\\u200b\"\n          });\n          d = y(k, e || !1, !0 === e ? f : 1);\n          b.categories = d.categories;\n          b.treeGrid.mapOfPosToGridNode = d.mapOfPosToGridNode;\n          b.hasNames = !0;\n          b.treeGrid.tree = d.tree;\n          b.series.forEach(function (a) {\n            var b = (a.options.data || []).map(function (b) {\n              v(b) && a.options.keys && a.options.keys.length && k.forEach(function (a) {\n                0 <= b.indexOf(a.x) && 0 <= b.indexOf(a.x2) && (b = a);\n              });\n              return K(b, !0) ? N(b) : b;\n            });\n            a.visible && a.setData(b, !1);\n          });\n          b.treeGrid.mapOptionsToLevel = n({\n            defaults: c,\n            from: 1,\n            levels: c && c.levels,\n            to: b.treeGrid.tree && b.treeGrid.tree.height\n          });\n          \"beforeRender\" === a.type && (b.treeGrid.collapsedNodes = d.collapsedNodes);\n        }\n      });\n    }\n\n    function t(b, d) {\n      var c = this.treeGrid.mapOptionsToLevel || {},\n          e = this.ticks,\n          f = e[d],\n          k;\n\n      if (\"treegrid\" === this.options.type && this.treeGrid.mapOfPosToGridNode) {\n        var h = this.treeGrid.mapOfPosToGridNode[d];\n        (c = c[h.depth]) && (k = {\n          labels: c\n        });\n        !f && a ? e[d] = new a(this, d, void 0, void 0, {\n          category: h.name,\n          tickmarkOffset: h.tickmarkOffset,\n          options: k\n        }) : (f.parameters.category = h.name, f.options = k, f.addLabel());\n      } else b.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n\n    function b(a, b, d) {\n      var c = this,\n          e = \"treegrid\" === d.type;\n      c.treeGrid || (c.treeGrid = new x(c));\n      e && (m(b, \"beforeRender\", p), m(b, \"beforeRedraw\", p), m(b, \"addSeries\", function (a) {\n        a.options.data && (a = y(a.options.data, d.uniqueNames || !1, 1), c.treeGrid.collapsedNodes = (c.treeGrid.collapsedNodes || []).concat(a.collapsedNodes));\n      }), m(c, \"foundExtremes\", function () {\n        c.treeGrid.collapsedNodes && c.treeGrid.collapsedNodes.forEach(function (a) {\n          var b = c.treeGrid.collapse(a);\n          c.brokenAxis && (c.brokenAxis.setBreaks(b, !1), c.treeGrid.collapsedNodes && (c.treeGrid.collapsedNodes = c.treeGrid.collapsedNodes.filter(function (b) {\n            return a.collapseStart !== b.collapseStart || a.collapseEnd !== b.collapseEnd;\n          })));\n        });\n      }), m(c, \"afterBreaks\", function () {\n        \"yAxis\" === c.coll && !c.staticScale && c.chart.options.chart.height && (c.isDirty = !0);\n      }), d = N({\n        grid: {\n          enabled: !0\n        },\n        labels: {\n          align: \"left\",\n          levels: [{\n            level: void 0\n          }, {\n            level: 1,\n            style: {\n              fontWeight: \"bold\"\n            }\n          }],\n          symbol: {\n            type: \"triangle\",\n            x: -5,\n            y: -5,\n            height: 10,\n            width: 10,\n            padding: 5\n          }\n        },\n        uniqueNames: !1\n      }, d, {\n        reversed: !0,\n        grid: {\n          columns: void 0\n        }\n      }));\n      a.apply(c, [b, d]);\n      e && (c.hasNames = !0, c.options.showLastLabel = !0);\n    }\n\n    function k(a) {\n      var b = this.options;\n      \"treegrid\" === b.type ? (this.min = H(this.userMin, b.min, this.dataMin), this.max = H(this.userMax, b.max, this.dataMax), d(this, \"foundExtremes\"), this.setAxisTranslation(), this.tickmarkOffset = .5, this.tickInterval = 1, this.tickPositions = this.treeGrid.mapOfPosToGridNode ? this.treeGrid.getTickPositions() : []) : a.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n\n    var n = A.getLevelOptions,\n        m = D.addEvent,\n        f = D.find,\n        d = D.fireEvent,\n        v = D.isArray,\n        K = D.isObject,\n        I = D.isString,\n        N = D.merge,\n        H = D.pick,\n        q = D.wrap,\n        w = [],\n        a,\n        x = function () {\n      function d(a) {\n        this.axis = a;\n      }\n\n      d.compose = function (d, e, g, f) {\n        if (-1 === w.indexOf(d)) {\n          w.push(d);\n          -1 === d.keepProps.indexOf(\"treeGrid\") && d.keepProps.push(\"treeGrid\");\n          var l = d.prototype;\n          q(l, \"generateTick\", t);\n          q(l, \"init\", b);\n          q(l, \"setTickInterval\", k);\n          l.utils = {\n            getNode: B.getNode\n          };\n        }\n\n        -1 === w.indexOf(f) && (w.push(f), a || (a = f));\n        h.compose(d, e, f);\n        c.compose(d, g);\n        E.compose(f);\n        return d;\n      };\n\n      d.prototype.setCollapsedStatus = function (a) {\n        var b = this.axis,\n            d = b.chart;\n        b.series.forEach(function (b) {\n          var c = b.options.data;\n\n          if (a.id && c) {\n            var e = d.get(a.id);\n            b = c[b.data.indexOf(e)];\n            e && b && (e.collapsed = a.collapsed, b.collapsed = a.collapsed);\n          }\n        });\n      };\n\n      d.prototype.collapse = function (a) {\n        var b = this.axis,\n            d = b.options.breaks || [],\n            c = F(a, b.max);\n        d.push(c);\n        a.collapsed = !0;\n        b.treeGrid.setCollapsedStatus(a);\n        return d;\n      };\n\n      d.prototype.expand = function (a) {\n        var b = this.axis,\n            d = b.options.breaks || [],\n            c = F(a, b.max);\n        a.collapsed = !1;\n        b.treeGrid.setCollapsedStatus(a);\n        return d.reduce(function (a, b) {\n          b.to === c.to && b.from === c.from || a.push(b);\n          return a;\n        }, []);\n      };\n\n      d.prototype.getTickPositions = function () {\n        var a = this.axis,\n            b = Math.floor(a.min / a.tickInterval) * a.tickInterval,\n            d = Math.ceil(a.max / a.tickInterval) * a.tickInterval;\n        return Object.keys(a.treeGrid.mapOfPosToGridNode || {}).reduce(function (c, e) {\n          e = +e;\n          !(e >= b && e <= d) || a.brokenAxis && a.brokenAxis.isInAnyBreak(e) || c.push(e);\n          return c;\n        }, []);\n      };\n\n      d.prototype.isCollapsed = function (a) {\n        var b = this.axis,\n            d = b.options.breaks || [],\n            c = F(a, b.max);\n        return d.some(function (a) {\n          return a.from === c.from && a.to === c.to;\n        });\n      };\n\n      d.prototype.toggleCollapse = function (a) {\n        return this.isCollapsed(a) ? this.expand(a) : this.collapse(a);\n      };\n\n      return d;\n    }();\n\n    return x;\n  });\n  O(h, \"Extensions/CurrentDateIndication.js\", [h[\"Core/Axis/Axis.js\"], h[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var E = B.addEvent,\n        A = B.merge;\n    B = B.wrap;\n    var D = {\n      color: \"#ccd6eb\",\n      width: 2,\n      label: {\n        format: \"%a, %b %d %Y, %H:%M\",\n        formatter: function (c, h) {\n          return this.axis.chart.time.dateFormat(h || \"\", c);\n        },\n        rotation: 0,\n        style: {\n          fontSize: \"10px\"\n        }\n      }\n    };\n    E(c, \"afterSetOptions\", function () {\n      var c = this.options,\n          h = c.currentDateIndicator;\n      h && (h = \"object\" === typeof h ? A(D, h) : A(D), h.value = Date.now(), h.className = \"highcharts-current-date-indicator\", c.plotLines || (c.plotLines = []), c.plotLines.push(h));\n    });\n    E(h, \"render\", function () {\n      this.label && this.label.attr({\n        text: this.getLabelText(this.options.label)\n      });\n    });\n    B(h.prototype, \"getLabelText\", function (c, h) {\n      var p = this.options;\n      return p && p.className && -1 !== p.className.indexOf(\"highcharts-current-date-indicator\") && p.label && \"function\" === typeof p.label.formatter ? (p.value = Date.now(), p.label.formatter.call(this, p.value, p.label.format)) : c.call(this, h);\n    });\n  });\n  O(h, \"Extensions/StaticScale.js\", [h[\"Core/Axis/Axis.js\"], h[\"Core/Chart/Chart.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var E = B.addEvent,\n        A = B.defined,\n        D = B.isNumber,\n        F = B.pick;\n    E(c, \"afterSetOptions\", function () {\n      var c = this.chart.options.chart;\n      !this.horiz && D(this.options.staticScale) && (!c.height || c.scrollablePlotArea && c.scrollablePlotArea.minHeight) && (this.staticScale = this.options.staticScale);\n    });\n\n    h.prototype.adjustHeight = function () {\n      \"adjustHeight\" !== this.redrawTrigger && ((this.axes || []).forEach(function (c) {\n        var h = c.chart,\n            t = !!h.initiatedScale && h.options.animation,\n            b = c.options.staticScale;\n\n        if (c.staticScale && A(c.min)) {\n          var k = F(c.brokenAxis && c.brokenAxis.unitLength, c.max + c.tickInterval - c.min) * b;\n          k = Math.max(k, b);\n          b = k - h.plotHeight;\n          !h.scrollablePixelsY && 1 <= Math.abs(b) && (h.plotHeight = k, h.redrawTrigger = \"adjustHeight\", h.setSize(void 0, h.chartHeight + b, t));\n          c.series.forEach(function (b) {\n            (b = b.sharedClipKey && h.sharedClips[b.sharedClipKey]) && b.attr(h.inverted ? {\n              width: h.plotHeight\n            } : {\n              height: h.plotHeight\n            });\n          });\n        }\n      }), this.initiatedScale = !0);\n      this.redrawTrigger = null;\n    };\n\n    E(h, \"render\", h.prototype.adjustHeight);\n  });\n  O(h, \"Extensions/ArrowSymbols.js\", [h[\"Core/Renderer/SVG/SVGRenderer.js\"]], function (c) {\n    function h(c, h, B, y) {\n      return [[\"M\", c, h + y / 2], [\"L\", c + B, h], [\"L\", c, h + y / 2], [\"L\", c + B, h + y]];\n    }\n\n    function B(c, h, B, y) {\n      return [[\"M\", c + B, h], [\"L\", c, h + y / 2], [\"L\", c + B, h + y], [\"Z\"]];\n    }\n\n    function E(c, h, E, y) {\n      return B(c, h, E / 2, y);\n    }\n\n    c = c.prototype.symbols;\n    c.arrow = h;\n    c[\"arrow-filled\"] = B;\n    c[\"arrow-filled-half\"] = E;\n\n    c[\"arrow-half\"] = function (c, B, E, y) {\n      return h(c, B, E / 2, y);\n    };\n\n    c[\"triangle-left\"] = B;\n    c[\"triangle-left-half\"] = E;\n    return c;\n  });\n  O(h, \"Gantt/Connection.js\", [h[\"Core/Globals.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E) {\n    function A(b) {\n      var c = b.shapeArgs;\n      return c ? {\n        xMin: c.x || 0,\n        xMax: (c.x || 0) + (c.width || 0),\n        yMin: c.y || 0,\n        yMax: (c.y || 0) + (c.height || 0)\n      } : (c = b.graphic && b.graphic.getBBox()) ? {\n        xMin: b.plotX - c.width / 2,\n        xMax: b.plotX + c.width / 2,\n        yMin: b.plotY - c.height / 2,\n        yMax: b.plotY + c.height / 2\n      } : null;\n    }\n\n    \"\";\n    var D = E.defined,\n        F = E.error,\n        y = E.extend,\n        p = E.merge,\n        t = E.objectEach,\n        b = c.deg2rad,\n        k = Math.max,\n        n = Math.min;\n    y(h.defaultOptions, {\n      connectors: {\n        type: \"straight\",\n        lineWidth: 1,\n        marker: {\n          enabled: !1,\n          align: \"center\",\n          verticalAlign: \"middle\",\n          inside: !1,\n          lineWidth: 1\n        },\n        startMarker: {\n          symbol: \"diamond\"\n        },\n        endMarker: {\n          symbol: \"arrow-filled\"\n        }\n      }\n    });\n\n    h = function () {\n      function c(b, d, c) {\n        this.toPoint = this.pathfinder = this.graphics = this.fromPoint = this.chart = void 0;\n        this.init(b, d, c);\n      }\n\n      c.prototype.init = function (b, d, c) {\n        this.fromPoint = b;\n        this.toPoint = d;\n        this.options = c;\n        this.chart = b.series.chart;\n        this.pathfinder = this.chart.pathfinder;\n      };\n\n      c.prototype.renderPath = function (b, d, c) {\n        var f = this.chart,\n            k = f.styledMode,\n            h = f.pathfinder,\n            m = !f.options.chart.forExport && !1 !== c,\n            n = this.graphics && this.graphics.path;\n        h.group || (h.group = f.renderer.g().addClass(\"highcharts-pathfinder-group\").attr({\n          zIndex: -1\n        }).add(f.seriesGroup));\n        h.group.translate(f.plotLeft, f.plotTop);\n        n && n.renderer || (n = f.renderer.path().add(h.group), k || n.attr({\n          opacity: 0\n        }));\n        n.attr(d);\n        b = {\n          d: b\n        };\n        k || (b.opacity = 1);\n        n[m ? \"animate\" : \"attr\"](b, c);\n        this.graphics = this.graphics || {};\n        this.graphics.path = n;\n      };\n\n      c.prototype.addMarker = function (c, d, k) {\n        var f = this.fromPoint.series.chart,\n            h = f.pathfinder;\n        f = f.renderer;\n        var m = \"start\" === c ? this.fromPoint : this.toPoint,\n            n = m.getPathfinderAnchorPoint(d);\n\n        if (d.enabled && ((k = \"start\" === c ? k[1] : k[k.length - 2]) && \"M\" === k[0] || \"L\" === k[0])) {\n          k = {\n            x: k[1],\n            y: k[2]\n          };\n          k = m.getRadiansToVector(k, n);\n          n = m.getMarkerVector(k, d.radius, n);\n          k = -k / b;\n\n          if (d.width && d.height) {\n            var p = d.width;\n            var v = d.height;\n          } else p = v = 2 * d.radius;\n\n          this.graphics = this.graphics || {};\n          n = {\n            x: n.x - p / 2,\n            y: n.y - v / 2,\n            width: p,\n            height: v,\n            rotation: k,\n            rotationOriginX: n.x,\n            rotationOriginY: n.y\n          };\n          this.graphics[c] ? this.graphics[c].animate(n) : (this.graphics[c] = f.symbol(d.symbol).addClass(\"highcharts-point-connecting-path-\" + c + \"-marker\").attr(n).add(h.group), f.styledMode || this.graphics[c].attr({\n            fill: d.color || this.fromPoint.color,\n            stroke: d.lineColor,\n            \"stroke-width\": d.lineWidth,\n            opacity: 0\n          }).animate({\n            opacity: 1\n          }, m.series.options.animation));\n        }\n      };\n\n      c.prototype.getPath = function (b) {\n        var c = this.pathfinder,\n            f = this.chart,\n            k = c.algorithms[b.type],\n            h = c.chartObstacles;\n        if (\"function\" !== typeof k) return F('\"' + b.type + '\" is not a Pathfinder algorithm.'), {\n          path: [],\n          obstacles: []\n        };\n        k.requiresObstacles && !h && (h = c.chartObstacles = c.getChartObstacles(b), f.options.connectors.algorithmMargin = b.algorithmMargin, c.chartObstacleMetrics = c.getObstacleMetrics(h));\n        return k(this.fromPoint.getPathfinderAnchorPoint(b.startMarker), this.toPoint.getPathfinderAnchorPoint(b.endMarker), p({\n          chartObstacles: h,\n          lineObstacles: c.lineObstacles || [],\n          obstacleMetrics: c.chartObstacleMetrics,\n          hardBounds: {\n            xMin: 0,\n            xMax: f.plotWidth,\n            yMin: 0,\n            yMax: f.plotHeight\n          },\n          obstacleOptions: {\n            margin: b.algorithmMargin\n          },\n          startDirectionX: c.getAlgorithmStartDirection(b.startMarker)\n        }, b));\n      };\n\n      c.prototype.render = function () {\n        var b = this.fromPoint,\n            c = b.series,\n            h = c.chart,\n            m = h.pathfinder,\n            t = p(h.options.connectors, c.options.connectors, b.options.connectors, this.options),\n            y = {};\n        h.styledMode || (y.stroke = t.lineColor || b.color, y[\"stroke-width\"] = t.lineWidth, t.dashStyle && (y.dashstyle = t.dashStyle));\n        y[\"class\"] = \"highcharts-point-connecting-path highcharts-color-\" + b.colorIndex;\n        t = p(y, t);\n        D(t.marker.radius) || (t.marker.radius = n(k(Math.ceil((t.algorithmMargin || 8) / 2) - 1, 1), 5));\n        b = this.getPath(t);\n        h = b.path;\n        b.obstacles && (m.lineObstacles = m.lineObstacles || [], m.lineObstacles = m.lineObstacles.concat(b.obstacles));\n        this.renderPath(h, y, c.options.animation);\n        this.addMarker(\"start\", p(t.marker, t.startMarker), h);\n        this.addMarker(\"end\", p(t.marker, t.endMarker), h);\n      };\n\n      c.prototype.destroy = function () {\n        this.graphics && (t(this.graphics, function (b) {\n          b.destroy();\n        }), delete this.graphics);\n      };\n\n      return c;\n    }();\n\n    c.Connection = h;\n    y(B.prototype, {\n      getPathfinderAnchorPoint: function (b) {\n        var c = A(this);\n\n        switch (b.align) {\n          case \"right\":\n            var d = \"xMax\";\n            break;\n\n          case \"left\":\n            d = \"xMin\";\n        }\n\n        switch (b.verticalAlign) {\n          case \"top\":\n            var k = \"yMin\";\n            break;\n\n          case \"bottom\":\n            k = \"yMax\";\n        }\n\n        return {\n          x: d ? c[d] : (c.xMin + c.xMax) / 2,\n          y: k ? c[k] : (c.yMin + c.yMax) / 2\n        };\n      },\n      getRadiansToVector: function (b, c) {\n        var d;\n        D(c) || (d = A(this)) && (c = {\n          x: (d.xMin + d.xMax) / 2,\n          y: (d.yMin + d.yMax) / 2\n        });\n        return Math.atan2(c.y - b.y, b.x - c.x);\n      },\n      getMarkerVector: function (b, c, d) {\n        var f = 2 * Math.PI,\n            k = A(this),\n            h = k.xMax - k.xMin,\n            m = k.yMax - k.yMin,\n            n = Math.atan2(m, h),\n            p = !1;\n        h /= 2;\n        var t = m / 2,\n            a = k.xMin + h;\n        k = k.yMin + t;\n\n        for (var x = a, e = k, u = 1, l = 1; b < -Math.PI;) b += f;\n\n        for (; b > Math.PI;) b -= f;\n\n        f = Math.tan(b);\n        b > -n && b <= n ? (l = -1, p = !0) : b > n && b <= Math.PI - n ? l = -1 : b > Math.PI - n || b <= -(Math.PI - n) ? (u = -1, p = !0) : u = -1;\n        p ? (x += u * h, e += l * h * f) : (x += m / (2 * f) * u, e += l * t);\n        d.x !== a && (x = d.x);\n        d.y !== k && (e = d.y);\n        return {\n          x: x + c * Math.cos(b),\n          y: e - c * Math.sin(b)\n        };\n      }\n    });\n    return h;\n  });\n  O(h, \"Gantt/PathfinderAlgorithms.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    function h(b, c, h) {\n      h = h || 0;\n      var k = b.length - 1;\n      c -= 1e-7;\n\n      for (var f, d; h <= k;) if (f = k + h >> 1, d = c - b[f].xMin, 0 < d) h = f + 1;else if (0 > d) k = f - 1;else return f;\n\n      return 0 < h ? h - 1 : 0;\n    }\n\n    function B(b, c) {\n      for (var k = h(b, c.x + 1) + 1; k--;) {\n        var m;\n        if (m = b[k].xMax >= c.x) m = b[k], m = c.x <= m.xMax && c.x >= m.xMin && c.y <= m.yMax && c.y >= m.yMin;\n        if (m) return k;\n      }\n\n      return -1;\n    }\n\n    function E(b) {\n      var c = [];\n\n      if (b.length) {\n        c.push([\"M\", b[0].start.x, b[0].start.y]);\n\n        for (var h = 0; h < b.length; ++h) c.push([\"L\", b[h].end.x, b[h].end.y]);\n      }\n\n      return c;\n    }\n\n    function A(b, c) {\n      b.yMin = y(b.yMin, c.yMin);\n      b.yMax = F(b.yMax, c.yMax);\n      b.xMin = y(b.xMin, c.xMin);\n      b.xMax = F(b.xMax, c.xMax);\n    }\n\n    var D = c.pick,\n        F = Math.min,\n        y = Math.max,\n        p = Math.abs;\n\n    c = function (b, c, h) {\n      function k(b, c, a, d, e) {\n        b = {\n          x: b.x,\n          y: b.y\n        };\n        b[c] = a[d || c] + (e || 0);\n        return b;\n      }\n\n      function f(b, c, a) {\n        var d = p(c[a] - b[a + \"Min\"]) > p(c[a] - b[a + \"Max\"]);\n        return k(c, a, b, a + (d ? \"Max\" : \"Min\"), d ? 1 : -1);\n      }\n\n      var d = [],\n          n = D(h.startDirectionX, p(c.x - b.x) > p(c.y - b.y)) ? \"x\" : \"y\",\n          t = h.chartObstacles,\n          y = B(t, b);\n      h = B(t, c);\n\n      if (-1 < h) {\n        var A = t[h];\n        h = f(A, c, n);\n        A = {\n          start: h,\n          end: c\n        };\n        var H = h;\n      } else H = c;\n\n      -1 < y && (t = t[y], h = f(t, b, n), d.push({\n        start: b,\n        end: h\n      }), h[n] >= b[n] === h[n] >= H[n] && (n = \"y\" === n ? \"x\" : \"y\", c = b[n] < c[n], d.push({\n        start: h,\n        end: k(h, n, t, n + (c ? \"Max\" : \"Min\"), c ? 1 : -1)\n      }), n = \"y\" === n ? \"x\" : \"y\"));\n      b = d.length ? d[d.length - 1].end : b;\n      h = k(b, n, H);\n      d.push({\n        start: b,\n        end: h\n      });\n      n = k(h, \"y\" === n ? \"x\" : \"y\", H);\n      d.push({\n        start: h,\n        end: n\n      });\n      d.push(A);\n      return {\n        path: E(d),\n        obstacles: d\n      };\n    };\n\n    c.requiresObstacles = !0;\n\n    var t = function (b, c, n) {\n      function k(a, b, c) {\n        var d,\n            e = a.x < b.x ? 1 : -1;\n\n        if (a.x < b.x) {\n          var g = a;\n          var f = b;\n        } else g = b, f = a;\n\n        if (a.y < b.y) {\n          var k = a;\n          var l = b;\n        } else k = b, l = a;\n\n        for (d = 0 > e ? F(h(u, f.x), u.length - 1) : 0; u[d] && (0 < e && u[d].xMin <= f.x || 0 > e && u[d].xMax >= g.x);) {\n          if (u[d].xMin <= f.x && u[d].xMax >= g.x && u[d].yMin <= l.y && u[d].yMax >= k.y) return c ? {\n            y: a.y,\n            x: a.x < b.x ? u[d].xMin - 1 : u[d].xMax + 1,\n            obstacle: u[d]\n          } : {\n            x: a.x,\n            y: a.y < b.y ? u[d].yMin - 1 : u[d].yMax + 1,\n            obstacle: u[d]\n          };\n          d += e;\n        }\n\n        return b;\n      }\n\n      function f(a, b, c, d, e) {\n        var g = e.soft,\n            f = e.hard,\n            h = d ? \"x\" : \"y\",\n            l = {\n          x: b.x,\n          y: b.y\n        },\n            r = {\n          x: b.x,\n          y: b.y\n        };\n        e = a[h + \"Max\"] >= g[h + \"Max\"];\n        g = a[h + \"Min\"] <= g[h + \"Min\"];\n        var m = a[h + \"Max\"] >= f[h + \"Max\"];\n        f = a[h + \"Min\"] <= f[h + \"Min\"];\n        var n = p(a[h + \"Min\"] - b[h]),\n            q = p(a[h + \"Max\"] - b[h]);\n        c = 10 > p(n - q) ? b[h] < c[h] : q < n;\n        r[h] = a[h + \"Min\"];\n        l[h] = a[h + \"Max\"];\n        a = k(b, r, d)[h] !== r[h];\n        b = k(b, l, d)[h] !== l[h];\n        c = a ? b ? c : !0 : b ? !1 : c;\n        c = g ? e ? c : !0 : e ? !1 : c;\n        return f ? m ? c : !0 : m ? !1 : c;\n      }\n\n      function d(b, c, g) {\n        if (b.x === c.x && b.y === c.y) return [];\n        var h = g ? \"x\" : \"y\",\n            l = n.obstacleOptions.margin;\n        var r = {\n          soft: {\n            xMin: w,\n            xMax: a,\n            yMin: x,\n            yMax: e\n          },\n          hard: n.hardBounds\n        };\n        var m = B(u, b);\n\n        if (-1 < m) {\n          m = u[m];\n          r = f(m, b, c, g, r);\n          A(m, n.hardBounds);\n          var p = g ? {\n            y: b.y,\n            x: m[r ? \"xMax\" : \"xMin\"] + (r ? 1 : -1)\n          } : {\n            x: b.x,\n            y: m[r ? \"yMax\" : \"yMin\"] + (r ? 1 : -1)\n          };\n          var q = B(u, p);\n          -1 < q && (q = u[q], A(q, n.hardBounds), p[h] = r ? y(m[h + \"Max\"] - l + 1, (q[h + \"Min\"] + m[h + \"Max\"]) / 2) : F(m[h + \"Min\"] + l - 1, (q[h + \"Max\"] + m[h + \"Min\"]) / 2), b.x === p.x && b.y === p.y ? (H && (p[h] = r ? y(m[h + \"Max\"], q[h + \"Max\"]) + 1 : F(m[h + \"Min\"], q[h + \"Min\"]) - 1), H = !H) : H = !1);\n          b = [{\n            start: b,\n            end: p\n          }];\n        } else h = k(b, {\n          x: g ? c.x : b.x,\n          y: g ? b.y : c.y\n        }, g), b = [{\n          start: b,\n          end: {\n            x: h.x,\n            y: h.y\n          }\n        }], h[g ? \"x\" : \"y\"] !== c[g ? \"x\" : \"y\"] && (r = f(h.obstacle, h, c, !g, r), A(h.obstacle, n.hardBounds), r = {\n          x: g ? h.x : h.obstacle[r ? \"xMax\" : \"xMin\"] + (r ? 1 : -1),\n          y: g ? h.obstacle[r ? \"yMax\" : \"yMin\"] + (r ? 1 : -1) : h.y\n        }, g = !g, b = b.concat(d({\n          x: h.x,\n          y: h.y\n        }, r, g)));\n\n        return b = b.concat(d(b[b.length - 1].end, c, !g));\n      }\n\n      function t(a, b, c) {\n        var d = F(a.xMax - b.x, b.x - a.xMin) < F(a.yMax - b.y, b.y - a.yMin);\n        c = f(a, b, c, d, {\n          soft: n.hardBounds,\n          hard: n.hardBounds\n        });\n        return d ? {\n          y: b.y,\n          x: a[c ? \"xMax\" : \"xMin\"] + (c ? 1 : -1)\n        } : {\n          x: b.x,\n          y: a[c ? \"yMax\" : \"yMin\"] + (c ? 1 : -1)\n        };\n      }\n\n      var K = D(n.startDirectionX, p(c.x - b.x) > p(c.y - b.y)),\n          I = K ? \"x\" : \"y\",\n          N = [],\n          H = !1,\n          q = n.obstacleMetrics,\n          w = F(b.x, c.x) - q.maxWidth - 10,\n          a = y(b.x, c.x) + q.maxWidth + 10,\n          x = F(b.y, c.y) - q.maxHeight - 10,\n          e = y(b.y, c.y) + q.maxHeight + 10,\n          u = n.chartObstacles;\n      var l = h(u, w);\n      q = h(u, a);\n      u = u.slice(l, q + 1);\n\n      if (-1 < (q = B(u, c))) {\n        var g = t(u[q], c, b);\n        N.push({\n          end: c,\n          start: g\n        });\n        c = g;\n      }\n\n      for (; -1 < (q = B(u, c));) l = 0 > c[I] - b[I], g = {\n        x: c.x,\n        y: c.y\n      }, g[I] = u[q][l ? I + \"Max\" : I + \"Min\"] + (l ? 1 : -1), N.push({\n        end: c,\n        start: g\n      }), c = g;\n\n      b = d(b, c, K);\n      b = b.concat(N.reverse());\n      return {\n        path: E(b),\n        obstacles: b\n      };\n    };\n\n    t.requiresObstacles = !0;\n    return {\n      fastAvoid: t,\n      straight: function (b, c) {\n        return {\n          path: [[\"M\", b.x, b.y], [\"L\", c.x, c.y]],\n          obstacles: [{\n            start: b,\n            end: c\n          }]\n        };\n      },\n      simpleConnect: c\n    };\n  });\n  O(h, \"Gantt/Pathfinder.js\", [h[\"Gantt/Connection.js\"], h[\"Core/Chart/Chart.js\"], h[\"Core/Globals.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Series/Point.js\"], h[\"Core/Utilities.js\"], h[\"Gantt/PathfinderAlgorithms.js\"]], function (c, h, B, E, A, D, F) {\n    function y(b) {\n      var c = b.shapeArgs;\n      return c ? {\n        xMin: c.x || 0,\n        xMax: (c.x || 0) + (c.width || 0),\n        yMin: c.y || 0,\n        yMax: (c.y || 0) + (c.height || 0)\n      } : (c = b.graphic && b.graphic.getBBox()) ? {\n        xMin: b.plotX - c.width / 2,\n        xMax: b.plotX + c.width / 2,\n        yMin: b.plotY - c.height / 2,\n        yMax: b.plotY + c.height / 2\n      } : null;\n    }\n\n    function p(b) {\n      for (var c = b.length, f = 0, a, h, e = [], k = function (a, b, c) {\n        c = d(c, 10);\n        var e = a.yMax + c > b.yMin - c && a.yMin - c < b.yMax + c,\n            g = a.xMax + c > b.xMin - c && a.xMin - c < b.xMax + c,\n            f = e ? a.xMin > b.xMax ? a.xMin - b.xMax : b.xMin - a.xMax : Infinity,\n            h = g ? a.yMin > b.yMax ? a.yMin - b.yMax : b.yMin - a.yMax : Infinity;\n        return g && e ? c ? k(a, b, Math.floor(c / 2)) : Infinity : I(f, h);\n      }; f < c; ++f) for (a = f + 1; a < c; ++a) h = k(b[f], b[a]), 80 > h && e.push(h);\n\n      e.push(80);\n      return K(Math.floor(e.sort(function (a, b) {\n        return a - b;\n      })[Math.floor(e.length / 10)] / 2 - 1), 1);\n    }\n\n    function t(b) {\n      if (b.options.pathfinder || b.series.reduce(function (b, c) {\n        c.options && f(!0, c.options.connectors = c.options.connectors || {}, c.options.pathfinder);\n        return b || c.options && c.options.pathfinder;\n      }, !1)) f(!0, b.options.connectors = b.options.connectors || {}, b.options.pathfinder), n('WARNING: Pathfinder options have been renamed. Use \"chart.connectors\" or \"series.connectors\" instead.');\n    }\n\n    \"\";\n    var b = D.addEvent,\n        k = D.defined,\n        n = D.error,\n        m = D.extend,\n        f = D.merge,\n        d = D.pick,\n        v = D.splat,\n        K = Math.max,\n        I = Math.min;\n    m(E.defaultOptions, {\n      connectors: {\n        type: \"straight\",\n        lineWidth: 1,\n        marker: {\n          enabled: !1,\n          align: \"center\",\n          verticalAlign: \"middle\",\n          inside: !1,\n          lineWidth: 1\n        },\n        startMarker: {\n          symbol: \"diamond\"\n        },\n        endMarker: {\n          symbol: \"arrow-filled\"\n        }\n      }\n    });\n\n    var N = function () {\n      function f(b) {\n        this.lineObstacles = this.group = this.connections = this.chartObstacleMetrics = this.chartObstacles = this.chart = void 0;\n        this.init(b);\n      }\n\n      f.prototype.init = function (c) {\n        this.chart = c;\n        this.connections = [];\n        b(c, \"redraw\", function () {\n          this.pathfinder.update();\n        });\n      };\n\n      f.prototype.update = function (b) {\n        var d = this.chart,\n            a = this,\n            f = a.connections;\n        a.connections = [];\n        d.series.forEach(function (b) {\n          b.visible && !b.options.isInternal && b.points.forEach(function (b) {\n            var e = b.options;\n            e && e.dependency && (e.connect = e.dependency);\n            var g;\n            e = b.options && b.options.connect && v(b.options.connect);\n            b.visible && !1 !== b.isInside && e && e.forEach(function (e) {\n              g = d.get(\"string\" === typeof e ? e : e.to);\n              g instanceof A && g.series.visible && g.visible && !1 !== g.isInside && a.connections.push(new c(b, g, \"string\" === typeof e ? {} : e));\n            });\n          });\n        });\n\n        for (var e = 0, h = void 0, k = void 0, g = f.length, m = a.connections.length; e < g; ++e) {\n          k = !1;\n\n          for (h = 0; h < m; ++h) if (f[e].fromPoint === a.connections[h].fromPoint && f[e].toPoint === a.connections[h].toPoint) {\n            a.connections[h].graphics = f[e].graphics;\n            k = !0;\n            break;\n          }\n\n          k || f[e].destroy();\n        }\n\n        delete this.chartObstacles;\n        delete this.lineObstacles;\n        a.renderConnections(b);\n      };\n\n      f.prototype.renderConnections = function (c) {\n        c ? this.chart.series.forEach(function (c) {\n          var a = function () {\n            var a = c.chart.pathfinder;\n            (a && a.connections || []).forEach(function (a) {\n              a.fromPoint && a.fromPoint.series === c && a.render();\n            });\n            c.pathfinderRemoveRenderEvent && (c.pathfinderRemoveRenderEvent(), delete c.pathfinderRemoveRenderEvent);\n          };\n\n          !1 === c.options.animation ? a() : c.pathfinderRemoveRenderEvent = b(c, \"afterAnimate\", a);\n        }) : this.connections.forEach(function (b) {\n          b.render();\n        });\n      };\n\n      f.prototype.getChartObstacles = function (b) {\n        for (var c = [], a = this.chart.series, f = d(b.algorithmMargin, 0), e, h = 0, l = a.length; h < l; ++h) if (a[h].visible && !a[h].options.isInternal) {\n          var g = 0,\n              m = a[h].points.length,\n              n = void 0;\n\n          for (n = void 0; g < m; ++g) n = a[h].points[g], n.visible && (n = y(n)) && c.push({\n            xMin: n.xMin - f,\n            xMax: n.xMax + f,\n            yMin: n.yMin - f,\n            yMax: n.yMax + f\n          });\n        }\n\n        c = c.sort(function (a, b) {\n          return a.xMin - b.xMin;\n        });\n        k(b.algorithmMargin) || (e = b.algorithmMargin = p(c), c.forEach(function (a) {\n          a.xMin -= e;\n          a.xMax += e;\n          a.yMin -= e;\n          a.yMax += e;\n        }));\n        return c;\n      };\n\n      f.prototype.getObstacleMetrics = function (b) {\n        for (var c = 0, a = 0, d, e, f = b.length; f--;) d = b[f].xMax - b[f].xMin, e = b[f].yMax - b[f].yMin, c < d && (c = d), a < e && (a = e);\n\n        return {\n          maxHeight: a,\n          maxWidth: c\n        };\n      };\n\n      f.prototype.getAlgorithmStartDirection = function (b) {\n        var c = \"top\" !== b.verticalAlign && \"bottom\" !== b.verticalAlign;\n        return \"left\" !== b.align && \"right\" !== b.align ? c ? void 0 : !1 : c ? !0 : void 0;\n      };\n\n      return f;\n    }();\n\n    N.prototype.algorithms = F;\n    B.Pathfinder = N;\n    m(A.prototype, {\n      getPathfinderAnchorPoint: function (b) {\n        var c = y(this);\n\n        switch (b.align) {\n          case \"right\":\n            var d = \"xMax\";\n            break;\n\n          case \"left\":\n            d = \"xMin\";\n        }\n\n        switch (b.verticalAlign) {\n          case \"top\":\n            var a = \"yMin\";\n            break;\n\n          case \"bottom\":\n            a = \"yMax\";\n        }\n\n        return {\n          x: d ? c[d] : (c.xMin + c.xMax) / 2,\n          y: a ? c[a] : (c.yMin + c.yMax) / 2\n        };\n      },\n      getRadiansToVector: function (b, c) {\n        var d;\n        k(c) || (d = y(this)) && (c = {\n          x: (d.xMin + d.xMax) / 2,\n          y: (d.yMin + d.yMax) / 2\n        });\n        return Math.atan2(c.y - b.y, b.x - c.x);\n      },\n      getMarkerVector: function (b, c, d) {\n        var a = 2 * Math.PI,\n            f = y(this),\n            e = f.xMax - f.xMin,\n            h = f.yMax - f.yMin,\n            k = Math.atan2(h, e),\n            g = !1;\n        e /= 2;\n        var m = h / 2,\n            n = f.xMin + e;\n        f = f.yMin + m;\n\n        for (var r = n, p = f, q = 1, t = 1; b < -Math.PI;) b += a;\n\n        for (; b > Math.PI;) b -= a;\n\n        a = Math.tan(b);\n        b > -k && b <= k ? (t = -1, g = !0) : b > k && b <= Math.PI - k ? t = -1 : b > Math.PI - k || b <= -(Math.PI - k) ? (q = -1, g = !0) : q = -1;\n        g ? (r += q * e, p += t * e * a) : (r += h / (2 * a) * q, p += t * m);\n        d.x !== n && (r = d.x);\n        d.y !== f && (p = d.y);\n        return {\n          x: r + c * Math.cos(b),\n          y: p - c * Math.sin(b)\n        };\n      }\n    });\n    h.prototype.callbacks.push(function (b) {\n      !1 !== b.options.connectors.enabled && (t(b), this.pathfinder = new N(this), this.pathfinder.update(!0));\n    });\n    return N;\n  });\n  O(h, \"Series/Gantt/GanttSeries.js\", [h[\"Core/Axis/Axis.js\"], h[\"Core/Chart/Chart.js\"], h[\"Series/Gantt/GanttPoint.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Axis/Tick.js\"], h[\"Core/Utilities.js\"], h[\"Core/Axis/TreeGrid/TreeGridAxis.js\"]], function (c, h, B, E, A, D, F) {\n    var y = this && this.__extends || function () {\n      var b = function (c, d) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, c) {\n          b.__proto__ = c;\n        } || function (b, c) {\n          for (var d in c) c.hasOwnProperty(d) && (b[d] = c[d]);\n        };\n\n        return b(c, d);\n      };\n\n      return function (c, d) {\n        function f() {\n          this.constructor = c;\n        }\n\n        b(c, d);\n        c.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());\n      };\n    }(),\n        p = E.series,\n        t = E.seriesTypes.xrange,\n        b = D.extend,\n        k = D.isNumber,\n        n = D.merge;\n\n    F.compose(c, h, p, A);\n\n    c = function (b) {\n      function c() {\n        var c = null !== b && b.apply(this, arguments) || this;\n        c.data = void 0;\n        c.options = void 0;\n        c.points = void 0;\n        return c;\n      }\n\n      y(c, b);\n\n      c.prototype.drawPoint = function (b, c) {\n        var d = this.options,\n            f = this.chart.renderer,\n            h = b.shapeArgs,\n            m = b.plotY,\n            n = b.graphic,\n            p = b.selected && \"select\",\n            a = d.stacking && !d.borderRadius;\n        if (b.options.milestone) {\n          if (k(m) && null !== b.y && !1 !== b.visible) {\n            h = f.symbols.diamond(h.x || 0, h.y || 0, h.width || 0, h.height || 0);\n            if (n) n[c]({\n              d: h\n            });else b.graphic = f.path(h).addClass(b.getClassName(), !0).add(b.group || this.group);\n            this.chart.styledMode || b.graphic.attr(this.pointAttribs(b, p)).shadow(d.shadow, null, a);\n          } else n && (b.graphic = n.destroy());\n        } else t.prototype.drawPoint.call(this, b, c);\n      };\n\n      c.prototype.translatePoint = function (b) {\n        t.prototype.translatePoint.call(this, b);\n\n        if (b.options.milestone) {\n          var c = b.shapeArgs;\n          var d = c.height || 0;\n          b.shapeArgs = {\n            x: (c.x || 0) - d / 2,\n            y: c.y,\n            width: d,\n            height: d\n          };\n        }\n      };\n\n      c.defaultOptions = n(t.defaultOptions, {\n        grouping: !1,\n        dataLabels: {\n          enabled: !0\n        },\n        tooltip: {\n          headerFormat: '<span style=\"font-size: 10px\">{series.name}</span><br/>',\n          pointFormat: null,\n          pointFormatter: function () {\n            var b = this.series,\n                c = b.xAxis,\n                f = b.tooltipOptions.dateTimeLabelFormats,\n                h = c.options.startOfWeek,\n                m = b.tooltipOptions,\n                n = m.xDateFormat,\n                p = this.options.milestone,\n                t = \"<b>\" + (this.name || this.yCategory) + \"</b>\";\n            if (m.pointFormat) return this.tooltipFormatter(m.pointFormat);\n            !n && k(this.start) && (n = b.chart.time.getDateFormat(c.closestPointRange, this.start, h, f || {}));\n            c = b.chart.time.dateFormat(n, this.start);\n            b = b.chart.time.dateFormat(n, this.end);\n            t += \"<br/>\";\n            return p ? t + (c + \"<br/>\") : t + (\"Start: \" + c + \"<br/>End: \") + (b + \"<br/>\");\n          }\n        },\n        connectors: {\n          type: \"simpleConnect\",\n          animation: {\n            reversed: !0\n          },\n          startMarker: {\n            enabled: !0,\n            symbol: \"arrow-filled\",\n            radius: 4,\n            fill: \"#fa0\",\n            align: \"left\"\n          },\n          endMarker: {\n            enabled: !1,\n            align: \"right\"\n          }\n        }\n      });\n      return c;\n    }(t);\n\n    b(c.prototype, {\n      pointArrayMap: [\"start\", \"end\", \"y\"],\n      pointClass: B,\n      setData: p.prototype.setData\n    });\n    E.registerSeriesType(\"gantt\", c);\n    \"\";\n    return c;\n  });\n  O(h, \"Core/Chart/GanttChart.js\", [h[\"Core/Chart/Chart.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Utilities.js\"]], function (c, h, B) {\n    var E = this && this.__extends || function () {\n      var c = function (h, b) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, c) {\n          b.__proto__ = c;\n        } || function (b, c) {\n          for (var h in c) c.hasOwnProperty(h) && (b[h] = c[h]);\n        };\n\n        return c(h, b);\n      };\n\n      return function (h, b) {\n        function k() {\n          this.constructor = h;\n        }\n\n        c(h, b);\n        h.prototype = null === b ? Object.create(b) : (k.prototype = b.prototype, new k());\n      };\n    }(),\n        A = h.getOptions,\n        D = B.isArray,\n        F = B.merge,\n        y = B.splat;\n\n    c = function (c) {\n      function h() {\n        return null !== c && c.apply(this, arguments) || this;\n      }\n\n      E(h, c);\n\n      h.prototype.init = function (b, h) {\n        var k = A(),\n            m = b.xAxis,\n            f = b.yAxis,\n            d;\n        b.xAxis = b.yAxis = void 0;\n        var p = F(!0, {\n          chart: {\n            type: \"gantt\"\n          },\n          title: {\n            text: null\n          },\n          legend: {\n            enabled: !1\n          },\n          navigator: {\n            series: {\n              type: \"gantt\"\n            },\n            yAxis: {\n              type: \"category\"\n            }\n          }\n        }, b, {\n          isGantt: !0\n        });\n        b.xAxis = m;\n        b.yAxis = f;\n        p.xAxis = (D(b.xAxis) ? b.xAxis : [b.xAxis || {}, {}]).map(function (b, c) {\n          1 === c && (d = 0);\n          return F(k.xAxis, {\n            grid: {\n              enabled: !0\n            },\n            opposite: !0,\n            linkedTo: d\n          }, b, {\n            type: \"datetime\"\n          });\n        });\n        p.yAxis = y(b.yAxis || {}).map(function (b) {\n          return F(k.yAxis, {\n            grid: {\n              enabled: !0\n            },\n            staticScale: 50,\n            reversed: !0,\n            type: b.categories ? b.type : \"treegrid\"\n          }, b);\n        });\n        c.prototype.init.call(this, p, h);\n      };\n\n      return h;\n    }(c);\n\n    (function (c) {\n      c.ganttChart = function (h, b, k) {\n        return new c(h, b, k);\n      };\n    })(c || (c = {}));\n\n    return c;\n  });\n  O(h, \"Core/Axis/ScrollbarAxis.js\", [h[\"Core/Utilities.js\"]], function (c) {\n    var h = c.addEvent,\n        B = c.defined,\n        E = c.pick;\n    return function () {\n      function c() {}\n\n      c.compose = function (A, F) {\n        if (-1 === c.composed.indexOf(A)) c.composed.push(A);else return A;\n\n        var y = function (c) {\n          var h = E(c.options && c.options.min, c.min),\n              b = E(c.options && c.options.max, c.max);\n          return {\n            axisMin: h,\n            axisMax: b,\n            scrollMin: B(c.dataMin) ? Math.min(h, c.min, c.dataMin, E(c.threshold, Infinity)) : h,\n            scrollMax: B(c.dataMax) ? Math.max(b, c.max, c.dataMax, E(c.threshold, -Infinity)) : b\n          };\n        };\n\n        h(A, \"afterInit\", function () {\n          var c = this;\n          c.options && c.options.scrollbar && c.options.scrollbar.enabled && (c.options.scrollbar.vertical = !c.horiz, c.options.startOnTick = c.options.endOnTick = !1, c.scrollbar = new F(c.chart.renderer, c.options.scrollbar, c.chart), h(c.scrollbar, \"changed\", function (h) {\n            var b = y(c),\n                k = b.axisMax,\n                n = b.scrollMin,\n                m = b.scrollMax - n;\n            B(b.axisMin) && B(k) && (c.horiz && !c.reversed || !c.horiz && c.reversed ? (b = n + m * this.to, n += m * this.from) : (b = n + m * (1 - this.from), n += m * (1 - this.to)), this.shouldUpdateExtremes(h.DOMType) ? c.setExtremes(n, b, !0, \"mousemove\" !== h.DOMType && \"touchmove\" !== h.DOMType, h) : this.setRange(this.from, this.to));\n          }));\n        });\n        h(A, \"afterRender\", function () {\n          var c = y(this),\n              h = c.scrollMin,\n              b = c.scrollMax;\n          c = this.scrollbar;\n          var k = this.axisTitleMargin + (this.titleOffset || 0),\n              n = this.chart.scrollbarsOffsets,\n              m = this.options.margin || 0;\n          c && (this.horiz ? (this.opposite || (n[1] += k), c.position(this.left, this.top + this.height + 2 + n[1] - (this.opposite ? m : 0), this.width, this.height), this.opposite || (n[1] += m), k = 1) : (this.opposite && (n[0] += k), c.position(c.options.opposite ? this.left + this.width + 2 + n[0] - (this.opposite ? 0 : m) : this.opposite ? 0 : m, this.top, this.width, this.height), this.opposite && (n[0] += m), k = 0), n[k] += c.size + c.options.margin, isNaN(h) || isNaN(b) || !B(this.min) || !B(this.max) || this.min === this.max ? c.setRange(0, 1) : (n = (this.min - h) / (b - h), h = (this.max - h) / (b - h), this.horiz && !this.reversed || !this.horiz && this.reversed ? c.setRange(n, h) : c.setRange(1 - h, 1 - n)));\n        });\n        h(A, \"afterGetOffset\", function () {\n          var c = this.scrollbar && !this.scrollbar.options.opposite;\n          c = this.horiz ? 2 : c ? 3 : 1;\n          var h = this.scrollbar;\n          h && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[c] += h.size + h.options.margin);\n        });\n        return A;\n      };\n\n      c.composed = [];\n      return c;\n    }();\n  });\n  O(h, \"Core/ScrollbarDefaults.js\", [h[\"Core/Globals.js\"]], function (c) {\n    return {\n      height: c.isTouchDevice ? 20 : 14,\n      barBorderRadius: 0,\n      buttonBorderRadius: 0,\n      liveRedraw: void 0,\n      margin: 10,\n      minWidth: 6,\n      opposite: !0,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: \"#cccccc\",\n      barBorderWidth: 1,\n      barBorderColor: \"#cccccc\",\n      buttonArrowColor: \"#333333\",\n      buttonBackgroundColor: \"#e6e6e6\",\n      buttonBorderColor: \"#cccccc\",\n      buttonBorderWidth: 1,\n      rifleColor: \"#333333\",\n      trackBackgroundColor: \"#f2f2f2\",\n      trackBorderColor: \"#f2f2f2\",\n      trackBorderWidth: 1\n    };\n  });\n  O(h, \"Core/Scrollbar.js\", [h[\"Core/DefaultOptions.js\"], h[\"Core/Globals.js\"], h[\"Core/Axis/ScrollbarAxis.js\"], h[\"Core/ScrollbarDefaults.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A) {\n    var D = c.defaultOptions,\n        F = A.addEvent,\n        y = A.correctFloat,\n        p = A.defined,\n        t = A.destroyObjectProperties,\n        b = A.fireEvent,\n        k = A.merge,\n        n = A.pick,\n        m = A.removeEvent;\n\n    c = function () {\n      function c(b, c, f) {\n        this._events = [];\n        this.chart = void 0;\n        this.from = this.chartY = this.chartX = 0;\n        this.scrollbar = this.renderer = this.options = this.group = void 0;\n        this.scrollbarButtons = [];\n        this.scrollbarGroup = void 0;\n        this.scrollbarLeft = 0;\n        this.scrollbarRifles = void 0;\n        this.scrollbarStrokeWidth = 1;\n        this.to = this.size = this.scrollbarTop = 0;\n        this.track = void 0;\n        this.trackBorderWidth = 1;\n        this.userOptions = void 0;\n        this.y = this.x = 0;\n        this.init(b, c, f);\n      }\n\n      c.compose = function (b) {\n        B.compose(b, c);\n      };\n\n      c.swapXY = function (b, c) {\n        c && b.forEach(function (b) {\n          for (var c = b.length, d, f = 0; f < c; f += 2) d = b[f + 1], \"number\" === typeof d && (b[f + 1] = b[f + 2], b[f + 2] = d);\n        });\n        return b;\n      };\n\n      c.prototype.addEvents = function () {\n        var b = this.options.inverted ? [1, 0] : [0, 1],\n            c = this.scrollbarButtons,\n            f = this.scrollbarGroup.element,\n            k = this.track.element,\n            m = this.mouseDownHandler.bind(this),\n            n = this.mouseMoveHandler.bind(this),\n            p = this.mouseUpHandler.bind(this);\n        b = [[c[b[0]].element, \"click\", this.buttonToMinClick.bind(this)], [c[b[1]].element, \"click\", this.buttonToMaxClick.bind(this)], [k, \"click\", this.trackClick.bind(this)], [f, \"mousedown\", m], [f.ownerDocument, \"mousemove\", n], [f.ownerDocument, \"mouseup\", p]];\n        h.hasTouch && b.push([f, \"touchstart\", m], [f.ownerDocument, \"touchmove\", n], [f.ownerDocument, \"touchend\", p]);\n        b.forEach(function (b) {\n          F.apply(null, b);\n        });\n        this._events = b;\n      };\n\n      c.prototype.buttonToMaxClick = function (c) {\n        var d = (this.to - this.from) * n(this.options.step, .2);\n        this.updatePosition(this.from + d, this.to + d);\n        b(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: c\n        });\n      };\n\n      c.prototype.buttonToMinClick = function (c) {\n        var d = y(this.to - this.from) * n(this.options.step, .2);\n        this.updatePosition(y(this.from - d), y(this.to - d));\n        b(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: c\n        });\n      };\n\n      c.prototype.cursorToScrollbarPosition = function (b) {\n        var c = this.options;\n        c = c.minWidth > this.calculatedWidth ? c.minWidth : 0;\n        return {\n          chartX: (b.chartX - this.x - this.xOffset) / (this.barWidth - c),\n          chartY: (b.chartY - this.y - this.yOffset) / (this.barWidth - c)\n        };\n      };\n\n      c.prototype.destroy = function () {\n        var b = this,\n            c = b.chart.scroller;\n        b.removeEvents();\n        [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (c) {\n          b[c] && b[c].destroy && (b[c] = b[c].destroy());\n        });\n        c && b === c.scrollbar && (c.scrollbar = null, t(c.scrollbarButtons));\n      };\n\n      c.prototype.drawScrollbarButton = function (b) {\n        var d = this.renderer,\n            f = this.scrollbarButtons,\n            h = this.options,\n            k = this.size,\n            m = d.g().add(this.group);\n        f.push(m);\n        m = d.rect().addClass(\"highcharts-scrollbar-button\").add(m);\n        this.chart.styledMode || m.attr({\n          stroke: h.buttonBorderColor,\n          \"stroke-width\": h.buttonBorderWidth,\n          fill: h.buttonBackgroundColor\n        });\n        m.attr(m.crisp({\n          x: -.5,\n          y: -.5,\n          width: k + 1,\n          height: k + 1,\n          r: h.buttonBorderRadius\n        }, m.strokeWidth()));\n        m = d.path(c.swapXY([[\"M\", k / 2 + (b ? -1 : 1), k / 2 - 3], [\"L\", k / 2 + (b ? -1 : 1), k / 2 + 3], [\"L\", k / 2 + (b ? 2 : -2), k / 2]], h.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(f[b]);\n        this.chart.styledMode || m.attr({\n          fill: h.buttonArrowColor\n        });\n      };\n\n      c.prototype.init = function (b, c, f) {\n        this.scrollbarButtons = [];\n        this.renderer = b;\n        this.userOptions = c;\n        this.options = k(E, D.scrollbar, c);\n        this.chart = f;\n        this.size = n(this.options.size, this.options.height);\n        c.enabled && (this.render(), this.addEvents());\n      };\n\n      c.prototype.mouseDownHandler = function (b) {\n        b = this.chart.pointer.normalize(b);\n        b = this.cursorToScrollbarPosition(b);\n        this.chartX = b.chartX;\n        this.chartY = b.chartY;\n        this.initPositions = [this.from, this.to];\n        this.grabbedCenter = !0;\n      };\n\n      c.prototype.mouseMoveHandler = function (c) {\n        var d = this.chart.pointer.normalize(c),\n            f = this.options.vertical ? \"chartY\" : \"chartX\",\n            h = this.initPositions || [];\n        !this.grabbedCenter || c.touches && 0 === c.touches[0][f] || (d = this.cursorToScrollbarPosition(d)[f], f = this[f], f = d - f, this.hasDragged = !0, this.updatePosition(h[0] + f, h[1] + f), this.hasDragged && b(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMType: c.type,\n          DOMEvent: c\n        }));\n      };\n\n      c.prototype.mouseUpHandler = function (c) {\n        this.hasDragged && b(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMType: c.type,\n          DOMEvent: c\n        });\n        this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;\n      };\n\n      c.prototype.position = function (b, c, f, h) {\n        var d = this.options.vertical,\n            k = this.rendered ? \"animate\" : \"attr\",\n            m = h,\n            n = 0;\n        this.group.show();\n        this.x = b;\n        this.y = c + this.trackBorderWidth;\n        this.width = f;\n        this.height = h;\n        this.xOffset = m;\n        this.yOffset = n;\n        d ? (this.width = this.yOffset = f = n = this.size, this.xOffset = m = 0, this.barWidth = h - 2 * f, this.x = b += this.options.margin) : (this.height = this.xOffset = h = m = this.size, this.barWidth = f - 2 * h, this.y += this.options.margin);\n        this.group[k]({\n          translateX: b,\n          translateY: this.y\n        });\n        this.track[k]({\n          width: f,\n          height: h\n        });\n        this.scrollbarButtons[1][k]({\n          translateX: d ? 0 : f - m,\n          translateY: d ? h - n : 0\n        });\n      };\n\n      c.prototype.removeEvents = function () {\n        this._events.forEach(function (b) {\n          m.apply(null, b);\n        });\n\n        this._events.length = 0;\n      };\n\n      c.prototype.render = function () {\n        var b = this.renderer,\n            f = this.options,\n            h = this.size,\n            k = this.chart.styledMode,\n            m = b.g(\"scrollbar\").attr({\n          zIndex: f.zIndex\n        }).hide().add();\n        this.group = m;\n        this.track = b.rect().addClass(\"highcharts-scrollbar-track\").attr({\n          x: 0,\n          r: f.trackBorderRadius || 0,\n          height: h,\n          width: h\n        }).add(m);\n        k || this.track.attr({\n          fill: f.trackBackgroundColor,\n          stroke: f.trackBorderColor,\n          \"stroke-width\": f.trackBorderWidth\n        });\n        this.trackBorderWidth = this.track.strokeWidth();\n        this.track.attr({\n          y: -this.trackBorderWidth % 2 / 2\n        });\n        this.scrollbarGroup = b.g().add(m);\n        this.scrollbar = b.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n          height: h,\n          width: h,\n          r: f.barBorderRadius || 0\n        }).add(this.scrollbarGroup);\n        this.scrollbarRifles = b.path(c.swapXY([[\"M\", -3, h / 4], [\"L\", -3, 2 * h / 3], [\"M\", 0, h / 4], [\"L\", 0, 2 * h / 3], [\"M\", 3, h / 4], [\"L\", 3, 2 * h / 3]], f.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup);\n        k || (this.scrollbar.attr({\n          fill: f.barBackgroundColor,\n          stroke: f.barBorderColor,\n          \"stroke-width\": f.barBorderWidth\n        }), this.scrollbarRifles.attr({\n          stroke: f.rifleColor,\n          \"stroke-width\": 1\n        }));\n        this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();\n        this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);\n        this.drawScrollbarButton(0);\n        this.drawScrollbarButton(1);\n      };\n\n      c.prototype.setRange = function (b, c) {\n        var d = this.options,\n            f = d.vertical,\n            h = d.minWidth,\n            k = this.barWidth,\n            m = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n\n        if (p(k)) {\n          var n = k * Math.min(c, 1);\n          b = Math.max(b, 0);\n          var a = Math.ceil(k * b);\n          this.calculatedWidth = n = y(n - a);\n          n < h && (a = (k - h + n) * b, n = h);\n          h = Math.floor(a + this.xOffset + this.yOffset);\n          k = n / 2 - .5;\n          this.from = b;\n          this.to = c;\n          f ? (this.scrollbarGroup[m]({\n            translateY: h\n          }), this.scrollbar[m]({\n            height: n\n          }), this.scrollbarRifles[m]({\n            translateY: k\n          }), this.scrollbarTop = h, this.scrollbarLeft = 0) : (this.scrollbarGroup[m]({\n            translateX: h\n          }), this.scrollbar[m]({\n            width: n\n          }), this.scrollbarRifles[m]({\n            translateX: k\n          }), this.scrollbarLeft = h, this.scrollbarTop = 0);\n          12 >= n ? this.scrollbarRifles.hide() : this.scrollbarRifles.show();\n          !1 === d.showFull && (0 >= b && 1 <= c ? this.group.hide() : this.group.show());\n          this.rendered = !0;\n        }\n      };\n\n      c.prototype.shouldUpdateExtremes = function (b) {\n        return n(this.options.liveRedraw, h.svg && !h.isTouchDevice && !this.chart.boosted) || \"mouseup\" === b || \"touchend\" === b || !p(b);\n      };\n\n      c.prototype.trackClick = function (c) {\n        var d = this.chart.pointer.normalize(c),\n            f = this.to - this.from,\n            h = this.y + this.scrollbarTop,\n            k = this.x + this.scrollbarLeft;\n        this.options.vertical && d.chartY > h || !this.options.vertical && d.chartX > k ? this.updatePosition(this.from + f, this.to + f) : this.updatePosition(this.from - f, this.to - f);\n        b(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: c\n        });\n      };\n\n      c.prototype.update = function (b) {\n        this.destroy();\n        this.init(this.chart.renderer, k(!0, this.options, b), this.chart);\n      };\n\n      c.prototype.updatePosition = function (b, c) {\n        1 < c && (b = y(1 - y(c - b)), c = 1);\n        0 > b && (c = y(c - b), b = 0);\n        this.from = b;\n        this.to = c;\n      };\n\n      c.defaultOptions = E;\n      return c;\n    }();\n\n    D.scrollbar = k(!0, c.defaultOptions, D.scrollbar);\n    return c;\n  });\n  O(h, \"Extensions/RangeSelector.js\", [h[\"Core/Axis/Axis.js\"], h[\"Core/Chart/Chart.js\"], h[\"Core/Globals.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Renderer/SVG/SVGElement.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A, D) {\n    function F(a) {\n      if (-1 !== a.indexOf(\"%L\")) return \"text\";\n      var b = \"aAdewbBmoyY\".split(\"\").some(function (b) {\n        return -1 !== a.indexOf(\"%\" + b);\n      }),\n          c = \"HkIlMS\".split(\"\").some(function (b) {\n        return -1 !== a.indexOf(\"%\" + b);\n      });\n      return b && c ? \"datetime-local\" : b ? \"date\" : c ? \"time\" : \"text\";\n    }\n\n    var y = E.defaultOptions,\n        p = D.addEvent,\n        t = D.createElement,\n        b = D.css,\n        k = D.defined,\n        n = D.destroyObjectProperties,\n        m = D.discardElement,\n        f = D.extend,\n        d = D.find,\n        v = D.fireEvent,\n        I = D.isNumber,\n        M = D.merge,\n        N = D.objectEach,\n        H = D.pad,\n        q = D.pick,\n        w = D.pInt,\n        a = D.splat;\n    f(y, {\n      rangeSelector: {\n        allButtonsEnabled: !1,\n        buttons: void 0,\n        buttonSpacing: 5,\n        dropdown: \"responsive\",\n        enabled: void 0,\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputBoxBorderColor: \"none\",\n        inputBoxHeight: 17,\n        inputBoxWidth: void 0,\n        inputDateFormat: \"%b %e, %Y\",\n        inputDateParser: void 0,\n        inputEditDateFormat: \"%Y-%m-%d\",\n        inputEnabled: !0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        inputSpacing: 5,\n        selected: void 0,\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        inputStyle: {\n          color: \"#335cad\",\n          cursor: \"pointer\"\n        },\n        labelStyle: {\n          color: \"#666666\"\n        }\n      }\n    });\n    f(y.lang, {\n      rangeSelectorZoom: \"Zoom\",\n      rangeSelectorFrom: \"\",\n      rangeSelectorTo: \"\\u2192\"\n    });\n\n    var x = function () {\n      function d(a) {\n        this.buttons = void 0;\n        this.buttonOptions = d.prototype.defaultButtons;\n        this.initialButtonGroupWidth = 0;\n        this.options = void 0;\n        this.chart = a;\n        this.init(a);\n      }\n\n      d.prototype.clickButton = function (b, d) {\n        var e = this.chart,\n            f = this.buttonOptions[b],\n            g = e.xAxis[0],\n            h = e.scroller && e.scroller.getUnionExtremes() || g || {},\n            l = h.dataMin,\n            m = h.dataMax,\n            n = g && Math.round(Math.min(g.max, q(m, g.max))),\n            t = f.type;\n        h = f._range;\n        var u,\n            w = f.dataGrouping;\n        var x = !0;\n\n        if (null !== l && null !== m) {\n          e.fixedRange = h;\n          this.setSelected(b);\n          w && (this.forcedDataGrouping = !0, c.prototype.setDataGrouping.call(g || {\n            chart: this.chart\n          }, w, !1), this.frozenStates = f.preserveDataGrouping);\n          if (\"month\" === t || \"year\" === t) {\n            if (g) {\n              x = {\n                range: f,\n                max: n,\n                chart: e,\n                dataMin: l,\n                dataMax: m\n              };\n              var y = g.minFromRange.call(x);\n              I(x.newMax) && (n = x.newMax);\n              x = !1;\n            } else h = f;\n          } else if (h) y = Math.max(n - h, l), n = Math.min(y + h, m), x = !1;else if (\"ytd\" === t) {\n            if (g) {\n              if (\"undefined\" === typeof m || \"undefined\" === typeof l) l = Number.MAX_VALUE, m = Number.MIN_VALUE, e.series.forEach(function (a) {\n                if (a = a.xData) l = Math.min(a[0], l), m = Math.max(a[a.length - 1], m);\n              }), d = !1;\n              n = this.getYTDExtremes(m, l, e.time.useUTC);\n              y = u = n.min;\n              n = n.max;\n            } else {\n              this.deferredYTDClick = b;\n              return;\n            }\n          } else \"all\" === t && g && (e.navigator && e.navigator.baseSeries[0] && (e.navigator.baseSeries[0].xAxis.options.range = void 0), y = l, n = m);\n          x && f._offsetMin && k(y) && (y += f._offsetMin);\n          f._offsetMax && k(n) && (n += f._offsetMax);\n          this.dropdown && (this.dropdown.selectedIndex = b + 1);\n          if (g) g.setExtremes(y, n, q(d, !0), void 0, {\n            trigger: \"rangeSelectorButton\",\n            rangeSelectorButton: f\n          });else {\n            var A = a(e.options.xAxis)[0];\n            var G = A.range;\n            A.range = h;\n            var B = A.min;\n            A.min = u;\n            p(e, \"load\", function () {\n              A.range = G;\n              A.min = B;\n            });\n          }\n          v(this, \"afterBtnClick\");\n        }\n      };\n\n      d.prototype.setSelected = function (a) {\n        this.selected = this.options.selected = a;\n      };\n\n      d.prototype.init = function (a) {\n        var b = this,\n            c = a.options.rangeSelector,\n            d = c.buttons || b.defaultButtons.slice(),\n            e = c.selected,\n            f = function () {\n          var a = b.minInput,\n              c = b.maxInput;\n          a && a.blur && v(a, \"blur\");\n          c && c.blur && v(c, \"blur\");\n        };\n\n        b.chart = a;\n        b.options = c;\n        b.buttons = [];\n        b.buttonOptions = d;\n        this.eventsToUnbind = [];\n        this.eventsToUnbind.push(p(a.container, \"mousedown\", f));\n        this.eventsToUnbind.push(p(a, \"resize\", f));\n        d.forEach(b.computeButtonRange);\n        \"undefined\" !== typeof e && d[e] && this.clickButton(e, !1);\n        this.eventsToUnbind.push(p(a, \"load\", function () {\n          a.xAxis && a.xAxis[0] && p(a.xAxis[0], \"setExtremes\", function (c) {\n            this.max - this.min !== a.fixedRange && \"rangeSelectorButton\" !== c.trigger && \"updatedData\" !== c.trigger && b.forcedDataGrouping && !b.frozenStates && this.setDataGrouping(!1, !1);\n          });\n        }));\n      };\n\n      d.prototype.updateButtonStates = function () {\n        var a = this,\n            b = this.chart,\n            c = this.dropdown,\n            d = b.xAxis[0],\n            e = Math.round(d.max - d.min),\n            f = !d.hasVisibleSeries,\n            h = b.scroller && b.scroller.getUnionExtremes() || d,\n            k = h.dataMin,\n            l = h.dataMax;\n        b = a.getYTDExtremes(l, k, b.time.useUTC);\n        var m = b.min,\n            n = b.max,\n            p = a.selected,\n            q = I(p),\n            t = a.options.allButtonsEnabled,\n            u = a.buttons;\n        a.buttonOptions.forEach(function (b, g) {\n          var h = b._range,\n              r = b.type,\n              z = b.count || 1,\n              v = u[g],\n              w = 0,\n              x = b._offsetMax - b._offsetMin;\n          b = g === p;\n          var L = h > l - k,\n              C = h < d.minRange,\n              y = !1,\n              A = !1;\n          h = h === e;\n          (\"month\" === r || \"year\" === r) && e + 36E5 >= 864E5 * {\n            month: 28,\n            year: 365\n          }[r] * z - x && e - 36E5 <= 864E5 * {\n            month: 31,\n            year: 366\n          }[r] * z + x ? h = !0 : \"ytd\" === r ? (h = n - m + x === e, y = !b) : \"all\" === r && (h = d.max - d.min >= l - k, A = !b && q && h);\n          r = !t && (L || C || A || f);\n          z = b && h || h && !q && !y || b && a.frozenStates;\n          r ? w = 3 : z && (q = !0, w = 2);\n          v.state !== w && (v.setState(w), c && (c.options[g + 1].disabled = r, 2 === w && (c.selectedIndex = g + 1)), 0 === w && p === g && a.setSelected());\n        });\n      };\n\n      d.prototype.computeButtonRange = function (a) {\n        var b = a.type,\n            c = a.count || 1,\n            d = {\n          millisecond: 1,\n          second: 1E3,\n          minute: 6E4,\n          hour: 36E5,\n          day: 864E5,\n          week: 6048E5\n        };\n        if (d[b]) a._range = d[b] * c;else if (\"month\" === b || \"year\" === b) a._range = 864E5 * {\n          month: 30,\n          year: 365\n        }[b] * c;\n        a._offsetMin = q(a.offsetMin, 0);\n        a._offsetMax = q(a.offsetMax, 0);\n        a._range += a._offsetMax - a._offsetMin;\n      };\n\n      d.prototype.getInputValue = function (a) {\n        a = \"min\" === a ? this.minInput : this.maxInput;\n        var b = this.chart.options.rangeSelector,\n            c = this.chart.time;\n        return a ? (\"text\" === a.type && b.inputDateParser || this.defaultInputDateParser)(a.value, c.useUTC, c) : 0;\n      };\n\n      d.prototype.setInputValue = function (a, b) {\n        var c = this.options,\n            d = this.chart.time,\n            e = \"min\" === a ? this.minInput : this.maxInput;\n        a = \"min\" === a ? this.minDateBox : this.maxDateBox;\n\n        if (e) {\n          var f = e.getAttribute(\"data-hc-time\");\n          f = k(f) ? Number(f) : void 0;\n          k(b) && (k(f) && e.setAttribute(\"data-hc-time-previous\", f), e.setAttribute(\"data-hc-time\", b), f = b);\n          e.value = d.dateFormat(this.inputTypeFormats[e.type] || c.inputEditDateFormat, f);\n          a && a.attr({\n            text: d.dateFormat(c.inputDateFormat, f)\n          });\n        }\n      };\n\n      d.prototype.setInputExtremes = function (a, b, c) {\n        if (a = \"min\" === a ? this.minInput : this.maxInput) {\n          var d = this.inputTypeFormats[a.type],\n              e = this.chart.time;\n          d && (b = e.dateFormat(d, b), a.min !== b && (a.min = b), c = e.dateFormat(d, c), a.max !== c && (a.max = c));\n        }\n      };\n\n      d.prototype.showInput = function (a) {\n        var c = \"min\" === a ? this.minDateBox : this.maxDateBox;\n\n        if ((a = \"min\" === a ? this.minInput : this.maxInput) && c && this.inputGroup) {\n          var d = \"text\" === a.type,\n              e = this.inputGroup,\n              f = e.translateX;\n          e = e.translateY;\n          var g = this.options.inputBoxWidth;\n          b(a, {\n            width: d ? c.width + (g ? -2 : 20) + \"px\" : \"auto\",\n            height: d ? c.height - 2 + \"px\" : \"auto\",\n            border: \"2px solid silver\"\n          });\n          d && g ? b(a, {\n            left: f + c.x + \"px\",\n            top: e + \"px\"\n          }) : b(a, {\n            left: Math.min(Math.round(c.x + f - (a.offsetWidth - c.width) / 2), this.chart.chartWidth - a.offsetWidth) + \"px\",\n            top: e - (a.offsetHeight - c.height) / 2 + \"px\"\n          });\n        }\n      };\n\n      d.prototype.hideInput = function (a) {\n        (a = \"min\" === a ? this.minInput : this.maxInput) && b(a, {\n          top: \"-9999em\",\n          border: 0,\n          width: \"1px\",\n          height: \"1px\"\n        });\n      };\n\n      d.prototype.defaultInputDateParser = function (a, b, c) {\n        var d = a.split(\"/\").join(\"-\").split(\" \").join(\"T\");\n        -1 === d.indexOf(\"T\") && (d += \"T00:00\");\n        if (b) d += \"Z\";else {\n          var e;\n          if (e = B.isSafari) e = d, e = !(6 < e.length && (e.lastIndexOf(\"-\") === e.length - 6 || e.lastIndexOf(\"+\") === e.length - 6));\n          e && (e = new Date(d).getTimezoneOffset() / 60, d += 0 >= e ? \"+\".concat(H(-e), \":00\") : \"-\".concat(H(e), \":00\"));\n        }\n        d = Date.parse(d);\n        I(d) || (a = a.split(\"-\"), d = Date.UTC(w(a[0]), w(a[1]) - 1, w(a[2])));\n        c && b && I(d) && (d += c.getTimezoneOffset(d));\n        return d;\n      };\n\n      d.prototype.drawInput = function (a) {\n        function c() {\n          var b = h.getInputValue(a),\n              c = d.xAxis[0],\n              e = d.scroller && d.scroller.xAxis ? d.scroller.xAxis : c,\n              f = e.dataMin;\n          e = e.dataMax;\n          var g = h.maxInput,\n              k = h.minInput;\n          b !== Number(q.getAttribute(\"data-hc-time-previous\")) && I(b) && (q.setAttribute(\"data-hc-time-previous\", b), n && g && I(f) ? b > Number(g.getAttribute(\"data-hc-time\")) ? b = void 0 : b < f && (b = f) : k && I(e) && (b < Number(k.getAttribute(\"data-hc-time\")) ? b = void 0 : b > e && (b = e)), \"undefined\" !== typeof b && c.setExtremes(n ? b : c.min, n ? c.max : b, void 0, void 0, {\n            trigger: \"rangeSelectorInput\"\n          }));\n        }\n\n        var d = this.chart,\n            e = this.div,\n            g = this.inputGroup,\n            h = this,\n            k = d.renderer.style || {},\n            l = d.renderer,\n            m = d.options.rangeSelector,\n            n = \"min\" === a,\n            p = y.lang[n ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"] || \"\";\n        p = l.label(p, 0).addClass(\"highcharts-range-label\").attr({\n          padding: p ? 2 : 0,\n          height: p ? m.inputBoxHeight : 0\n        }).add(g);\n        l = l.label(\"\", 0).addClass(\"highcharts-range-input\").attr({\n          padding: 2,\n          width: m.inputBoxWidth,\n          height: m.inputBoxHeight,\n          \"text-align\": \"center\"\n        }).on(\"click\", function () {\n          h.showInput(a);\n          h[a + \"Input\"].focus();\n        });\n        d.styledMode || l.attr({\n          stroke: m.inputBoxBorderColor,\n          \"stroke-width\": 1\n        });\n        l.add(g);\n        var q = t(\"input\", {\n          name: a,\n          className: \"highcharts-range-selector\"\n        }, void 0, e);\n        q.setAttribute(\"type\", F(m.inputDateFormat || \"%b %e, %Y\"));\n        d.styledMode || (p.css(M(k, m.labelStyle)), l.css(M({\n          color: \"#333333\"\n        }, k, m.inputStyle)), b(q, f({\n          position: \"absolute\",\n          border: 0,\n          boxShadow: \"0 0 15px rgba(0,0,0,0.3)\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          textAlign: \"center\",\n          fontSize: k.fontSize,\n          fontFamily: k.fontFamily,\n          top: \"-9999em\"\n        }, m.inputStyle)));\n\n        q.onfocus = function () {\n          h.showInput(a);\n        };\n\n        q.onblur = function () {\n          q === B.doc.activeElement && c();\n          h.hideInput(a);\n          h.setInputValue(a);\n          q.blur();\n        };\n\n        var u = !1;\n\n        q.onchange = function () {\n          u || (c(), h.hideInput(a), q.blur());\n        };\n\n        q.onkeypress = function (a) {\n          13 === a.keyCode && c();\n        };\n\n        q.onkeydown = function (a) {\n          u = !0;\n          38 !== a.keyCode && 40 !== a.keyCode || c();\n        };\n\n        q.onkeyup = function () {\n          u = !1;\n        };\n\n        return {\n          dateBox: l,\n          input: q,\n          label: p\n        };\n      };\n\n      d.prototype.getPosition = function () {\n        var a = this.chart,\n            b = a.options.rangeSelector;\n        a = \"top\" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;\n        return {\n          buttonTop: a + b.buttonPosition.y,\n          inputTop: a + b.inputPosition.y - 10\n        };\n      };\n\n      d.prototype.getYTDExtremes = function (a, b, c) {\n        var d = this.chart.time,\n            e = new d.Date(a),\n            f = d.get(\"FullYear\", e);\n        c = c ? d.Date.UTC(f, 0, 1) : +new d.Date(f, 0, 1);\n        b = Math.max(b, c);\n        e = e.getTime();\n        return {\n          max: Math.min(a || e, e),\n          min: b\n        };\n      };\n\n      d.prototype.render = function (a, b) {\n        var c = this.chart,\n            d = c.renderer,\n            e = c.container,\n            f = c.options,\n            g = f.rangeSelector,\n            h = q(f.chart.style && f.chart.style.zIndex, 0) + 1;\n        f = g.inputEnabled;\n\n        if (!1 !== g.enabled) {\n          this.rendered || (this.group = d.g(\"range-selector-group\").attr({\n            zIndex: 7\n          }).add(), this.div = t(\"div\", void 0, {\n            position: \"relative\",\n            height: 0,\n            zIndex: h\n          }), this.buttonOptions.length && this.renderButtons(), e.parentNode && e.parentNode.insertBefore(this.div, e), f && (this.inputGroup = d.g(\"input-group\").add(this.group), d = this.drawInput(\"min\"), this.minDateBox = d.dateBox, this.minLabel = d.label, this.minInput = d.input, d = this.drawInput(\"max\"), this.maxDateBox = d.dateBox, this.maxLabel = d.label, this.maxInput = d.input));\n\n          if (f && (this.setInputValue(\"min\", a), this.setInputValue(\"max\", b), a = c.scroller && c.scroller.getUnionExtremes() || c.xAxis[0] || {}, k(a.dataMin) && k(a.dataMax) && (c = c.xAxis[0].minRange || 0, this.setInputExtremes(\"min\", a.dataMin, Math.min(a.dataMax, this.getInputValue(\"max\")) - c), this.setInputExtremes(\"max\", Math.max(a.dataMin, this.getInputValue(\"min\")) + c, a.dataMax)), this.inputGroup)) {\n            var l = 0;\n            [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (a) {\n              if (a) {\n                var b = a.getBBox().width;\n                b && (a.attr({\n                  x: l\n                }), l += b + g.inputSpacing);\n              }\n            });\n          }\n\n          this.alignElements();\n          this.rendered = !0;\n        }\n      };\n\n      d.prototype.renderButtons = function () {\n        var a = this,\n            b = this.buttons,\n            c = this.options,\n            d = y.lang,\n            e = this.chart.renderer,\n            f = M(c.buttonTheme),\n            h = f && f.states,\n            k = f.width || 28;\n        delete f.width;\n        delete f.states;\n        this.buttonGroup = e.g(\"range-selector-buttons\").add(this.group);\n        var l = this.dropdown = t(\"select\", void 0, {\n          position: \"absolute\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          border: 0,\n          top: \"-9999em\",\n          cursor: \"pointer\",\n          opacity: .0001\n        }, this.div);\n        p(l, \"touchstart\", function () {\n          l.style.fontSize = \"16px\";\n        });\n        [[B.isMS ? \"mouseover\" : \"mouseenter\"], [B.isMS ? \"mouseout\" : \"mouseleave\"], [\"change\", \"click\"]].forEach(function (c) {\n          var d = c[0],\n              e = c[1];\n          p(l, d, function () {\n            var c = b[a.currentButtonIndex()];\n            c && v(c.element, e || d);\n          });\n        });\n        this.zoomText = e.label(d && d.rangeSelectorZoom || \"\", 0).attr({\n          padding: c.buttonTheme.padding,\n          height: c.buttonTheme.height,\n          paddingLeft: 0,\n          paddingRight: 0\n        }).add(this.buttonGroup);\n        this.chart.styledMode || (this.zoomText.css(c.labelStyle), f[\"stroke-width\"] = q(f[\"stroke-width\"], 0));\n        t(\"option\", {\n          textContent: this.zoomText.textStr,\n          disabled: !0\n        }, void 0, l);\n        this.buttonOptions.forEach(function (c, d) {\n          t(\"option\", {\n            textContent: c.title || c.text\n          }, void 0, l);\n          b[d] = e.button(c.text, 0, 0, function (b) {\n            var e = c.events && c.events.click,\n                f;\n            e && (f = e.call(c, b));\n            !1 !== f && a.clickButton(d);\n            a.isActive = !0;\n          }, f, h && h.hover, h && h.select, h && h.disabled).attr({\n            \"text-align\": \"center\",\n            width: k\n          }).add(a.buttonGroup);\n          c.title && b[d].attr(\"title\", c.title);\n        });\n      };\n\n      d.prototype.alignElements = function () {\n        var a = this,\n            b = this.buttonGroup,\n            c = this.buttons,\n            d = this.chart,\n            e = this.group,\n            f = this.inputGroup,\n            h = this.options,\n            k = this.zoomText,\n            l = d.options,\n            m = l.exporting && !1 !== l.exporting.enabled && l.navigation && l.navigation.buttonOptions;\n        l = h.buttonPosition;\n\n        var n = h.inputPosition,\n            p = h.verticalAlign,\n            t = function (b, c) {\n          return m && a.titleCollision(d) && \"top\" === p && \"right\" === c.align && c.y - b.getBBox().height - 12 < (m.y || 0) + (m.height || 0) + d.spacing[0] ? -40 : 0;\n        },\n            u = d.plotLeft;\n\n        if (e && l && n) {\n          var v = l.x - d.spacing[3];\n\n          if (b) {\n            this.positionButtons();\n\n            if (!this.initialButtonGroupWidth) {\n              var w = 0;\n              k && (w += k.getBBox().width + 5);\n              c.forEach(function (a, b) {\n                w += a.width;\n                b !== c.length - 1 && (w += h.buttonSpacing);\n              });\n              this.initialButtonGroupWidth = w;\n            }\n\n            u -= d.spacing[3];\n            this.updateButtonStates();\n            k = t(b, l);\n            this.alignButtonGroup(k);\n            e.placed = b.placed = d.hasLoaded;\n          }\n\n          b = 0;\n          f && (b = t(f, n), \"left\" === n.align ? v = u : \"right\" === n.align && (v = -Math.max(d.axisOffset[1], -b)), f.align({\n            y: n.y,\n            width: f.getBBox().width,\n            align: n.align,\n            x: n.x + v - 2\n          }, !0, d.spacingBox), f.placed = d.hasLoaded);\n          this.handleCollision(b);\n          e.align({\n            verticalAlign: p\n          }, !0, d.spacingBox);\n          f = e.alignAttr.translateY;\n          b = e.getBBox().height + 20;\n          t = 0;\n          \"bottom\" === p && (t = (t = d.legend && d.legend.options) && \"bottom\" === t.verticalAlign && t.enabled && !t.floating ? d.legend.legendHeight + q(t.margin, 10) : 0, b = b + t - 20, t = f - b - (h.floating ? 0 : h.y) - (d.titleOffset ? d.titleOffset[2] : 0) - 10);\n          if (\"top\" === p) h.floating && (t = 0), d.titleOffset && d.titleOffset[0] && (t = d.titleOffset[0]), t += d.margin[0] - d.spacing[0] || 0;else if (\"middle\" === p) if (n.y === l.y) t = f;else if (n.y || l.y) t = 0 > n.y || 0 > l.y ? t - Math.min(n.y, l.y) : f - b;\n          e.translate(h.x, h.y + Math.floor(t));\n          l = this.minInput;\n          n = this.maxInput;\n          f = this.dropdown;\n          h.inputEnabled && l && n && (l.style.marginTop = e.translateY + \"px\", n.style.marginTop = e.translateY + \"px\");\n          f && (f.style.marginTop = e.translateY + \"px\");\n        }\n      };\n\n      d.prototype.alignButtonGroup = function (a, b) {\n        var c = this.chart,\n            d = this.buttonGroup,\n            e = this.options.buttonPosition,\n            f = c.plotLeft - c.spacing[3],\n            g = e.x - c.spacing[3];\n        \"right\" === e.align ? g += a - f : \"center\" === e.align && (g -= f / 2);\n        d && d.align({\n          y: e.y,\n          width: q(b, this.initialButtonGroupWidth),\n          align: e.align,\n          x: g\n        }, !0, c.spacingBox);\n      };\n\n      d.prototype.positionButtons = function () {\n        var a = this.buttons,\n            b = this.chart,\n            c = this.options,\n            d = this.zoomText,\n            e = b.hasLoaded ? \"animate\" : \"attr\",\n            f = c.buttonPosition,\n            h = b.plotLeft,\n            k = h;\n        d && \"hidden\" !== d.visibility && (d[e]({\n          x: q(h + f.x, h)\n        }), k += f.x + d.getBBox().width + 5);\n        this.buttonOptions.forEach(function (b, d) {\n          if (\"hidden\" !== a[d].visibility) a[d][e]({\n            x: k\n          }), k += a[d].width + c.buttonSpacing;else a[d][e]({\n            x: h\n          });\n        });\n      };\n\n      d.prototype.handleCollision = function (a) {\n        var b = this,\n            c = this.chart,\n            d = this.buttonGroup,\n            e = this.inputGroup,\n            f = this.options,\n            g = f.buttonPosition,\n            h = f.dropdown,\n            k = f.inputPosition;\n\n        f = function () {\n          var a = 0;\n          b.buttons.forEach(function (b) {\n            b = b.getBBox();\n            b.width > a && (a = b.width);\n          });\n          return a;\n        };\n\n        var l = function (b) {\n          if (e && d) {\n            var c = e.alignAttr.translateX + e.alignOptions.x - a + e.getBBox().x + 2,\n                f = e.alignOptions.width,\n                h = d.alignAttr.translateX + d.getBBox().x;\n            return h + b > c && c + f > h && g.y < k.y + e.getBBox().height;\n          }\n\n          return !1;\n        },\n            m = function () {\n          e && d && e.attr({\n            translateX: e.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),\n            translateY: e.alignAttr.translateY + d.getBBox().height + 10\n          });\n        };\n\n        if (d) {\n          if (\"always\" === h) {\n            this.collapseButtons(a);\n            l(f()) && m();\n            return;\n          }\n\n          \"never\" === h && this.expandButtons();\n        }\n\n        e && d ? k.align === g.align || l(this.initialButtonGroupWidth + 20) ? \"responsive\" === h ? (this.collapseButtons(a), l(f()) && m()) : m() : \"responsive\" === h && this.expandButtons() : d && \"responsive\" === h && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());\n      };\n\n      d.prototype.collapseButtons = function (a) {\n        var b = this.buttons,\n            c = this.buttonOptions,\n            d = this.chart,\n            e = this.dropdown,\n            f = this.options,\n            g = this.zoomText,\n            h = d.userOptions.rangeSelector && d.userOptions.rangeSelector.buttonTheme || {},\n            k = function (a) {\n          return {\n            text: a ? \"\" + a + \" \\u25be\" : \"\\u25be\",\n            width: \"auto\",\n            paddingLeft: q(f.buttonTheme.paddingLeft, h.padding, 8),\n            paddingRight: q(f.buttonTheme.paddingRight, h.padding, 8)\n          };\n        };\n\n        g && g.hide();\n        var l = !1;\n        c.forEach(function (a, c) {\n          c = b[c];\n          2 !== c.state ? c.hide() : (c.show(), c.attr(k(a.text)), l = !0);\n        });\n        l || (e && (e.selectedIndex = 0), b[0].show(), b[0].attr(k(this.zoomText && this.zoomText.textStr)));\n        c = f.buttonPosition.align;\n        this.positionButtons();\n        \"right\" !== c && \"center\" !== c || this.alignButtonGroup(a, b[this.currentButtonIndex()].getBBox().width);\n        this.showDropdown();\n      };\n\n      d.prototype.expandButtons = function () {\n        var a = this.buttons,\n            b = this.buttonOptions,\n            c = this.options,\n            d = this.zoomText;\n        this.hideDropdown();\n        d && d.show();\n        b.forEach(function (b, d) {\n          d = a[d];\n          d.show();\n          d.attr({\n            text: b.text,\n            width: c.buttonTheme.width || 28,\n            paddingLeft: q(c.buttonTheme.paddingLeft, \"unset\"),\n            paddingRight: q(c.buttonTheme.paddingRight, \"unset\")\n          });\n          2 > d.state && d.setState(0);\n        });\n        this.positionButtons();\n      };\n\n      d.prototype.currentButtonIndex = function () {\n        var a = this.dropdown;\n        return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;\n      };\n\n      d.prototype.showDropdown = function () {\n        var a = this.buttonGroup,\n            c = this.buttons,\n            d = this.chart,\n            e = this.dropdown;\n\n        if (a && e) {\n          var f = a.translateX;\n          a = a.translateY;\n          c = c[this.currentButtonIndex()].getBBox();\n          b(e, {\n            left: d.plotLeft + f + \"px\",\n            top: a + .5 + \"px\",\n            width: c.width + \"px\",\n            height: c.height + \"px\"\n          });\n          this.hasVisibleDropdown = !0;\n        }\n      };\n\n      d.prototype.hideDropdown = function () {\n        var a = this.dropdown;\n        a && (b(a, {\n          top: \"-9999em\",\n          width: \"1px\",\n          height: \"1px\"\n        }), this.hasVisibleDropdown = !1);\n      };\n\n      d.prototype.getHeight = function () {\n        var a = this.options,\n            b = this.group,\n            c = a.y,\n            d = a.buttonPosition.y,\n            e = a.inputPosition.y;\n        if (a.height) return a.height;\n        this.alignElements();\n        a = b ? b.getBBox(!0).height + 13 + c : 0;\n        b = Math.min(e, d);\n        if (0 > e && 0 > d || 0 < e && 0 < d) a += Math.abs(b);\n        return a;\n      };\n\n      d.prototype.titleCollision = function (a) {\n        return !(a.options.title.text || a.options.subtitle.text);\n      };\n\n      d.prototype.update = function (a) {\n        var b = this.chart;\n        M(!0, b.options.rangeSelector, a);\n        this.destroy();\n        this.init(b);\n        this.render();\n      };\n\n      d.prototype.destroy = function () {\n        var a = this,\n            b = a.minInput,\n            c = a.maxInput;\n        a.eventsToUnbind && (a.eventsToUnbind.forEach(function (a) {\n          return a();\n        }), a.eventsToUnbind = void 0);\n        n(a.buttons);\n        b && (b.onfocus = b.onblur = b.onchange = null);\n        c && (c.onfocus = c.onblur = c.onchange = null);\n        N(a, function (b, c) {\n          b && \"chart\" !== c && (b instanceof A ? b.destroy() : b instanceof U.HTMLElement && m(b));\n          b !== d.prototype[c] && (a[c] = null);\n        }, this);\n      };\n\n      return d;\n    }();\n\n    x.prototype.defaultButtons = [{\n      type: \"month\",\n      count: 1,\n      text: \"1m\",\n      title: \"View 1 month\"\n    }, {\n      type: \"month\",\n      count: 3,\n      text: \"3m\",\n      title: \"View 3 months\"\n    }, {\n      type: \"month\",\n      count: 6,\n      text: \"6m\",\n      title: \"View 6 months\"\n    }, {\n      type: \"ytd\",\n      text: \"YTD\",\n      title: \"View year to date\"\n    }, {\n      type: \"year\",\n      count: 1,\n      text: \"1y\",\n      title: \"View 1 year\"\n    }, {\n      type: \"all\",\n      text: \"All\",\n      title: \"View all\"\n    }];\n    x.prototype.inputTypeFormats = {\n      \"datetime-local\": \"%Y-%m-%dT%H:%M:%S\",\n      date: \"%Y-%m-%d\",\n      time: \"%H:%M:%S\"\n    };\n\n    c.prototype.minFromRange = function () {\n      var a = this.range,\n          b = a.type,\n          c = this.max,\n          d = this.chart.time,\n          e = function (a, c) {\n        var e = \"year\" === b ? \"FullYear\" : \"Month\",\n            f = new d.Date(a),\n            g = d.get(e, f);\n        d.set(e, f, g + c);\n        g === d.get(e, f) && d.set(\"Date\", f, 0);\n        return f.getTime() - a;\n      };\n\n      if (I(a)) {\n        var f = c - a;\n        var h = a;\n      } else a && (f = c + e(c, -(a.count || 1)), this.chart && (this.chart.fixedRange = c - f));\n\n      var k = q(this.dataMin, Number.MIN_VALUE);\n      I(f) || (f = k);\n      f <= k && (f = k, \"undefined\" === typeof h && (h = e(f, a.count)), this.newMax = Math.min(f + h, q(this.dataMax, Number.MAX_VALUE)));\n      I(c) ? !I(a) && a && a._offsetMin && (f += a._offsetMin) : f = void 0;\n      return f;\n    };\n\n    if (!B.RangeSelector) {\n      var e = [],\n          u = function (a) {\n        function b() {\n          f && (c = a.xAxis[0].getExtremes(), h = a.legend, l = f && f.options.verticalAlign, I(c.min) && f.render(c.min, c.max), h.display && \"top\" === l && l === h.options.verticalAlign && (k = M(a.spacingBox), k.y = \"vertical\" === h.options.layout ? a.plotTop : k.y + f.getHeight(), h.group.placed = !1, h.align(k)));\n        }\n\n        var c,\n            f = a.rangeSelector,\n            h,\n            k,\n            l;\n        f && (d(e, function (b) {\n          return b[0] === a;\n        }) || e.push([a, [p(a.xAxis[0], \"afterSetExtremes\", function (a) {\n          f && f.render(a.min, a.max);\n        }), p(a, \"redraw\", b)]]), b());\n      };\n\n      p(h, \"afterGetContainer\", function () {\n        this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new x(this));\n      });\n      p(h, \"beforeRender\", function () {\n        var a = this.axes,\n            b = this.rangeSelector;\n        b && (I(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || (\"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0)));\n      });\n      p(h, \"update\", function (a) {\n        var b = a.options.rangeSelector;\n        a = this.rangeSelector;\n        var c = this.extraBottomMargin,\n            d = this.extraTopMargin;\n        b && b.enabled && !k(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new x(this));\n        this.extraTopMargin = this.extraBottomMargin = !1;\n        a && (u(this), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || (\"bottom\" === b ? this.extraBottomMargin = !0 : \"middle\" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== c || this.extraTopMargin !== d) && (this.isDirtyBox = !0);\n      });\n      p(h, \"render\", function () {\n        var a = this.rangeSelector;\n        a && !a.options.floating && (a.render(), a = a.options.verticalAlign, \"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0));\n      });\n      p(h, \"getMargins\", function () {\n        var a = this.rangeSelector;\n        a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));\n      });\n      h.prototype.callbacks.push(u);\n      p(h, \"destroy\", function () {\n        for (var a = 0; a < e.length; a++) {\n          var b = e[a];\n\n          if (b[0] === this) {\n            b[1].forEach(function (a) {\n              return a();\n            });\n            e.splice(a, 1);\n            break;\n          }\n        }\n      });\n      B.RangeSelector = x;\n    }\n\n    return x;\n  });\n  O(h, \"Core/Axis/NavigatorAxis.js\", [h[\"Core/Globals.js\"], h[\"Core/Utilities.js\"]], function (c, h) {\n    var B = c.isTouchDevice,\n        E = h.addEvent,\n        A = h.correctFloat,\n        D = h.defined,\n        F = h.isNumber,\n        y = h.pick,\n        p = function () {\n      function c(b) {\n        this.axis = b;\n      }\n\n      c.prototype.destroy = function () {\n        this.axis = void 0;\n      };\n\n      c.prototype.toFixedRange = function (b, c, h, m) {\n        var f = this.axis,\n            d = f.chart;\n        d = d && d.fixedRange;\n        var k = (f.pointRange || 0) / 2;\n        b = y(h, f.translate(b, !0, !f.horiz));\n        c = y(m, f.translate(c, !0, !f.horiz));\n        f = d && (c - b) / d;\n        D(h) || (b = A(b + k));\n        D(m) || (c = A(c - k));\n        .7 < f && 1.3 > f && (m ? b = c - d : c = b + d);\n        F(b) && F(c) || (b = c = void 0);\n        return {\n          min: b,\n          max: c\n        };\n      };\n\n      return c;\n    }();\n\n    return function () {\n      function c() {}\n\n      c.compose = function (b) {\n        b.keepProps.push(\"navigatorAxis\");\n        E(b, \"init\", function () {\n          this.navigatorAxis || (this.navigatorAxis = new p(this));\n        });\n        E(b, \"zoom\", function (b) {\n          var c = this.chart.options,\n              h = c.navigator,\n              f = this.navigatorAxis,\n              d = c.chart.zooming.pinchType,\n              k = c.rangeSelector;\n          c = c.chart.zooming.type;\n          this.isXAxis && (h && h.enabled || k && k.enabled) && (\"y\" === c ? b.zoomed = !1 : (!B && \"xy\" === c || B && \"xy\" === d) && this.options.range && (h = f.previousZoom, D(b.newMin) ? f.previousZoom = [this.min, this.max] : h && (b.newMin = h[0], b.newMax = h[1], f.previousZoom = void 0)));\n          \"undefined\" !== typeof b.zoomed && b.preventDefault();\n        });\n      };\n\n      c.AdditionsClass = p;\n      return c;\n    }();\n  });\n  O(h, \"Core/Navigator.js\", [h[\"Core/Axis/Axis.js\"], h[\"Core/Chart/Chart.js\"], h[\"Core/Color/Color.js\"], h[\"Core/Globals.js\"], h[\"Core/Axis/NavigatorAxis.js\"], h[\"Core/DefaultOptions.js\"], h[\"Core/Renderer/RendererRegistry.js\"], h[\"Core/Scrollbar.js\"], h[\"Core/Series/Series.js\"], h[\"Core/Series/SeriesRegistry.js\"], h[\"Core/Utilities.js\"]], function (c, h, B, E, A, D, F, y, p, t, b) {\n    B = B.parse;\n\n    var k = E.hasTouch,\n        n = E.isTouchDevice,\n        m = D.defaultOptions,\n        f = b.addEvent,\n        d = b.clamp,\n        v = b.correctFloat,\n        I = b.defined,\n        M = b.destroyObjectProperties,\n        N = b.erase,\n        H = b.extend,\n        q = b.find,\n        w = b.isArray,\n        a = b.isNumber,\n        x = b.merge,\n        e = b.pick,\n        u = b.removeEvent,\n        l = b.splat,\n        g = function (b) {\n      for (var c = [], d = 1; d < arguments.length; d++) c[d - 1] = arguments[d];\n\n      c = [].filter.call(c, a);\n      if (c.length) return Math[b].apply(0, c);\n    };\n\n    D = \"undefined\" === typeof t.seriesTypes.areaspline ? \"line\" : \"areaspline\";\n    H(m, {\n      navigator: {\n        height: 40,\n        margin: 25,\n        maskInside: !0,\n        handles: {\n          width: 7,\n          height: 15,\n          symbols: [\"navigator-handle\", \"navigator-handle\"],\n          enabled: !0,\n          lineWidth: 1,\n          backgroundColor: \"#f2f2f2\",\n          borderColor: \"#999999\"\n        },\n        maskFill: B(\"#6685c2\").setOpacity(.3).get(),\n        outlineColor: \"#cccccc\",\n        outlineWidth: 1,\n        series: {\n          type: D,\n          fillOpacity: .05,\n          lineWidth: 1,\n          compare: null,\n          dataGrouping: {\n            approximation: \"average\",\n            enabled: !0,\n            groupPixelWidth: 2,\n            firstAnchor: \"firstPoint\",\n            anchor: \"middle\",\n            lastAnchor: \"lastPoint\",\n            units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2, 3, 4]], [\"week\", [1, 2, 3]], [\"month\", [1, 3, 6]], [\"year\", null]]\n          },\n          dataLabels: {\n            enabled: !1,\n            zIndex: 2\n          },\n          id: \"highcharts-navigator-series\",\n          className: \"highcharts-navigator-series\",\n          lineColor: null,\n          marker: {\n            enabled: !1\n          },\n          threshold: null\n        },\n        xAxis: {\n          overscroll: 0,\n          className: \"highcharts-navigator-xaxis\",\n          tickLength: 0,\n          lineWidth: 0,\n          gridLineColor: \"#e6e6e6\",\n          gridLineWidth: 1,\n          tickPixelInterval: 200,\n          labels: {\n            align: \"left\",\n            style: {\n              color: \"#999999\"\n            },\n            x: 3,\n            y: -4\n          },\n          crosshair: !1\n        },\n        yAxis: {\n          className: \"highcharts-navigator-yaxis\",\n          gridLineWidth: 0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: .1,\n          maxPadding: .1,\n          labels: {\n            enabled: !1\n          },\n          crosshair: !1,\n          title: {\n            text: null\n          },\n          tickLength: 0,\n          tickWidth: 0\n        }\n      }\n    });\n\n    F.getRendererType().prototype.symbols[\"navigator-handle\"] = function (a, b, c, d, e) {\n      a = (e && e.width || 0) / 2;\n      b = Math.round(a / 3) + .5;\n      e = e && e.height || 0;\n      return [[\"M\", -a - 1, .5], [\"L\", a, .5], [\"L\", a, e + .5], [\"L\", -a - 1, e + .5], [\"L\", -a - 1, .5], [\"M\", -b, 4], [\"L\", -b, e - 3], [\"M\", b - 1, 4], [\"L\", b - 1, e - 3]];\n    };\n\n    var G = function () {\n      function b(a) {\n        this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.rendered = this.range = this.outlineHeight = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;\n        this.init(a);\n      }\n\n      b.prototype.drawHandle = function (a, b, c, d) {\n        var e = this.navigatorOptions.handles.height;\n        this.handles[b][d](c ? {\n          translateX: Math.round(this.left + this.height / 2),\n          translateY: Math.round(this.top + parseInt(a, 10) + .5 - e)\n        } : {\n          translateX: Math.round(this.left + parseInt(a, 10)),\n          translateY: Math.round(this.top + this.height / 2 - e / 2 - 1)\n        });\n      };\n\n      b.prototype.drawOutline = function (a, b, c, d) {\n        var e = this.navigatorOptions.maskInside,\n            f = this.outline.strokeWidth(),\n            g = f / 2,\n            h = f % 2 / 2;\n        f = this.outlineHeight;\n        var k = this.scrollbarHeight || 0,\n            l = this.size,\n            m = this.left - k,\n            n = this.top;\n        c ? (m -= g, c = n + b + h, b = n + a + h, h = [[\"M\", m + f, n - k - h], [\"L\", m + f, c], [\"L\", m, c], [\"L\", m, b], [\"L\", m + f, b], [\"L\", m + f, n + l + k]], e && h.push([\"M\", m + f, c - g], [\"L\", m + f, b + g])) : (a += m + k - h, b += m + k - h, n += g, h = [[\"M\", m, n], [\"L\", a, n], [\"L\", a, n + f], [\"L\", b, n + f], [\"L\", b, n], [\"L\", m + l + 2 * k, n]], e && h.push([\"M\", a - g, n], [\"L\", b + g, n]));\n        this.outline[d]({\n          d: h\n        });\n      };\n\n      b.prototype.drawMasks = function (a, b, c, d) {\n        var e = this.left,\n            f = this.top,\n            g = this.height;\n\n        if (c) {\n          var h = [e, e, e];\n          var k = [f, f + a, f + b];\n          var l = [g, g, g];\n          var m = [a, b - a, this.size - b];\n        } else h = [e, e + a, e + b], k = [f, f, f], l = [a, b - a, this.size - b], m = [g, g, g];\n\n        this.shades.forEach(function (a, b) {\n          a[d]({\n            x: h[b],\n            y: k[b],\n            width: l[b],\n            height: m[b]\n          });\n        });\n      };\n\n      b.prototype.renderElements = function () {\n        var a = this,\n            b = a.navigatorOptions,\n            c = b.maskInside,\n            d = a.chart,\n            e = d.renderer,\n            f,\n            g = {\n          cursor: d.inverted ? \"ns-resize\" : \"ew-resize\"\n        };\n        a.navigatorGroup = f = e.g(\"navigator\").attr({\n          zIndex: 8,\n          visibility: \"hidden\"\n        }).add();\n        [!c, c, !c].forEach(function (c, h) {\n          var k = e.rect().addClass(\"highcharts-navigator-mask\" + (1 === h ? \"-inside\" : \"-outside\")).add(f);\n          d.styledMode || (k.attr({\n            fill: c ? b.maskFill : \"rgba(0,0,0,0)\"\n          }), 1 === h && k.css(g));\n          a.shades[h] = k;\n        });\n        a.outline = e.path().addClass(\"highcharts-navigator-outline\").add(f);\n        d.styledMode || a.outline.attr({\n          \"stroke-width\": b.outlineWidth,\n          stroke: b.outlineColor\n        });\n        b.handles.enabled && [0, 1].forEach(function (c) {\n          b.handles.inverted = d.inverted;\n          a.handles[c] = e.symbol(b.handles.symbols[c], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);\n          a.handles[c].attr({\n            zIndex: 7 - c\n          }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][c]).add(f);\n\n          if (!d.styledMode) {\n            var h = b.handles;\n            a.handles[c].attr({\n              fill: h.backgroundColor,\n              stroke: h.borderColor,\n              \"stroke-width\": h.lineWidth\n            }).css(g);\n          }\n        });\n      };\n\n      b.prototype.update = function (a) {\n        (this.series || []).forEach(function (a) {\n          a.baseSeries && delete a.baseSeries.navigatorSeries;\n        });\n        this.destroy();\n        x(!0, this.chart.options.navigator, this.options, a);\n        this.init(this.chart);\n      };\n\n      b.prototype.render = function (b, c, f, g) {\n        var h = this.chart,\n            k = this.scrollbarHeight,\n            l,\n            m = this.xAxis,\n            n = m.pointRange || 0;\n        var r = m.navigatorAxis.fake ? h.xAxis[0] : m;\n        var p = this.navigatorEnabled,\n            q,\n            t = this.rendered;\n        var u = h.inverted;\n        var w = h.xAxis[0].minRange,\n            x = h.xAxis[0].options.maxRange;\n\n        if (!this.hasDragged || I(f)) {\n          b = v(b - n / 2);\n          c = v(c + n / 2);\n          if (!a(b) || !a(c)) if (t) f = 0, g = e(m.width, r.width);else return;\n          this.left = e(m.left, h.plotLeft + k + (u ? h.plotWidth : 0));\n          this.size = q = l = e(m.len, (u ? h.plotHeight : h.plotWidth) - 2 * k);\n          h = u ? k : l + 2 * k;\n          f = e(f, m.toPixels(b, !0));\n          g = e(g, m.toPixels(c, !0));\n          a(f) && Infinity !== Math.abs(f) || (f = 0, g = h);\n          b = m.toValue(f, !0);\n          c = m.toValue(g, !0);\n          var z = Math.abs(v(c - b));\n          z < w ? this.grabbedLeft ? f = m.toPixels(c - w - n, !0) : this.grabbedRight && (g = m.toPixels(b + w + n, !0)) : I(x) && v(z - n) > x && (this.grabbedLeft ? f = m.toPixels(c - x - n, !0) : this.grabbedRight && (g = m.toPixels(b + x + n, !0)));\n          this.zoomedMax = d(Math.max(f, g), 0, q);\n          this.zoomedMin = d(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(f, g), 0, q);\n          this.range = this.zoomedMax - this.zoomedMin;\n          q = Math.round(this.zoomedMax);\n          f = Math.round(this.zoomedMin);\n          p && (this.navigatorGroup.attr({\n            visibility: \"inherit\"\n          }), t = t && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(f, q, u, t), this.drawOutline(f, q, u, t), this.navigatorOptions.handles.enabled && (this.drawHandle(f, 0, u, t), this.drawHandle(q, 1, u, t)));\n          this.scrollbar && (u ? (u = this.top - k, r = this.left - k + (p || !r.opposite ? 0 : (r.titleOffset || 0) + r.axisTitleMargin), k = l + 2 * k) : (u = this.top + (p ? this.height : -k), r = this.left - k), this.scrollbar.position(r, u, h, k), this.scrollbar.setRange(this.zoomedMin / (l || 1), this.zoomedMax / (l || 1)));\n          this.rendered = !0;\n        }\n      };\n\n      b.prototype.addMouseEvents = function () {\n        var a = this,\n            b = a.chart,\n            c = b.container,\n            d = [],\n            e,\n            g;\n\n        a.mouseMoveHandler = e = function (b) {\n          a.onMouseMove(b);\n        };\n\n        a.mouseUpHandler = g = function (b) {\n          a.onMouseUp(b);\n        };\n\n        d = a.getPartsEvents(\"mousedown\");\n        d.push(f(b.renderTo, \"mousemove\", e), f(c.ownerDocument, \"mouseup\", g));\n        k && (d.push(f(b.renderTo, \"touchmove\", e), f(c.ownerDocument, \"touchend\", g)), d.concat(a.getPartsEvents(\"touchstart\")));\n        a.eventsToUnbind = d;\n        a.series && a.series[0] && d.push(f(a.series[0].xAxis, \"foundExtremes\", function () {\n          b.navigator.modifyNavigatorAxisExtremes();\n        }));\n      };\n\n      b.prototype.getPartsEvents = function (a) {\n        var b = this,\n            c = [];\n        [\"shades\", \"handles\"].forEach(function (d) {\n          b[d].forEach(function (e, g) {\n            c.push(f(e.element, a, function (a) {\n              b[d + \"Mousedown\"](a, g);\n            }));\n          });\n        });\n        return c;\n      };\n\n      b.prototype.shadesMousedown = function (a, b) {\n        a = this.chart.pointer.normalize(a);\n        var c = this.chart,\n            d = this.xAxis,\n            e = this.zoomedMin,\n            f = this.left,\n            g = this.size,\n            h = this.range,\n            k = a.chartX;\n        c.inverted && (k = a.chartY, f = this.top);\n        if (1 === b) this.grabbedCenter = k, this.fixedWidth = h, this.dragOffset = k - e;else {\n          a = k - f - h / 2;\n          if (0 === b) a = Math.max(0, a);else if (2 === b && a + h >= g) if (a = g - h, this.reversedExtremes) {\n            a -= h;\n            var l = this.getUnionExtremes().dataMin;\n          } else var m = this.getUnionExtremes().dataMax;\n          a !== e && (this.fixedWidth = h, b = d.navigatorAxis.toFixedRange(a, a + h, l, m), I(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, {\n            trigger: \"navigator\"\n          }));\n        }\n      };\n\n      b.prototype.handlesMousedown = function (a, b) {\n        this.chart.pointer.normalize(a);\n        a = this.chart;\n        var c = a.xAxis[0],\n            d = this.reversedExtremes;\n        0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? c.max : c.min);\n        a.fixedRange = null;\n      };\n\n      b.prototype.onMouseMove = function (a) {\n        var b = this,\n            c = b.chart,\n            d = b.left,\n            f = b.navigatorSize,\n            g = b.range,\n            h = b.dragOffset,\n            k = c.inverted;\n        a.touches && 0 === a.touches[0].pageX || (a = c.pointer.normalize(a), c = a.chartX, k && (d = b.top, c = a.chartY), b.grabbedLeft ? (b.hasDragged = !0, b.render(0, 0, c - d, b.otherHandlePos)) : b.grabbedRight ? (b.hasDragged = !0, b.render(0, 0, b.otherHandlePos, c - d)) : b.grabbedCenter && (b.hasDragged = !0, c < h ? c = h : c > f + h - g && (c = f + h - g), b.render(0, 0, c - h, c - h + g)), b.hasDragged && b.scrollbar && e(b.scrollbar.options.liveRedraw, E.svg && !n && !this.chart.boosted) && (a.DOMType = a.type, setTimeout(function () {\n          b.onMouseUp(a);\n        }, 0)));\n      };\n\n      b.prototype.onMouseUp = function (b) {\n        var c = this.chart,\n            d = this.xAxis,\n            e = this.scrollbar,\n            f = b.DOMEvent || b,\n            g = c.inverted,\n            h = this.rendered && !this.hasDragged ? \"animate\" : \"attr\";\n\n        if (this.hasDragged && (!e || !e.hasDragged) || \"scrollbar\" === b.trigger) {\n          e = this.getUnionExtremes();\n          if (this.zoomedMin === this.otherHandlePos) var k = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var l = this.fixedExtreme;\n          this.zoomedMax === this.size && (l = this.reversedExtremes ? e.dataMin : e.dataMax);\n          0 === this.zoomedMin && (k = this.reversedExtremes ? e.dataMax : e.dataMin);\n          d = d.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, k, l);\n          I(d.min) && c.xAxis[0].setExtremes(Math.min(d.min, d.max), Math.max(d.min, d.max), !0, this.hasDragged ? !1 : null, {\n            trigger: \"navigator\",\n            triggerOp: \"navigator-drag\",\n            DOMEvent: f\n          });\n        }\n\n        \"mousemove\" !== b.DOMType && \"touchmove\" !== b.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);\n        this.navigatorEnabled && a(this.zoomedMin) && a(this.zoomedMax) && (c = Math.round(this.zoomedMin), b = Math.round(this.zoomedMax), this.shades && this.drawMasks(c, b, g, h), this.outline && this.drawOutline(c, b, g, h), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(c, 0, g, h), this.drawHandle(b, 1, g, h)));\n      };\n\n      b.prototype.removeEvents = function () {\n        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind = void 0);\n        this.removeBaseSeriesEvents();\n      };\n\n      b.prototype.removeBaseSeriesEvents = function () {\n        var a = this.baseSeries || [];\n        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {\n          u(a, \"updatedData\", this.updatedDataHandler);\n        }, this), a[0].xAxis && u(a[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n      };\n\n      b.prototype.init = function (a) {\n        var b = a.options,\n            d = b.navigator,\n            h = d.enabled,\n            k = b.scrollbar,\n            l = k.enabled;\n        b = h ? d.height : 0;\n        var m = l ? k.height : 0;\n        this.handles = [];\n        this.shades = [];\n        this.chart = a;\n        this.setBaseSeries();\n        this.height = b;\n        this.scrollbarHeight = m;\n        this.scrollbarEnabled = l;\n        this.navigatorEnabled = h;\n        this.navigatorOptions = d;\n        this.scrollbarOptions = k;\n        this.outlineHeight = b + m;\n        this.opposite = e(d.opposite, !(h || !a.inverted));\n        var n = this;\n        h = n.baseSeries;\n        k = a.xAxis.length;\n        l = a.yAxis.length;\n        var p = h && h[0] && h[0].xAxis || a.xAxis[0] || {\n          options: {}\n        };\n        a.isDirtyBox = !0;\n        n.navigatorEnabled ? (n.xAxis = new c(a, x({\n          breaks: p.options.breaks,\n          ordinal: p.options.ordinal\n        }, d.xAxis, {\n          id: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          isX: !0,\n          type: \"datetime\",\n          index: k,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: 0,\n          maxPadding: 0,\n          zoomEnabled: !1\n        }, a.inverted ? {\n          offsets: [m, 0, -m, 0],\n          width: b\n        } : {\n          offsets: [0, -m, 0, m],\n          height: b\n        })), n.yAxis = new c(a, x(d.yAxis, {\n          id: \"navigator-y-axis\",\n          alignTicks: !1,\n          offset: 0,\n          index: l,\n          isInternal: !0,\n          reversed: e(d.yAxis && d.yAxis.reversed, a.yAxis[0] && a.yAxis[0].reversed, !1),\n          zoomEnabled: !1\n        }, a.inverted ? {\n          width: b\n        } : {\n          height: b\n        })), h || d.series.data ? n.updateNavigatorSeries(!1) : 0 === a.series.length && (n.unbindRedraw = f(a, \"beforeRedraw\", function () {\n          0 < a.series.length && !n.series && (n.setBaseSeries(), n.unbindRedraw());\n        })), n.reversedExtremes = a.inverted && !n.xAxis.reversed || !a.inverted && n.xAxis.reversed, n.renderElements(), n.addMouseEvents()) : (n.xAxis = {\n          chart: a,\n          navigatorAxis: {\n            fake: !0\n          },\n          translate: function (b, c) {\n            var d = a.xAxis[0],\n                e = d.getExtremes(),\n                f = d.len - 2 * m,\n                h = g(\"min\", d.options.min, e.dataMin);\n            d = g(\"max\", d.options.max, e.dataMax) - h;\n            return c ? b * d / f + h : f * (b - h) / d;\n          },\n          toPixels: function (a) {\n            return this.translate(a);\n          },\n          toValue: function (a) {\n            return this.translate(a, !0);\n          }\n        }, n.xAxis.navigatorAxis.axis = n.xAxis, n.xAxis.navigatorAxis.toFixedRange = A.AdditionsClass.prototype.toFixedRange.bind(n.xAxis.navigatorAxis));\n        a.options.scrollbar.enabled && (a.scrollbar = n.scrollbar = new y(a.renderer, x(a.options.scrollbar, {\n          margin: n.navigatorEnabled ? 0 : 10,\n          vertical: a.inverted\n        }), a), f(n.scrollbar, \"changed\", function (a) {\n          var b = n.size,\n              c = b * this.to;\n          b *= this.from;\n          n.hasDragged = n.scrollbar.hasDragged;\n          n.render(0, 0, b, c);\n          this.shouldUpdateExtremes(a.DOMType) && setTimeout(function () {\n            n.onMouseUp(a);\n          });\n        }));\n        n.addBaseSeriesEvents();\n        n.addChartEvents();\n      };\n\n      b.prototype.getUnionExtremes = function (a) {\n        var b = this.chart.xAxis[0],\n            c = this.xAxis,\n            d = c.options,\n            f = b.options,\n            h;\n        a && null === b.dataMin || (h = {\n          dataMin: e(d && d.min, g(\"min\", f.min, b.dataMin, c.dataMin, c.min)),\n          dataMax: e(d && d.max, g(\"max\", f.max, b.dataMax, c.dataMax, c.max))\n        });\n        return h;\n      };\n\n      b.prototype.setBaseSeries = function (a, b) {\n        var c = this.chart,\n            d = this.baseSeries = [];\n        a = a || c.options && c.options.navigator.baseSeries || (c.series.length ? q(c.series, function (a) {\n          return !a.options.isInternal;\n        }).index : 0);\n        (c.series || []).forEach(function (b, c) {\n          b.options.isInternal || !b.options.showInNavigator && (c !== a && b.options.id !== a || !1 === b.options.showInNavigator) || d.push(b);\n        });\n        this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, b);\n      };\n\n      b.prototype.updateNavigatorSeries = function (a, b) {\n        var c = this,\n            d = c.chart,\n            f = c.baseSeries,\n            g,\n            h,\n            k = c.navigatorOptions.series,\n            n,\n            p = {\n          enableMouseTracking: !1,\n          index: null,\n          linkedTo: null,\n          group: \"nav\",\n          padXAxis: !1,\n          xAxis: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          showInLegend: !1,\n          stacking: void 0,\n          isInternal: !0,\n          states: {\n            inactive: {\n              opacity: 1\n            }\n          }\n        },\n            r = c.series = (c.series || []).filter(function (a) {\n          var b = a.baseSeries;\n          return 0 > f.indexOf(b) ? (b && (u(b, \"updatedData\", c.updatedDataHandler), delete b.navigatorSeries), a.chart && a.destroy(), !1) : !0;\n        });\n        f && f.length && f.forEach(function (a) {\n          var q = a.navigatorSeries,\n              t = H({\n            color: a.color,\n            visible: a.visible\n          }, w(k) ? m.navigator.series : k);\n          q && !1 === c.navigatorOptions.adaptToUpdatedData || (p.name = \"Navigator \" + f.length, g = a.options || {}, n = g.navigatorOptions || {}, t.dataLabels = l(t.dataLabels), h = x(g, p, t, n), h.pointRange = e(t.pointRange, n.pointRange, m.plotOptions[h.type || \"line\"].pointRange), t = n.data || t.data, c.hasNavigatorData = c.hasNavigatorData || !!t, h.data = t || g.data && g.data.slice(0), q && q.options ? q.update(h, b) : (a.navigatorSeries = d.initSeries(h), a.navigatorSeries.baseSeries = a, r.push(a.navigatorSeries)));\n        });\n        if (k.data && (!f || !f.length) || w(k)) c.hasNavigatorData = !1, k = l(k), k.forEach(function (a, b) {\n          p.name = \"Navigator \" + (r.length + 1);\n          h = x(m.navigator.series, {\n            color: d.series[b] && !d.series[b].options.isInternal && d.series[b].color || d.options.colors[b] || d.options.colors[0]\n          }, p, a);\n          h.data = a.data;\n          h.data && (c.hasNavigatorData = !0, r.push(d.initSeries(h)));\n        });\n        a && this.addBaseSeriesEvents();\n      };\n\n      b.prototype.addBaseSeriesEvents = function () {\n        var a = this,\n            b = a.baseSeries || [];\n        b[0] && b[0].xAxis && b[0].eventsToUnbind.push(f(b[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n        b.forEach(function (b) {\n          b.eventsToUnbind.push(f(b, \"show\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n          }));\n          b.eventsToUnbind.push(f(b, \"hide\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n          }));\n          !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && b.eventsToUnbind.push(f(b, \"updatedData\", this.updatedDataHandler));\n          b.eventsToUnbind.push(f(b, \"remove\", function () {\n            this.navigatorSeries && (N(a.series, this.navigatorSeries), I(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n          }));\n        }, this);\n      };\n\n      b.prototype.getBaseSeriesMin = function (a) {\n        return this.baseSeries.reduce(function (a, b) {\n          return Math.min(a, b.xData && b.xData.length ? b.xData[0] : a);\n        }, a);\n      };\n\n      b.prototype.modifyNavigatorAxisExtremes = function () {\n        var a = this.xAxis,\n            b;\n        \"undefined\" !== typeof a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));\n      };\n\n      b.prototype.modifyBaseAxisExtremes = function () {\n        var b = this.chart.navigator,\n            c = this.getExtremes(),\n            d = c.dataMin,\n            f = c.dataMax;\n        c = c.max - c.min;\n        var g = b.stickToMin,\n            h = b.stickToMax,\n            k = e(this.options.overscroll, 0),\n            l = b.series && b.series[0],\n            m = !!this.setExtremes;\n\n        if (!this.eventArgs || \"rangeSelectorButton\" !== this.eventArgs.trigger) {\n          if (g) {\n            var n = d;\n            var p = n + c;\n          }\n\n          h && (p = f + k, g || (n = Math.max(d, p - c, b.getBaseSeriesMin(l && l.xData ? l.xData[0] : -Number.MAX_VALUE))));\n          m && (g || h) && a(n) && (this.min = this.userMin = n, this.max = this.userMax = p);\n        }\n\n        b.stickToMin = b.stickToMax = null;\n      };\n\n      b.prototype.updatedDataHandler = function () {\n        var a = this.chart.navigator,\n            b = this.navigatorSeries;\n        a.stickToMax = e(this.chart.options.navigator && this.chart.options.navigator.stickToMax, a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size));\n        a.stickToMin = a.shouldStickToMin(this, a);\n        b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));\n      };\n\n      b.prototype.shouldStickToMin = function (b, c) {\n        c = c.getBaseSeriesMin(b.xData[0]);\n        var d = b.xAxis;\n        b = d.max;\n        var e = d.min;\n        d = d.options.range;\n        return a(b) && a(e) ? d && 0 < b - c ? b - c < d : e <= c : !1;\n      };\n\n      b.prototype.addChartEvents = function () {\n        this.eventsToUnbind || (this.eventsToUnbind = []);\n        this.eventsToUnbind.push(f(this.chart, \"redraw\", function () {\n          var a = this.navigator,\n              b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);\n          b && a.render(b.min, b.max);\n        }), f(this.chart, \"getMargins\", function () {\n          var a = this.navigator,\n              b = a.opposite ? \"plotTop\" : \"marginBottom\";\n          this.inverted && (b = a.opposite ? \"marginRight\" : \"plotLeft\");\n          this[b] = (this[b] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;\n        }));\n      };\n\n      b.prototype.destroy = function () {\n        this.removeEvents();\n        this.xAxis && (N(this.chart.xAxis, this.xAxis), N(this.chart.axes, this.xAxis));\n        this.yAxis && (N(this.chart.yAxis, this.yAxis), N(this.chart.axes, this.yAxis));\n        (this.series || []).forEach(function (a) {\n          a.destroy && a.destroy();\n        });\n        \"series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered\".split(\" \").forEach(function (a) {\n          this[a] && this[a].destroy && this[a].destroy();\n          this[a] = null;\n        }, this);\n        [this.handles].forEach(function (a) {\n          M(a);\n        }, this);\n      };\n\n      return b;\n    }();\n\n    E.Navigator || (E.Navigator = G, A.compose(c), f(h, \"beforeShowResetZoom\", function () {\n      var a = this.options,\n          b = a.navigator,\n          c = a.rangeSelector;\n      if ((b && b.enabled || c && c.enabled) && (!n && \"x\" === a.chart.zooming.type || n && \"x\" === a.chart.zooming.pinchType)) return !1;\n    }), f(h, \"beforeRender\", function () {\n      var a = this.options;\n      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new G(this);\n    }), f(h, \"afterSetChartSize\", function () {\n      var a = this.legend,\n          b = this.navigator;\n\n      if (b) {\n        var c = a && a.options;\n        var d = b.xAxis;\n        var f = b.yAxis;\n        var g = b.scrollbarHeight;\n        this.inverted ? (b.left = b.opposite ? this.chartWidth - g - b.height : this.spacing[3] + g, b.top = this.plotTop + g) : (b.left = e(d.left, this.plotLeft + g), b.top = b.navigatorOptions.top || this.chartHeight - b.height - g - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (c && \"bottom\" === c.verticalAlign && \"proximate\" !== c.layout && c.enabled && !c.floating ? a.legendHeight + e(c.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));\n        d && f && (this.inverted ? d.options.left = f.options.left = b.left : d.options.top = f.options.top = b.top, d.setAxisSize(), f.setAxisSize());\n      }\n    }), f(h, \"update\", function (a) {\n      var b = a.options.navigator || {},\n          c = a.options.scrollbar || {};\n      this.navigator || this.scroller || !b.enabled && !c.enabled || (x(!0, this.options.navigator, b), x(!0, this.options.scrollbar, c), delete a.options.navigator, delete a.options.scrollbar);\n    }), f(h, \"afterUpdate\", function (a) {\n      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new G(this), e(a.redraw, !0) && this.redraw(a.animation));\n    }), f(h, \"afterAddSeries\", function () {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    }), f(p, \"afterUpdate\", function () {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    }), h.prototype.callbacks.push(function (a) {\n      var b = a.navigator;\n      b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));\n    }));\n    E.Navigator = G;\n    return E.Navigator;\n  });\n  O(h, \"masters/modules/gantt.src.js\", [h[\"Core/Globals.js\"], h[\"Series/XRange/XRangeSeries.js\"], h[\"Core/Chart/GanttChart.js\"], h[\"Core/Scrollbar.js\"]], function (c, h, B, E) {\n    c.Scrollbar = E;\n    c.GanttChart = B;\n    c.ganttChart = B.ganttChart;\n    E.compose(c.Axis);\n    h.compose(c.Axis);\n  });\n  O(h, \"masters/highcharts-gantt.src.js\", [h[\"masters/highcharts.src.js\"]], function (c) {\n    c.product = \"Highcharts Gantt\";\n    return c;\n  });\n  h[\"masters/highcharts-gantt.src.js\"]._modules = h;\n  return h[\"masters/highcharts-gantt.src.js\"];\n}); //# sourceMappingURL=highcharts-gantt.js.map","map":null,"metadata":{},"sourceType":"script"}